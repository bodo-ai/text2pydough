RAG Response for Example 3
==================================================

Full RAG Results Dictionary:
{'generated_answer': '# Explanation of Pydough Code for Finding Top 10 Unshipped Orders\n\n## Overview\n\nThe provided Pydough code implements TPC-H query #3, which finds the 10 unshipped orders with the highest value as of March 15th, 1995. Let me explain the code in detail based on the provided documentation.\n\n## Pydough-Specific Functions and Patterns\n\n### 1. WHERE Function\nThe code uses the `WHERE` function to filter data based on specific conditions:\n\n```python\nselected_orders = orders.WHERE(\n    (customer.mktsegment == "BUILDING") & (order_date < cutoff_date)\n)\n```\n\nThis pattern is seen in multiple examples in the documentation [82a3091], where `WHERE` is used to filter collections based on boolean conditions.\n\n### 2. PARTITION Function\nThe `PARTITION` function is used to group data by specific keys and perform aggregations:\n\n```python\nresult = PARTITION(\n    selected_lines, name="l", by=(order_key, order_date, ship_priority)\n)(\n    L_ORDERKEY=order_key,\n    REVENUE=SUM(l.extended_price * (1 - l.discount)),\n    O_ORDERDATE=order_date,\n    O_SHIPPRIORITY=ship_priority,\n)\n```\n\nThis is similar to the pattern shown in [407f517] where `PARTITION` is used to group customer information by the number of non-special orders:\n\n```python\noutput = PARTITION(customer_info, name="custs", by=num_non_special_orders).CALCULATE(\n    C_COUNT=num_non_special_orders, CUSTDIST=COUNT(custs)\n)\n```\n\n### 3. TOP_K Function\nThe `TOP_K` function is used to limit results to the top K items based on specified ordering:\n\n```python\n.TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\n```\n\nThis pattern is demonstrated in [82a3091] where `TOP_K` is used to get the top 100 results:\n\n```python\n.TOP_K(\n    100,\n    by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\n)\n```\n\n### 4. BACK Function\nThe `BACK` function is used to reference parent collections in the data hierarchy:\n\n```python\nselected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)(\n    BACK(1).order_date,\n    BACK(1).ship_priority,\n)\n```\n\nAccording to [e676197], `BACK` is used to reference previous items in a sequence, such as in time-series data.\n\n### 5. Aggregation Functions (SUM)\nThe code uses the `SUM` aggregation function to calculate the total revenue:\n\n```python\nREVENUE=SUM(l.extended_price * (1 - l.discount))\n```\n\nThis pattern is seen in [82a3091] where `SUM` is used to calculate various aggregations.\n\n## Data Flow and Transformations\n\nThe code follows a clear data flow:\n\n1. **Define a cutoff date**: `cutoff_date = datetime.date(1995, 3, 15)`\n\n2. **Filter orders**: Select orders from the "BUILDING" market segment that were placed before the cutoff date [82a3091]:\n   ```python\n   selected_orders = orders.WHERE(\n       (customer.mktsegment == "BUILDING") & (order_date < cutoff_date)\n   )\n   ```\n\n3. **Filter line items**: From the selected orders, get line items that haven\'t shipped yet (ship date after cutoff date) and include order date and shipping priority from the parent order [82a3091]:\n   ```python\n   selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)(\n       BACK(1).order_date,\n       BACK(1).ship_priority,\n   )\n   ```\n\n4. **Group and aggregate**: Group the selected line items by order key, order date, and shipping priority, then calculate the revenue for each group [82a3091]:\n   ```python\n   result = PARTITION(\n       selected_lines, name="l", by=(order_key, order_date, ship_priority)\n   )(\n       L_ORDERKEY=order_key,\n       REVENUE=SUM(l.extended_price * (1 - l.discount)),\n       O_ORDERDATE=order_date,\n       O_SHIPPRIORITY=ship_priority,\n   )\n   ```\n\n5. **Sort and limit**: Get the top 10 orders with the highest revenue, breaking ties by order date (ascending) and then order key (ascending) [82a3091]:\n   ```python\n   .TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\n   ```\n\n## Pydough Best Practices Demonstrated\n\n1. **Clear variable naming**: Variables like `cutoff_date`, `selected_orders`, and `selected_lines` clearly indicate their purpose [82a3091].\n\n2. **Progressive data refinement**: The code starts with all orders and progressively filters and transforms the data [82a3091].\n\n3. **Efficient use of relationships**: The code leverages the relationship between orders and line items using the `.lines` accessor [82a3091].\n\n4. **Proper use of BACK**: The code uses `BACK(1)` to reference parent collections when needed [e676197].\n\n5. **Appropriate sorting**: The code uses multiple sorting criteria to ensure deterministic results [82a3091].\n\n## How the Code Follows Pydough Conventions\n\n1. **Chaining operations**: The code chains operations like `WHERE`, `PARTITION`, and `TOP_K` to create a readable data pipeline [82a3091].\n\n2. **Using parentheses for method arguments**: The code uses parentheses to pass arguments to methods [82a3091].\n\n3. **Using aliases in PARTITION**: The code assigns a name (`"l"`) to the partitioned elements for reference in aggregations [407f517].\n\n4. **Using descriptive column names**: The output columns are named according to the TPC-H specification (L_ORDERKEY, REVENUE, etc.) [82a3091].\n\n## How the Code Addresses the Original Question\n\nThe code directly addresses the requirements of TPC-H query #3:\n\n1. It filters orders to those from the "BUILDING" market segment placed before March 15th, 1995 [82a3091].\n\n2. It identifies line items that haven\'t shipped yet (ship date after March 15th, 1995) [82a3091].\n\n3. It calculates the potential revenue for each order as the sum of extended price times (1 - discount) [82a3091].\n\n4. It returns the top 10 orders with the highest revenue, sorted by revenue (descending), order date (ascending), and order key (ascending) [82a3091].\n\n5. For each order, it includes the order key, revenue, order date, and shipping priority [82a3091].\n\n## Comparison with SQL\n\nThe Pydough code is equivalent to the SQL query shown in [82a3091]:\n\n```sql\nSELECT\n  L_ORDERKEY,\n  SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\n  O_ORDERDATE,\n  O_SHIPPRIORITY\nFROM\n  CUSTOMER,\n  ORDERS,\n  LINEITEM\nWHERE\n  C_MKTSEGMENT = \'BUILDING\'\n  AND C_CUSTKEY = O_CUSTKEY\n  AND L_ORDERKEY = O_ORDERKEY\n  AND O_ORDERDATE < DATE \'1995-03-15\'\n  AND L_SHIPDATE > DATE \'1995-03-15\'\nGROUP BY\n  L_ORDERKEY,\n  O_ORDERDATE,\n  O_SHIPPRIORITY\nORDER BY\n  REVENUE DESC,\n  O_ORDERDATE\nLIMIT 10;\n```\n\nThe Pydough code achieves the same result with a more readable and concise syntax, leveraging the relationships between entities in the data model.', 'search_results': AggregateSearchResult(chunk_search_results=[ChunkSearchResult(score=0.049, text=]

},

{

"cell_type": "code",

"execution_count": null,

"id": "27365f94-32a0-48f1-9589-711d57cf145b",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_parts = (\n",

" nations.CALCULATE(n_name=name)\n",

" .WHERE(region.name == \"EUROPE\")\n",

" .suppliers.CALCULATE(\n",

" s_acctbal=account_balance,\n",

" s_name=name,\n",

" s_address=address,\n",

" s_phone=phone,\n",

" s_comment=comment,\n",

" )\n",

" .supply_records.CALCULATE(\n",

" supplycost=supplycost,\n",

" )\n",

" .part.WHERE(ENDSWITH(part_type, \"BRASS\") & (size == 15))\n",

" )\n",

"part_groups = PARTITION(selected_parts, name=\"p\", by=key).CALCULATE(\n",

" best_cost=MIN(p.supplycost)\n",

")\n",

"output = part_groups.p.WHERE(\n",

" (supplycost == best_cost)\n",

" & ENDSWITH(part_type, \"BRASS\")\n",

" & (size == 15)\n",

").CALCULATE(\n",

" S_ACCTBAL=s_acctbal,\n",

" S_NAME=s_name,\n",

" N_NAME=n_name,\n",

" P_PARTKEY=key,\n",

" P_MFGR=manufacturer,\n",

" S_ADDRESS=s_address,\n",

" S_PHONE=s_phone,\n",

" S_COMMENT=s_comment,\n",

").TOP_K(\n",

" 100,\n",

" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\n",

")\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "c4979e37-388e-48df-9165-ecd3c71571c1",

"metadata": {},

"source": [

"## Query 3\n",

"\n",

"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" L_ORDERKEY,\n",

" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\n",

" O_ORDERDATE,\n",

" O_SHIPPRIORITY\n",

"FROM\n",

" CUSTOMER,\n",

" ORDERS,\n",

" LINEITEM\n",

"WHERE\n",

" C_MKTSEGMENT = 'BUILDING'\n",

" AND C_CUSTKEY = O_CUSTKEY\n",

" AND L_ORDERKEY = O_ORDERKEY\n",

" AND O_ORDERDATE < DATE '1995-03-15'\n",

" AND L_SHIPDATE > DATE '1995-03-15'\n",

"GROUP BY\n",

" L_ORDERKEY,\n",

" O_ORDERDATE,\n",

" O_SHIPPRIORITY\n",

"ORDER BY\n",

" REVENUE DESC,\n",

" O_ORDERDATE\n",

"LIMIT 10;\n",

"```\n",

"\n",

"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"cutoff_date = datetime.date(1995, 3, 15)\n",

"selected_orders = orders.CALCULATE(\n",

" order_date, ship_priority\n",

").WHERE(\n",

" (customer.mktsegment == \"BUILDING\") & (order_date < cutoff_date)\n",

")\n",

"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\n",

"output = PARTITION(\n",

" selected_lines, name=\"l\", by=(order_key, order_date, ship_priority)\n",

").CALCULATE(\n",

" L_ORDERKEY=order_key,\n",

" REVENUE=SUM(l.extended_price * (1 - l.discount)),\n",

" O_ORDERDATE=order_date,\n",

" O_SHIPPRIORITY=ship_priority,\n",

").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "a72bd083-12c7-402e-8b44-22d640308a7f",

"metadata": {},), ChunkSearchResult(score=0.047, text="source": [

"%%pydough\n",

"\n",

"customer_info = customers.CALCULATE(\n",

" key,\n",

" num_non_special_orders=COUNT(\n",

" orders.WHERE(~(LIKE(comment, \"%special%requests%\")))\n",

" ),\n",

")\n",

"output = PARTITION(customer_info, name=\"custs\", by=num_non_special_orders).CALCULATE(\n",

" C_COUNT=num_non_special_orders, CUSTDIST=COUNT(custs)\n",

").ORDER_BY(CUSTDIST.DESC(), C_COUNT.DESC())\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "1f793b72-d8ce-4f82-84b5-7e568ee0600a",

"metadata": {},

"source": [

"## Query 14\n",

"\n",

"This question seeks seeks to determine **the impact of a promotion on revenue within a particular month**. More specifically, it determines what percentage of the revenue in a given year and month was derived from promotional parts. The query considers only parts actually shipped in that month and gives the percentage. Revenue is defined as extended price times one minus the discount. The chosen year and month are September of 1995.\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" 100.00 * SUM(CASE\n",

" WHEN P_TYPE LIKE 'PROMO%'\n",

" THEN L_EXTENDEDPRICE * (1 - L_DISCOUNT)\n",

" ELSE 0\n",

" END) / SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS PROMO_REVENUE\n",

"FROM\n",

" LINEITEM,\n",

" PART\n",

"WHERE\n",

" L_PARTKEY = P_PARTKEY\n",

" AND L_SHIPDATE >= DATE '1995-09-01'\n",

" AND L_SHIPDATE < DATE '1995-10-01';\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "8a843681-0893-4636-a312-75095c730de3",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"value = extended_price * (1 - discount)\n",

"selected_lines = lines.WHERE(\n",

" (ship_date >= datetime.date(1995, 9, 1))\n",

" & (ship_date < datetime.date(1995, 10, 1))\n",

").CALCULATE(\n",

" value=value,\n",

" promo_value=IFF(STARTSWITH(part.part_type, \"PROMO\"), value, 0),\n",

")\n",

"output = TPCH.CALCULATE(PROMO_REVENUE=100.0 * SUM(selected_lines.promo_value) / SUM(selected_lines.value))\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "1734b0e1-a4bb-456b-a41e-fa6440c87e85",

"metadata": {},

"source": [

"## Query 15\n",

"\n",

"This question seeks to determine **the top supplier within a particular quarter**. It does so by finding the supplier who contributed the most to the overall revenue for parts shipped during a given quarter of a given year. In case of a tie, the query lists all suppliers whose contribution was equal to the maximum, presented in supplier number order. The chosen quarter is the first 3 months of 1996.\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"with REVENUE (SUPPLIER_NO, TOTAL_REVENUE) AS\n",

" SELECT\n",

" L_SUPPKEY,\n",

" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT))\n",

" FROM\n",

" LINEITEM\n",

" WHERE\n",

" L_SHIPDATE >= DATE '1996-01-01'\n",

" AND L_SHIPDATE < DATE '1996-04-01'\n",

" GROUP BY\n",

" L_SUPPKEY;\n",

"\n",

"SELECT\n",

" S_SUPPKEY,\n",

" S_NAME,\n",

" S_ADDRESS,\n",

" S_PHONE,\n",

" TOTAL_REVENUE\n",

"FROM\n",

" SUPPLIER,\n",

" REVENUE\n",

"WHERE\n",

" S_SUPPKEY = SUPPLIER_NO AND\n",

" TOTAL_REVENUE = (\n",

" SELECT\n",

" MAX(TOTAL_REVENUE)\n",

" FROM\n",

" REVENUE0\n",

" )\n",

"ORDER BY\n",

" SUPPLIER_NO;\n",

"```\n",

"\n",

"With PyDough, the total revenue per-supplier can be expressed via contextless expressions which are first placed into context for the global aggregation to find the maximum revenue overall, then used again to be associated per-supplier."

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "a3f9b025-3ae7-4c7d-888c-a430cbe536b2",

"metadata": {},

"outputs": [],), ChunkSearchResult(score=0.047, text="source": [

"## Query 12\n",

"\n",

"This question seeks to determine **the impact of low cost shipping modes on delays for orders of varying priorities**. It does so by counting, by ship mode, for lineitems actually received by customers in a given year, the number of lineitems belonging to orders for which the receipt date exceeds the commit date for two different specified ship modes. Only lineitems that were actually shipped before the commit date are considered. The late lineitems are partitioned into two groups, those with priority `1-URGENT` or `2-HIGH`, and those with a priority other than `1-URGENT` or `2-HIGH`. The chosen year is 1994, and the two chosen ship modes are mail & ship.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" L_SHIPMODE,\n",

" SUM(CASE\n",

" WHEN O_ORDERPRIORITY = '1-URGENT'\n",

" OR O_ORDERPRIORITY = '2-HIGH'\n",

" THEN 1\n",

" ELSE 0\n",

" END) AS HIGH_LINE_COUNT,\n",

" SUM(CASE\n",

" WHEN O_ORDERPRIORITY <> '1-URGENT'\n",

" AND O_ORDERPRIORITY <> '2-HIGH'\n",

" THEN 1\n",

" ELSE 0\n",

" END) AS LOW_LINE_COUNT\n",

"FROM\n",

" ORDERS,\n",

" LINEITEM\n",

"WHERE\n",

" O_ORDERKEY = L_ORDERKEY\n",

" AND L_SHIPMODE IN ('MAIL', 'SHIP')\n",

" AND L_COMMITDATE < L_RECEIPTDATE\n",

" AND L_SHIPDATE < L_COMMITDATE\n",

" AND L_RECEIPTDATE >= DATE '1994-01-01'\n",

" AND L_RECEIPTDATE < DATE '1995-01-01'\n",

"GROUP BY\n",

" L_SHIPMODE\n",

"ORDER BY\n",

" L_SHIPMODE;\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "7daa2e52-9afb-44dd-8d65-326011776532",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = lines.WHERE(\n",

" ((ship_mode == \"MAIL\") | (ship_mode == \"SHIP\"))\n",

" & (ship_date < commit_date)\n",

" & (commit_date < receipt_date)\n",

" & (receipt_date >= datetime.date(1994, 1, 1))\n",

" & (receipt_date < datetime.date(1995, 1, 1))\n",

").CALCULATE(\n",

" is_high_priority=(order.order_priority == \"1-URGENT\")\n",

" | (order.order_priority == \"2-HIGH\"),\n",

")\n",

"output = PARTITION(selected_lines, \"l\", by=ship_mode).CALCULATE(\n",

" L_SHIPMODE=ship_mode,\n",

" HIGH_LINE_COUNT=SUM(l.is_high_priority),\n",

" LOW_LINE_COUNT=SUM(~(l.is_high_priority)),\n",

").ORDER_BY(L_SHIPMODE.ASC())\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "f6f90a64-4a54-4790-bf80-d3b237f5b5a1",

"metadata": {},

"source": [

"## Query 13\n",

"\n",

"This question seeks to **understand the order count of each customer, including any customer who has not placed an order**. More specifically, it determines the distribution of customers by the number of orders they have made, including customers who have no record of orders, past or present. It counts and reports how many customers have no orders, how many have 1, 2, 3, etc. A check is made to ensure that the orders counted do not fall into one of several special categories of orders. Special categories are identified in the order comment column by looking for a particular pattern. The chosen pattern is comments that contain `'special'`, and later contain `'requests'`.\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" C_COUNT,\n",

" COUNT(*) AS CUSTDIST\n",

"FROM (\n",

" SELECT\n",

" C_CUSTKEY,\n",

" COUNT(O_ORDERKEY) AS C_COUNT\n",

" FROM\n",

" CUSTOMER\n",

" LEFT OUTER JOIN ORDERS ON C_CUSTKEY = O_CUSTKEY\n",

" AND O_COMMENT NOT LIKE '%special%requests%'\n",

" GROUP BY\n",

" C_CUSTKEY\n",

") C_ORDERS\n",

"GROUP BY\n",

" C_COUNT\n",

"ORDER BY\n",

" CUSTDIST DESC,\n",

" C_COUNT DESC;\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "522ee934-1e88-4c93-847b-d1757c372eeb",

"metadata": {},

"outputs": [],), ChunkSearchResult(score=0.046, text=# names in a rolling window.

⋮----

def avg_order_diff_per_customer()

⋮----

# Finds the 5 customers with the highest average difference in days between

# orders made.

prev_order_date_by_cust = PREV(order_date, by=order_date.ASC(), levels=1)

order_info = orders.CALCULATE(

selected_customers = Customers.WHERE(HAS(order_info))

⋮----

def yoy_change_in_num_orders()

⋮----

# For every year, counts the number of orders made in that year and the

# percentage change from the previous year.

years = PARTITION(

current_year_orders = COUNT(orders_in_year)

prev_year_orders = PREV(COUNT(orders_in_year), by=year.ASC())

⋮----

def first_order_in_year()

⋮----

# Find all orders that do not have a previous order in the same year

# (breaking ties by order key).

previous_order_date = PREV(order_date, by=(order_date.ASC(), key.ASC()))

⋮----

def customer_largest_order_deltas()

⋮----

# For each customer, find the highest positive/negative difference in

# revenue between one of their orders and and the most recent order before

# it, ignoring their first ever order. Return the 5 customers with the

# largest such difference. Only consider customers with orders.

line_revenue = extended_price * (1 - discount)

order_revenue = SUM(lines.CALCULATE(r=line_revenue).r)

previous_order_revenue = PREV(order_revenue, by=order_date.ASC(), levels=1)

orders_info = orders.WHERE(PRESENT(previous_order_revenue)).CALCULATE(

⋮----

def suppliers_bal_diffs()

⋮----

# Finds the 5 suppliers with the largest difference in account balance from

# the supplier with the next smallest account balance in the same region.

⋮----

def month_year_sliding_windows()

⋮----

# Finds all months where the total amount spent by customers on orders in

# that month was more than the preceding/following month, and the amount

# spent in that year was more than the following year.

ym_groups = PARTITION(

y_groups = (

⋮----

def avg_gap_prev_urgent_same_clerk()

⋮----

# Finds the average gap in days between each urgent order and the previous

# urgent order handled by the same clerk

urgent_orders = Orders.WHERE(order_priority == "1-URGENT")

clerks = PARTITION(urgent_orders, name="orders", by=clerk)

order_info = clerks.orders.CALCULATE(

⋮----

def nation_window_aggs()

⋮----

# Calculating multiple global windowed aggregations for each nation, only

# considering nations whose names do not start with a vowel.

⋮----

def region_nation_window_aggs()

⋮----

# per-region, considering nations whose names do not start with a vowel.

⋮----

def supplier_pct_national_qty()

⋮----

# Find the 5 African suppliers with the highest percentage of total

# quantity of product shipped from them out of all suppliers in that nation

# meeting certain criteria. Include for each such supplier their name,

# nation name, the quantity, and the percentage. The criteria are that the

# shipments were done in 1998, they were shipped by ship, the part shipped

# had had "tomato" in the name and was a large container. Also, when

# finding the sum for each naiton and the best suppliers, ignore all

# suppliers with a negative account balance and whose comments do not

# contain the word "careful".

selected_lines = lines.WHERE(

supp_qty = SUM(selected_lines.quantity)

⋮----

def highest_priority_per_year()

⋮----

# For each year, identify the priority with the highest percentage of

# made in that year with that priority, listing the year, priority, and

# percentage. Sort the results by year.

order_info = Orders.CALCULATE(order_year=YEAR(order_date))

year_priorities = PARTITION(

years = PARTITION(year_priorities, name="priorities", by=order_year)

⋮----

def nation_best_order()

⋮----

# For each Asian nation, identify the most expensive order made by a

# customer in that nation in 1998, listing the nation name, customer

# name, order key, the order's price, and percentage of the price of

# all orders made in 1998. Order the nations alphabetically.

selected_nations = Nations.WHERE(region.name == "ASIA")

best_order = (

⋮----), ChunkSearchResult(score=0.046, text="source": [

"## Query 6\n",

"\n",

"This question formulated a sample \"what-if\" question, asking **how was revenue impacted over a previous year due to the presence of certain discounts** and potentially speculating on future revenue due to a change in that discount. It considers all the lineitems shipped in a given year with discounts in a certain value (in this case, 0.05 to 0.07). The query lists the amount by which the total revenue would have increased if these discounts had been eliminated for lineitems with l_quantity less than quantity. Note that the potential revenue increase is equal to the sum of the extended price times one minus the discount for all lineitems with discounts and quantities in the qualifying range. The chosen quantity range is quantity values below 24.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" SUM(L_EXTENDEDPRICE * L_DISCOUNT) AS REVENUE\n",

"FROM\n",

" LINEITEM\n",

"WHERE\n",

" L_SHIPDATE >= DATE '1994-01-01'\n",

" AND L_SHIPDATE < DATE '1995-01-01'\n",

" AND L_DISCOUNT BETWEEN 0.05 AND 0.07\n",

" AND L_QUANTITY < 24;\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "6e1edea5-63f0-4542-9bcc-16a3398abe22",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = lines.WHERE(\n",

" (ship_date >= datetime.date(1994, 1, 1))\n",

" & (ship_date < datetime.date(1995, 1, 1))\n",

" & (0.05 <= discount)\n",

" & (discount <= 0.07)\n",

" & (quantity < 24)\n",

").CALCULATE(amt=extended_price * discount)\n",

"output = TPCH.CALCULATE(REVENUE=SUM(selected_lines.amt))\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "3f4c5e4e-b038-4c83-b064-f730612378da",

"metadata": {},

"source": [

"## Query 7\n",

"\n",

"This question asks about **the value of goods shipped between certain nations within a particular year** as a representation for future contract negotiations. More specifically, it finds, for two given nations, the gross discounted revenues derived from lineitems in which parts were shipped from a supplier in either nation to a customer in the other nation during 1995 and 1996. The query lists the supplier nation, the customer nation, the year, and the revenue from shipments that took place in that year. The query orders the answer by Supplier nation, Customer nation, and year (all ascending). The two nations chosen are France and Germany.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" SUPP_NATION,\n",

" CUST_NATION,\n",

" L_YEAR,\n",

" SUM(VOLUME) AS REVENUE\n",

"FROM (\n",

" SELECT\n",

" N1.N_NAME AS SUPP_NATION,\n",

" N2.N_NAME AS CUST_NATION,\n",

" EXTRACT(YEAR FROM L_SHIPDATE) AS L_YEAR,\n",

" L_EXTENDEDPRICE * (1 - L_DISCOUNT) AS VOLUME\n",

" FROM\n",

" SUPPLIER,\n",

" LINEITEM,\n",

" ORDERS,\n",

" CUSTOMER,\n",

" NATION N1,\n",

" NATION N2\n",

" WHERE\n",

" S_SUPPKEY = L_SUPPKEY\n",

" AND O_ORDERKEY = L_ORDERKEY\n",

" AND C_CUSTKEY = O_CUSTKEY\n",

" AND S_NATIONKEY = N1.N_NATIONKEY\n",

" AND C_NATIONKEY = N2.N_NATIONKEY\n",

" AND (\n",

" (N1.N_NAME = 'FRANCE' AND N2.N_NAME = 'GERMANY')\n",

" OR (N1.N_NAME = 'GERMANY' AND N2.N_NAME = 'FRANCE')\n",

" )\n",

" AND L_SHIPDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31'\n",

") SHIPPING\n",

"GROUP BY\n",

" SUPP_NATION,\n",

" CUST_NATION,\n",

" L_YEAR\n",

"ORDER BY\n",

" SUPP_NATION,\n",

" CUST_NATION,\n",

" L_YEAR;\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "45ebb047-324c-4040-8c81-b0d274ef6a3b",

"metadata": {},

"outputs": [],), ChunkSearchResult(score=0.045, text="source": [

"## Query 4\n",

"\n",

"This question seeks to answer **how well the order priority system is working at ensuring that orders are delivered on time within a particular quarter**. It does this by counting the number of orders ordered in a given quarter of a given year in which at least one lineitem was received by the customer later than its committed date. The query lists the count of such orders for each order priority sorted in ascending priority order.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" O_ORDERPRIORITY,\n",

" COUNT(*) AS ORDER_COUNT\n",

"FROM\n",

" ORDERS\n",

"WHERE\n",

" O_ORDERDATE >= DATE '1993-07-01'\n",

" AND O_ORDERDATE < DATE '1993-10-01'\n",

" AND EXISTS (\n",

" SELECT 1\n",

" FROM LINEITEM\n",

" WHERE L_ORDERKEY = O_ORDERKEY\n",

" AND L_COMMITDATE < L_RECEIPTDATE\n",

" )\n",

"GROUP BY\n",

" O_ORDERPRIORITY\n",

"ORDER BY\n",

" O_ORDERPRIORITY;\n",

"```\n",

"\n",

"PyDough handles the `exists` functionality through its use of `HAS`, relying on the underlying relationship between collections to simplify the join/table logic."

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "e7525d29-7edc-4c41-9c48-c1313d6f07a4",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = lines.WHERE(commit_date < receipt_date)\n",

"selected_orders = orders.WHERE(\n",

" (order_date >= datetime.date(1993, 7, 1))\n",

" & (order_date < datetime.date(1993, 10, 1))\n",

" & HAS(selected_lines)\n",

")\n",

"output = PARTITION(selected_orders, name=\"o\", by=order_priority).CALCULATE(\n",

" O_ORDERPRIORITY=order_priority,\n",

" ORDER_COUNT=COUNT(o),\n",

").ORDER_BY(O_ORDERPRIORITY.ASC())\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "d6fee20d",

"metadata": {},

"source": [

"## Query 5\n",

"\n",

"This question seeks to learn about domestic revenue from suppliers in Asian countries. It does so by calculating, for each Asian country, the total revenue generated by suppliers in that nation shipping a part to a customer from the same nation, only considering shipments ordered in 1994. Revenue volume for all qualifying lineitems in a particular nation is defined as `sum(l_extendedprice * (1 - l_discount))`.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"select\n",

" N_NAME,\n",

" sum(l_extendedprice * (1 - l_discount)) as REVENUE\n",

"from\n",

" customer,\n",

" orders,\n",

" lineitem,\n",

" supplier,\n",

" nation,\n",

" region\n",

"where\n",

" c_custkey = o_custkey\n",

" and l_orderkey = o_orderkey\n",

" and l_suppkey = s_suppkey\n",

" and c_nationkey = s_nationkey\n",

" and s_nationkey = n_nationkey\n",

" and n_regionkey = r_regionkey\n",

" and r_name = 'ASIA'\n",

" and o_orderdate >= '1994-01-01'\n",

" and o_orderdate < '1995-01-01'\n",

"group by\n",

" n_name\n",

"order by\n",

" revenue desc\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "4f8eb6d0",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = (\n",

" customers.orders.WHERE(\n",

" (order_date >= datetime.date(1994, 1, 1))\n",

" & (order_date < datetime.date(1995, 1, 1))\n",

" )\n",

" .lines.WHERE(supplier.nation.name == nation_name)\n",

" .CALCULATE(value=extended_price * (1 - discount))\n",

")\n",

"output = (\n",

" nations.CALCULATE(nation_name=name)\n",

" .WHERE(region.name == \"ASIA\")\n",

" .WHERE(HAS(selected_lines))\n",

" .CALCULATE(N_NAME=name, REVENUE=SUM(selected_lines.value))\n",

" .ORDER_BY(REVENUE.DESC())\n",

")\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "c5c4d84b-b3c0-4b58-8635-b1d30ea2946a",

"metadata": {},), ChunkSearchResult(score=0.041, text="source": [

"## Query 17\n",

"\n",

"This question seeks to determine **how much average yearly revenue would be lost if orders were no longer filled for small quantities of certain parts**. It does so by considering parts of a given brand and with a given container type and determines the average lineitem quantity of such parts ordered for all orders (past and pending) in the 7-year database. What would be the average yearly gross (undiscounted) loss in revenue if orders for these parts with a quantity of less than 20% of this average were no longer taken? The chosen brand and container type are `'Brand#23'` and `MED BOX`, respectively.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"select\n",

" sum(l_extendedprice) / 7.0 as avg_yearly\n",

"from\n",

" lineitem,\n",

" part\n",

"where\n",

" p_partkey = l_partkey\n",

" and p_brand = 'Brand#23'\n",

" and p_container = 'MED BOX'\n",

" and l_quantity < (\n",

" select\n",

" 0.2 * avg(l_quantity)\n",

" from\n",

" lineitem\n",

" where\n",

" l_partkey = p_partkey\n",

" )\n",

"```\n",

"\n",

"PyDough bypasses the need for the correlated subquery by first aggregating lineitems by part, then stepping into the lineitems and backreferencing to compare against the per-part average value."

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "4824db18-364b-4ba3-98a2-70ee8930c074",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = parts.WHERE(\n",

" (brand == \"Brand#23\") & (container == \"MED BOX\")\n",

").CALCULATE(\n",

" avg_quantity=AVG(lines.quantity)\n",

").lines.WHERE(quantity < 0.2 * avg_quantity)\n",

"output = TPCH.CALCULATE(AVG_YEARLY=SUM(selected_lines.extended_price) / 7.0)\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "ca71d07c-095b-4dd6-82a6-71cdd69be974",

"metadata": {},

"source": [

"## Query 18\n",

"\n",

"This question seeks to **ranks customers based on their status as having placed a large quantity order**. It does so by calculating a list of the top 100 customers who have ever placed large quantity orders. It lists the customer name, customer key, the order key, date and total price and the quantity for the order.\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"select\n",

" c_name,\n",

" c_custkey,\n",

" o_orderkey,\n",

" o_orderdate,\n",

" o_totalprice,\n",

" sum(l_quantity)\n",

"from\n",

" customer,\n",

" orders,\n",

" lineitem\n",

"where\n",

" o_orderkey in (\n",

" select\n",

" l_orderkey\n",

" from\n",

" lineitem\n",

" group by\n",

" l_orderkey \n",

" having\n",

" sum(l_quantity) > 300\n",

" )\n",

" and c_custkey = o_custkey\n",

" and o_orderkey = l_orderkey\n",

"group by\n",

" c_name,\n",

" c_custkey,\n",

" o_orderkey,\n",

" o_orderdate,\n",

" o_totalprice\n",

"order by\n",

" o_totalprice desc,\n",

" o_orderdate;\n",

"```\n",

"\n",

"Notice that PyDough can simplify this by phrasing this as an operation being done per-order, thus eliding the need to do any manual aggregation."

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "87292649-b89a-4e0d-a438-74bd1aa9656d",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"output = orders.CALCULATE(\n",

" C_NAME=customer.name,\n",

" C_CUSTKEY=customer.key,\n",

" O_ORDERKEY=key,\n",

" O_ORDERDATE=order_date,\n",

" O_TOTALPRICE=total_price,\n",

" TOTAL_QUANTITY=SUM(lines.quantity),\n",

").WHERE(\n",

" TOTAL_QUANTITY > 300\n",

").TOP_K(100, by=(O_TOTALPRICE.DESC(), O_ORDERDATE.ASC()))\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "b27461d3-9720-4dee-9d40-e519ca01c71b",

"metadata": {},), ChunkSearchResult(score=0.030, text=) < COALESCE(_t9.agg_1, 0)

ORDER BY

ordering_2 DESC

LIMIT 10

)

SELECT

ps_partkey AS PS_PARTKEY,

value AS VALUE

FROM _t0_2

ORDER BY

ordering_2 DESC

````

## File: tests/test_sql_refsols/tpch_q12_ansi.sql

````sql

WITH _t1_2 AS (

SELECT

SUM(

(

orders.o_orderpriority <> '1-URGENT' AND orders.o_orderpriority <> '2-HIGH'

)

) AS agg_1,

SUM((

orders.o_orderpriority = '1-URGENT' OR orders.o_orderpriority = '2-HIGH'

)) AS agg_0,

lineitem.l_shipmode AS ship_mode

FROM tpch.lineitem AS lineitem

LEFT JOIN tpch.orders AS orders

ON lineitem.l_orderkey = orders.o_orderkey

WHERE

lineitem.l_commitdate < lineitem.l_receiptdate

AND lineitem.l_commitdate > lineitem.l_shipdate

AND lineitem.l_receiptdate < CAST('1995-01-01' AS DATE)

AND lineitem.l_receiptdate >= CAST('1994-01-01' AS DATE)

AND (

lineitem.l_shipmode = 'MAIL' OR lineitem.l_shipmode = 'SHIP'

)

GROUP BY

lineitem.l_shipmode

)

SELECT

ship_mode AS L_SHIPMODE,

COALESCE(agg_0, 0) AS HIGH_LINE_COUNT,

COALESCE(agg_1, 0) AS LOW_LINE_COUNT

FROM _t1_2

ORDER BY

ship_mode

````

## File: tests/test_sql_refsols/tpch_q12_sqlite.sql

````sql

WITH _t1_2 AS (

SELECT

SUM(

(

orders.o_orderpriority <> '1-URGENT' AND orders.o_orderpriority <> '2-HIGH'

)

) AS agg_1,

SUM((

orders.o_orderpriority = '1-URGENT' OR orders.o_orderpriority = '2-HIGH'

)) AS agg_0,

lineitem.l_shipmode AS ship_mode

FROM tpch.lineitem AS lineitem

LEFT JOIN tpch.orders AS orders

ON lineitem.l_orderkey = orders.o_orderkey

WHERE

lineitem.l_commitdate < lineitem.l_receiptdate

AND lineitem.l_commitdate > lineitem.l_shipdate

AND lineitem.l_receiptdate < '1995-01-01'

AND lineitem.l_receiptdate >= '1994-01-01'

AND (

lineitem.l_shipmode = 'MAIL' OR lineitem.l_shipmode = 'SHIP'

)

GROUP BY

lineitem.l_shipmode

)

SELECT

ship_mode AS L_SHIPMODE,

COALESCE(agg_0, 0) AS HIGH_LINE_COUNT,

COALESCE(agg_1, 0) AS LOW_LINE_COUNT

FROM _t1_2

ORDER BY

ship_mode

````

## File: tests/test_sql_refsols/tpch_q13_ansi.sql

````sql

WITH _t1 AS (

SELECT

COUNT() AS agg_0,

o_custkey AS customer_key

FROM tpch.orders

WHERE

NOT o_comment LIKE '%special%requests%'

GROUP BY

o_custkey

), _t2 AS (

SELECT

COUNT() AS agg_0,

COALESCE(_t1.agg_0, 0) AS num_non_special_orders

FROM tpch.customer AS customer

LEFT JOIN _t1 AS _t1

ON _t1.customer_key = customer.c_custkey

GROUP BY

COALESCE(_t1.agg_0, 0)

), _t0_2 AS (

SELECT

COALESCE(agg_0, 0) AS custdist,

num_non_special_orders AS c_count,

COALESCE(agg_0, 0) AS ordering_1,

num_non_special_orders AS ordering_2

FROM _t2

ORDER BY

ordering_1 DESC,

ordering_2 DESC

LIMIT 10

)

SELECT

c_count AS C_COUNT,

custdist AS CUSTDIST

FROM _t0_2

ORDER BY

ordering_1 DESC,

ordering_2 DESC

````

## File: tests/test_sql_refsols/tpch_q13_sqlite.sql

````sql

WITH _t1 AS (

SELECT

COUNT() AS agg_0,

o_custkey AS customer_key

FROM tpch.orders

WHERE

NOT o_comment LIKE '%special%requests%'

GROUP BY

o_custkey

), _t2 AS (

SELECT

COUNT() AS agg_0,

COALESCE(_t1.agg_0, 0) AS num_non_special_orders

FROM tpch.customer AS customer

LEFT JOIN _t1 AS _t1

ON _t1.customer_key = customer.c_custkey

GROUP BY

COALESCE(_t1.agg_0, 0)

), _t0_2 AS (

SELECT

COALESCE(agg_0, 0) AS custdist,

num_non_special_orders AS c_count,

COALESCE(agg_0, 0) AS ordering_1,

num_non_special_orders AS ordering_2

FROM _t2

ORDER BY

ordering_1 DESC,

ordering_2 DESC

LIMIT 10

)

SELECT

c_count AS C_COUNT,

custdist AS CUSTDIST

FROM _t0_2

ORDER BY

ordering_1 DESC,

ordering_2 DESC

````

## File: tests/test_sql_refsols/tpch_q14_ansi.sql

````sql

WITH _t0_2 AS (

SELECT

SUM(

CASE

WHEN part.p_type LIKE 'PROMO%'

THEN lineitem.l_extendedprice * (

1 - lineitem.l_discount

)

ELSE 0

END

) AS agg_0,

SUM(lineitem.l_extendedprice * (

1 - lineitem.l_discount

)) AS agg_1

FROM tpch.lineitem AS lineitem

LEFT JOIN tpch.part AS part

ON lineitem.l_partkey = part.p_partkey

WHERE

lineitem.l_shipdate < CAST('1995-10-01' AS DATE)

AND lineitem.l_shipdate >= CAST('1995-09-01' AS DATE)

)

SELECT

(

100.0 * COALESCE(agg_0, 0)

) / COALESCE(agg_1, 0) AS PROMO_REVENUE), ChunkSearchResult(score=0.029, text="source": [

"## Query 19\n",

"\n",

"This question seeks to **report the gross discounted revenue resulting from select parts with a set of handling details**. More specifically, it finds the gross discounted revenue for all orders for three different types of parts that were shipped by air and delivered in person. Parts are selected based on the combination of specific brands, a list of containers, and a range of sizes. The allowed combinations are:\n",

"\n",

"- The brand is `'BRAND#12'`, the quantity is between 1 and 11, the size is between 1 and 5, and the container type is one of `['SM CASE', 'SM BOX', 'SM PACK', 'SM PKG']`.\n",

"- The brand is `'BRAND#23'`, the quantity is between 10 and 20, the size is between 1 and 10, and the container type is one of `['MED BAG', 'MED BOX', 'MED PKG', 'MED PACK']`.\n",

"- The brand is `'BRAND#34'`, the quantity is between 20 and 30, the size is between 1 and 15, and the container type is one of `['LG CASE', 'LG BOX', 'LG PACK', 'LG PKG']`.\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"select\n",

" sum(l_extendedprice * (1 - l_discount) ) as revenue\n",

"from\n",

" lineitem,\n",

" part\n",

"where\n",

" (\n",

" p_partkey = l_partkey\n",

" and p_brand = 'Brand#12'\n",

" and p_container in ( 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')\n",

" and l_quantity >= 1 and l_quantity <= 1 + 10\n",

" and p_size between 1 and 5\n",

" and l_shipmode in ('AIR', 'AIR REG')\n",

" and l_shipinstruct = 'DELIVER IN PERSON'\n",

" )\n",

" or\n",

" (\n",

" p_partkey = l_partkey\n",

" and p_brand = 'Brand#23'\n",

" and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')\n",

" and l_quantity >= 10 and l_quantity <= 10 + 10\n",

" and p_size between 1 and 10\n",

" and l_shipmode in ('AIR', 'AIR REG')\n",

" and l_shipinstruct = 'DELIVER IN PERSON'\n",

" )\n",

" or\n",

" (\n",

" p_partkey = l_partkey\n",

" and p_brand = 'Brand#34'\n",

" and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')\n",

" and l_quantity >= 20 and l_quantity <= 20 + 10\n",

" and p_size between 1 and 15\n",

" and l_shipmode in ('AIR', 'AIR REG')\n",

" and l_shipinstruct = 'DELIVER IN PERSON'\n",

" )\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "aeaaa90e-000e-4a12-91e9-4100d308d312",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = lines.WHERE(\n",

" (ISIN(ship_mode, (\"AIR\", \"AIR REG\")))\n",

" & (ship_instruct == \"DELIVER IN PERSON\")\n",

" & (part.size >= 1)\n",

" & (\n",

" (\n",

" (part.size <= 5)\n",

" & (quantity >= 1)\n",

" & (quantity <= 11)\n",

" & ISIN(\n",

" part.container,\n",

" (\"SM CASE\", \"SM BOX\", \"SM PACK\", \"SM PKG\"),\n",

" )\n",

" & (part.brand == \"Brand#12\")\n",

" )\n",

" | (\n",

" (part.size <= 10)\n",

" & (quantity >= 10)\n",

" & (quantity <= 20)\n",

" & ISIN(\n",

" part.container,\n",

" (\"MED BAG\", \"MED BOX\", \"MED PACK\", \"MED PKG\"),\n",

" )\n",

" & (part.brand == \"Brand#23\")\n",

" )\n",

" | (\n",

" (part.size <= 15)\n",

" & (quantity >= 20)\n",

" & (quantity <= 30)\n",

" & ISIN(\n",

" part.container,\n",

" (\"LG CASE\", \"LG BOX\", \"LG PACK\", \"LG PKG\"),\n",

" )\n",

" & (part.brand == \"Brand#34\")\n",

" )\n",

" )\n",

")\n",

"output = TPCH.CALCULATE(\n",

" REVENUE=SUM(selected_lines.extended_price * (1 - selected_lines.discount))\n",

")\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "860e2d30-5fb9-48ad-ba6d-b2cc7145f97f",

"metadata": {},), ChunkSearchResult(score=0.028, text=## File: tests/test_plan_refsols/tpch_q1.txt

````

ROOT(columns=[('L_RETURNFLAG', L_RETURNFLAG), ('L_LINESTATUS', L_LINESTATUS), ('SUM_QTY', SUM_QTY), ('SUM_BASE_PRICE', SUM_BASE_PRICE), ('SUM_DISC_PRICE', SUM_DISC_PRICE), ('SUM_CHARGE', SUM_CHARGE), ('AVG_QTY', AVG_QTY), ('AVG_PRICE', AVG_PRICE), ('AVG_DISC', AVG_DISC), ('COUNT_ORDER', COUNT_ORDER)], orderings=[(ordering_8):asc_first, (ordering_9):asc_first])

PROJECT(columns={'AVG_DISC': AVG_DISC, 'AVG_PRICE': AVG_PRICE, 'AVG_QTY': AVG_QTY, 'COUNT_ORDER': COUNT_ORDER, 'L_LINESTATUS': L_LINESTATUS, 'L_RETURNFLAG': L_RETURNFLAG, 'SUM_BASE_PRICE': SUM_BASE_PRICE, 'SUM_CHARGE': SUM_CHARGE, 'SUM_DISC_PRICE': SUM_DISC_PRICE, 'SUM_QTY': SUM_QTY, 'ordering_8': L_RETURNFLAG, 'ordering_9': L_LINESTATUS})

PROJECT(columns={'AVG_DISC': agg_0, 'AVG_PRICE': agg_1, 'AVG_QTY': agg_2, 'COUNT_ORDER': DEFAULT_TO(agg_3, 0:int64), 'L_LINESTATUS': status, 'L_RETURNFLAG': return_flag, 'SUM_BASE_PRICE': DEFAULT_TO(agg_4, 0:int64), 'SUM_CHARGE': DEFAULT_TO(agg_5, 0:int64), 'SUM_DISC_PRICE': DEFAULT_TO(agg_6, 0:int64), 'SUM_QTY': DEFAULT_TO(agg_7, 0:int64)})

AGGREGATE(keys={'return_flag': return_flag, 'status': status}, aggregations={'agg_0': AVG(discount), 'agg_1': AVG(extended_price), 'agg_2': AVG(quantity), 'agg_3': COUNT(), 'agg_4': SUM(extended_price), 'agg_5': SUM(expr_10), 'agg_6': SUM(expr_11), 'agg_7': SUM(quantity)})

PROJECT(columns={'discount': discount, 'expr_10': extended_price * 1:int64 - discount * 1:int64 + tax, 'expr_11': extended_price * 1:int64 - discount, 'extended_price': extended_price, 'quantity': quantity, 'return_flag': return_flag, 'status': status})

FILTER(condition=ship_date <= datetime.date(1998, 12, 1):date, columns={'discount': discount, 'extended_price': extended_price, 'quantity': quantity, 'return_flag': return_flag, 'status': status, 'tax': tax})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'quantity': l_quantity, 'return_flag': l_returnflag, 'ship_date': l_shipdate, 'status': l_linestatus, 'tax': l_tax})

````

## File: tests/test_plan_refsols/tpch_q10.txt

````

ROOT(columns=[('C_CUSTKEY', C_CUSTKEY), ('C_NAME', C_NAME), ('REVENUE', REVENUE), ('C_ACCTBAL', C_ACCTBAL), ('N_NAME', N_NAME), ('C_ADDRESS', C_ADDRESS), ('C_PHONE', C_PHONE), ('C_COMMENT', C_COMMENT)], orderings=[(ordering_1):desc_last, (ordering_2):asc_first])

LIMIT(limit=Literal(value=20, type=Int64Type()), columns={'C_ACCTBAL': C_ACCTBAL, 'C_ADDRESS': C_ADDRESS, 'C_COMMENT': C_COMMENT, 'C_CUSTKEY': C_CUSTKEY, 'C_NAME': C_NAME, 'C_PHONE': C_PHONE, 'N_NAME': N_NAME, 'REVENUE': REVENUE, 'ordering_1': ordering_1, 'ordering_2': ordering_2}, orderings=[(ordering_1):desc_last, (ordering_2):asc_first])

PROJECT(columns={'C_ACCTBAL': C_ACCTBAL, 'C_ADDRESS': C_ADDRESS, 'C_COMMENT': C_COMMENT, 'C_CUSTKEY': C_CUSTKEY, 'C_NAME': C_NAME, 'C_PHONE': C_PHONE, 'N_NAME': N_NAME, 'REVENUE': REVENUE, 'ordering_1': REVENUE, 'ordering_2': C_CUSTKEY})

PROJECT(columns={'C_ACCTBAL': acctbal, 'C_ADDRESS': address, 'C_COMMENT': comment, 'C_CUSTKEY': key, 'C_NAME': name, 'C_PHONE': phone, 'N_NAME': name_4, 'REVENUE': DEFAULT_TO(agg_0, 0:int64)})

JOIN(conditions=[t0.nation_key == t1.key], types=['left'], columns={'acctbal': t0.acctbal, 'address': t0.address, 'agg_0': t0.agg_0, 'comment': t0.comment, 'key': t0.key, 'name': t0.name, 'name_4': t1.name, 'phone': t0.phone})

JOIN(conditions=[t0.key == t1.customer_key], types=['left'], columns={'acctbal': t0.acctbal, 'address': t0.address, 'agg_0': t1.agg_0, 'comment': t0.comment, 'key': t0.key, 'name': t0.name, 'nation_key': t0.nation_key, 'phone': t0.phone})

SCAN(table=tpch.CUSTOMER, columns={'acctbal': c_acctbal, 'address': c_address, 'comment': c_comment, 'key': c_custkey, 'name': c_name, 'nation_key': c_nationkey, 'phone': c_phone})

AGGREGATE(keys={'customer_key': customer_key}, aggregations={'agg_0': SUM(amt)})

PROJECT(columns={'amt': extended_price * 1:int64 - discount, 'customer_key': customer_key})), ChunkSearchResult(score=0.028, text=(1, 1, 0, 1, 0, 99.99, 'success', 'debit', 'Online purchase', NULL, '2023-06-01 10:15:30', '2023-06-01 10:15:45', 'ad154bf7-8185-4230-a8d8-3ef59b4e0012', 'Stripe', 'tx_123abc456def', 'mobile_8fh2k1', '192.168.0.1', 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_3_1 like Mac OS X) ...'),

(2, 1, 0, 1, 1, 20.00, 'success', 'credit', 'Coupon discount', 1, '2023-06-01 10:15:30', '2023-06-01 10:15:45', 'ad154bf7-8185-4230-a8d8-3ef59b4e0012', 'Stripe', 'tx_123abc456def', 'mobile_8fh2k1', '192.168.0.1', 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_3_1 like Mac OS X) ...'),

(3, 2, 0, 1, 1, 16.00, 'success', 'credit', 'Coupon discount', 1, '2023-07-01 10:18:30', '2023-06-01 10:18:45', 'kd454bf7-428d-eig2-a8d8-3ef59b4e0012', 'Stripe', 'tx_123abc789gas', 'mobile_yjp08q', '198.51.100.233', 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_4 like Mac OS X) ...'),

(4, 3, 1, 9, 0, 125.50, 'success', 'debit', 'Product purchase', NULL, '2023-06-01 13:22:18', '2023-06-01 13:22:45', 'e6f510e9-ff7d-4914-81c2-f8e56bae4012', 'PayPal', 'ppx_192ks8hl', 'web_k29qjd', '216.58.195.68', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) ...'),

(5, 9, 0, 3, 1, 42.75, 'pending', 'debit', 'Order #438721', 3, '2023-06-01 18:45:02', '2023-06-01 18:45:13', 'b2ca190e-a42f-4f5e-8318-f82bcc6ae64e', 'Stripe', 'tx_987zyx654wvu', 'mobile_q3mz8n', '68.85.32.201', 'Mozilla/5.0 (Linux; Android 13) ...'),

(6, 9, 0, 3, 1, 10.00, 'success', 'credit', 'Coupon discount', 3, '2023-06-01 18:45:02', '2023-06-01 18:45:13', 'b2ca190e-a42f-4f5e-8318-f82bcc6ae64e', 'Stripe', 'tx_987zyx654wvu', 'mobile_q3mz8n', '68.85.32.201', 'Mozilla/5.0 (Linux; Android 13) ...'),

(7, 2, 0, 7, 1, 89.99, 'pending', 'debit', 'Home furnishings', NULL, '2023-06-02 09:30:25', '2023-06-02 09:30:40', 'c51e10d1-db34-4d9f-b55f-43a05a5481c8', 'Checkout.com', 'ord_kzhg123', 'mobile_yjp08q', '198.51.100.233', 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_4 like Mac OS X) ...'),

(8, 2, 0, 7, 1, 17.99, 'success', 'credit', 'Coupon discount', 7, '2023-06-02 09:30:25', '2023-06-02 09:30:40', 'c51e10d1-db34-4d9f-b55f-43a05a5481c8', 'Checkout.com', 'ord_kzhg123', 'mobile_yjp08q', '198.51.100.233', 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_4 like Mac OS X) ...'),), ChunkSearchResult(score=0.028, text=JOIN(conditions=[t0.order_key == t1.key], types=['left'], columns={'order_priority': t1.order_priority, 'ship_mode': t0.ship_mode})

FILTER(condition=commit_date < receipt_date & receipt_date < datetime.date(1995, 1, 1):date & ship_date < commit_date & receipt_date >= datetime.date(1994, 1, 1):date & ship_mode == 'MAIL':string | ship_mode == 'SHIP':string, columns={'order_key': order_key, 'ship_mode': ship_mode})

SCAN(table=tpch.LINEITEM, columns={'commit_date': l_commitdate, 'order_key': l_orderkey, 'receipt_date': l_receiptdate, 'ship_date': l_shipdate, 'ship_mode': l_shipmode})

SCAN(table=tpch.ORDERS, columns={'key': o_orderkey, 'order_priority': o_orderpriority})

````

## File: tests/test_plan_refsols/tpch_q13.txt

````

ROOT(columns=[('C_COUNT', C_COUNT), ('CUSTDIST', CUSTDIST)], orderings=[(ordering_1):desc_last, (ordering_2):desc_last])

LIMIT(limit=Literal(value=10, type=Int64Type()), columns={'CUSTDIST': CUSTDIST, 'C_COUNT': C_COUNT, 'ordering_1': ordering_1, 'ordering_2': ordering_2}, orderings=[(ordering_1):desc_last, (ordering_2):desc_last])

PROJECT(columns={'CUSTDIST': CUSTDIST, 'C_COUNT': C_COUNT, 'ordering_1': CUSTDIST, 'ordering_2': C_COUNT})

PROJECT(columns={'CUSTDIST': DEFAULT_TO(agg_0, 0:int64), 'C_COUNT': num_non_special_orders})

AGGREGATE(keys={'num_non_special_orders': num_non_special_orders}, aggregations={'agg_0': COUNT()})

PROJECT(columns={'num_non_special_orders': DEFAULT_TO(agg_0, 0:int64)})

JOIN(conditions=[t0.key == t1.customer_key], types=['left'], columns={'agg_0': t1.agg_0})

SCAN(table=tpch.CUSTOMER, columns={'key': c_custkey})

AGGREGATE(keys={'customer_key': customer_key}, aggregations={'agg_0': COUNT()})

FILTER(condition=NOT(LIKE(comment, '%special%requests%':string)), columns={'customer_key': customer_key})

SCAN(table=tpch.ORDERS, columns={'comment': o_comment, 'customer_key': o_custkey})

````

## File: tests/test_plan_refsols/tpch_q14.txt

````

ROOT(columns=[('PROMO_REVENUE', PROMO_REVENUE)], orderings=[])

PROJECT(columns={'PROMO_REVENUE': 100.0:float64 * DEFAULT_TO(agg_0, 0:int64) / DEFAULT_TO(agg_1, 0:int64)})

AGGREGATE(keys={}, aggregations={'agg_0': SUM(promo_value), 'agg_1': SUM(value)})

PROJECT(columns={'promo_value': IFF(STARTSWITH(part_type, 'PROMO':string), extended_price * 1:int64 - discount, 0:int64), 'value': extended_price * 1:int64 - discount})

JOIN(conditions=[t0.part_key == t1.key], types=['left'], columns={'discount': t0.discount, 'extended_price': t0.extended_price, 'part_type': t1.part_type})

FILTER(condition=ship_date < datetime.date(1995, 10, 1):date & ship_date >= datetime.date(1995, 9, 1):date, columns={'discount': discount, 'extended_price': extended_price, 'part_key': part_key})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'part_key': l_partkey, 'ship_date': l_shipdate})

SCAN(table=tpch.PART, columns={'key': p_partkey, 'part_type': p_type})

````

## File: tests/test_plan_refsols/tpch_q15.txt

````

ROOT(columns=[('S_SUPPKEY', S_SUPPKEY), ('S_NAME', S_NAME), ('S_ADDRESS', S_ADDRESS), ('S_PHONE', S_PHONE), ('TOTAL_REVENUE', TOTAL_REVENUE)], orderings=[(ordering_2):asc_first])

PROJECT(columns={'S_ADDRESS': S_ADDRESS, 'S_NAME': S_NAME, 'S_PHONE': S_PHONE, 'S_SUPPKEY': S_SUPPKEY, 'TOTAL_REVENUE': TOTAL_REVENUE, 'ordering_2': S_SUPPKEY})

FILTER(condition=TOTAL_REVENUE == max_revenue, columns={'S_ADDRESS': S_ADDRESS, 'S_NAME': S_NAME, 'S_PHONE': S_PHONE, 'S_SUPPKEY': S_SUPPKEY, 'TOTAL_REVENUE': TOTAL_REVENUE})

PROJECT(columns={'S_ADDRESS': address, 'S_NAME': name, 'S_PHONE': phone, 'S_SUPPKEY': key, 'TOTAL_REVENUE': DEFAULT_TO(agg_1, 0:int64), 'max_revenue': max_revenue})

JOIN(conditions=[t0.key == t1.supplier_key], types=['left'], columns={'address': t0.address, 'agg_1': t1.agg_1, 'key': t0.key, 'max_revenue': t0.max_revenue, 'name': t0.name, 'phone': t0.phone})

JOIN(conditions=[True:bool], types=['inner'], columns={'address': t1.address, 'key': t1.key, 'max_revenue': t0.max_revenue, 'name': t1.name, 'phone': t1.phone})

PROJECT(columns={'max_revenue': agg_0})), ChunkSearchResult(score=0.027, text=ROOT(columns=[('order_priority', order_priority), ('order_key', order_key), ('order_total_price', order_total_price)], orderings=[(ordering_0):asc_first])

PROJECT(columns={'order_key': order_key, 'order_priority': order_priority, 'order_total_price': order_total_price, 'ordering_0': order_priority})

PROJECT(columns={'order_key': key, 'order_priority': order_priority, 'order_total_price': total_price})

FILTER(condition=RANKING(args=[], partition=[order_priority], order=[(total_price):desc_first]) == 1:int64, columns={'key': key, 'order_priority': order_priority, 'total_price': total_price})

FILTER(condition=YEAR(order_date) == 1992:int64, columns={'key': key, 'order_priority': order_priority, 'total_price': total_price})

SCAN(table=tpch.ORDERS, columns={'key': o_orderkey, 'order_date': o_orderdate, 'order_priority': o_orderpriority, 'total_price': o_totalprice})

````

## File: tests/test_plan_refsols/ordered_asian_nations.txt

````

ROOT(columns=[('key', key), ('name', name), ('region_key', region_key), ('comment', comment)], orderings=[(ordering_0):asc_last])

JOIN(conditions=[t0.region_key == t1.key], types=['inner'], columns={'comment': t0.comment, 'key': t0.key, 'name': t0.name, 'ordering_0': t0.ordering_0, 'region_key': t0.region_key})

PROJECT(columns={'comment': comment, 'key': key, 'name': name, 'ordering_0': name, 'region_key': region_key})

SCAN(table=tpch.NATION, columns={'comment': n_comment, 'key': n_nationkey, 'name': n_name, 'region_key': n_regionkey})

FILTER(condition=name == 'ASIA':string, columns={'key': key})

SCAN(table=tpch.REGION, columns={'key': r_regionkey, 'name': r_name})

````

## File: tests/test_plan_refsols/ordering_name_overload.txt

````

ROOT(columns=[('ordering_0', ordering_0_0), ('ordering_1', ordering_1_0), ('ordering_2', ordering_2_0), ('ordering_3', ordering_3_0), ('ordering_4', ordering_4_0), ('ordering_5', ordering_5_0), ('ordering_6', ordering_6), ('ordering_7', ordering_7), ('ordering_8', ordering_8)], orderings=[(ordering_3):asc_last, (ordering_4):desc_last, (ordering_5):asc_first])

PROJECT(columns={'ordering_0_0': ordering_2, 'ordering_1_0': ordering_0, 'ordering_2_0': ordering_1, 'ordering_3': ordering_3, 'ordering_3_0': ordering_2, 'ordering_4': ordering_4, 'ordering_4_0': ordering_1, 'ordering_5': ordering_5, 'ordering_5_0': ordering_0, 'ordering_6': LOWER(name), 'ordering_7': ABS(key), 'ordering_8': LENGTH(comment)})

PROJECT(columns={'comment': comment, 'key': key, 'name': name, 'ordering_0': ordering_0, 'ordering_1': ordering_1, 'ordering_2': ordering_2, 'ordering_3': LOWER(name), 'ordering_4': ABS(key), 'ordering_5': LENGTH(comment)})

PROJECT(columns={'comment': comment, 'key': key, 'name': name, 'ordering_0': name, 'ordering_1': key, 'ordering_2': comment})

SCAN(table=tpch.NATION, columns={'comment': n_comment, 'key': n_nationkey, 'name': n_name})

````

## File: tests/test_plan_refsols/orders_sum_line_price.txt

````

ROOT(columns=[('okey', okey), ('lsum', lsum)], orderings=[])

PROJECT(columns={'lsum': DEFAULT_TO(agg_0, 0:int64), 'okey': key})

JOIN(conditions=[t0.key == t1.order_key], types=['left'], columns={'agg_0': t1.agg_0, 'key': t0.key})

SCAN(table=tpch.ORDERS, columns={'key': o_orderkey})

AGGREGATE(keys={'order_key': order_key}, aggregations={'agg_0': SUM(extended_price)})

SCAN(table=tpch.LINEITEM, columns={'extended_price': l_extendedprice, 'order_key': l_orderkey})

````

## File: tests/test_plan_refsols/orders_sum_vs_count_line_price.txt

````

ROOT(columns=[('okey', okey), ('lavg', lavg)], orderings=[])

PROJECT(columns={'lavg': DEFAULT_TO(agg_0, 0:int64) / DEFAULT_TO(agg_1, 0:int64), 'okey': key})

JOIN(conditions=[t0.key == t1.order_key], types=['left'], columns={'agg_0': t1.agg_0, 'agg_1': t1.agg_1, 'key': t0.key})

SCAN(table=tpch.ORDERS, columns={'key': o_orderkey})

AGGREGATE(keys={'order_key': order_key}, aggregations={'agg_0': SUM(extended_price), 'agg_1': COUNT(extended_price)})

SCAN(table=tpch.LINEITEM, columns={'extended_price': l_extendedprice, 'order_key': l_orderkey})

````), ChunkSearchResult(score=0.027, text=JOIN(conditions=[t0.key == t1.customer_key], types=['left'], columns={'acctbal': t0.acctbal, 'agg_0': t1.agg_0, 'cntry_code': t0.cntry_code})

FILTER(condition=ISIN(cntry_code, ['13', '31', '23', '29', '30', '18', '17']:array[unknown]), columns={'acctbal': acctbal, 'cntry_code': cntry_code, 'key': key})

PROJECT(columns={'acctbal': acctbal, 'cntry_code': SLICE(phone, None:unknown, 2:int64, None:unknown), 'key': key})

FILTER(condition=acctbal > global_avg_balance, columns={'acctbal': acctbal, 'key': key, 'phone': phone})

JOIN(conditions=[True:bool], types=['inner'], columns={'acctbal': t1.acctbal, 'global_avg_balance': t0.global_avg_balance, 'key': t1.key, 'phone': t1.phone})

PROJECT(columns={'global_avg_balance': agg_0})

AGGREGATE(keys={}, aggregations={'agg_0': AVG(acctbal)})

FILTER(condition=ISIN(cntry_code, ['13', '31', '23', '29', '30', '18', '17']:array[unknown]), columns={'acctbal': acctbal})

PROJECT(columns={'acctbal': acctbal, 'cntry_code': SLICE(phone, None:unknown, 2:int64, None:unknown)})

FILTER(condition=acctbal > 0.0:float64, columns={'acctbal': acctbal, 'phone': phone})

SCAN(table=tpch.CUSTOMER, columns={'acctbal': c_acctbal, 'phone': c_phone})

SCAN(table=tpch.CUSTOMER, columns={'acctbal': c_acctbal, 'key': c_custkey, 'phone': c_phone})

AGGREGATE(keys={'customer_key': customer_key}, aggregations={'agg_0': COUNT()})

SCAN(table=tpch.ORDERS, columns={'customer_key': o_custkey})

````

## File: tests/test_plan_refsols/tpch_q3.txt

````

ROOT(columns=[('L_ORDERKEY', L_ORDERKEY), ('REVENUE', REVENUE), ('O_ORDERDATE', O_ORDERDATE), ('O_SHIPPRIORITY', O_SHIPPRIORITY)], orderings=[(ordering_1):desc_last, (ordering_2):asc_first, (ordering_3):asc_first])

LIMIT(limit=Literal(value=10, type=Int64Type()), columns={'L_ORDERKEY': L_ORDERKEY, 'O_ORDERDATE': O_ORDERDATE, 'O_SHIPPRIORITY': O_SHIPPRIORITY, 'REVENUE': REVENUE, 'ordering_1': ordering_1, 'ordering_2': ordering_2, 'ordering_3': ordering_3}, orderings=[(ordering_1):desc_last, (ordering_2):asc_first, (ordering_3):asc_first])

PROJECT(columns={'L_ORDERKEY': L_ORDERKEY, 'O_ORDERDATE': O_ORDERDATE, 'O_SHIPPRIORITY': O_SHIPPRIORITY, 'REVENUE': REVENUE, 'ordering_1': REVENUE, 'ordering_2': O_ORDERDATE, 'ordering_3': L_ORDERKEY})

PROJECT(columns={'L_ORDERKEY': order_key, 'O_ORDERDATE': order_date, 'O_SHIPPRIORITY': ship_priority, 'REVENUE': DEFAULT_TO(agg_0, 0:int64)})

AGGREGATE(keys={'order_date': order_date, 'order_key': order_key, 'ship_priority': ship_priority}, aggregations={'agg_0': SUM(expr_4)})

PROJECT(columns={'expr_4': extended_price * 1:int64 - discount, 'order_date': order_date, 'order_key': order_key, 'ship_priority': ship_priority})

JOIN(conditions=[t0.key == t1.order_key], types=['inner'], columns={'discount': t1.discount, 'extended_price': t1.extended_price, 'order_date': t0.order_date, 'order_key': t1.order_key, 'ship_priority': t0.ship_priority})

JOIN(conditions=[t0.customer_key == t1.key], types=['inner'], columns={'key': t0.key, 'order_date': t0.order_date, 'ship_priority': t0.ship_priority})

FILTER(condition=order_date < datetime.date(1995, 3, 15):date, columns={'customer_key': customer_key, 'key': key, 'order_date': order_date, 'ship_priority': ship_priority})

SCAN(table=tpch.ORDERS, columns={'customer_key': o_custkey, 'key': o_orderkey, 'order_date': o_orderdate, 'ship_priority': o_shippriority})

FILTER(condition=mktsegment == 'BUILDING':string, columns={'key': key})

SCAN(table=tpch.CUSTOMER, columns={'key': c_custkey, 'mktsegment': c_mktsegment})

FILTER(condition=ship_date > datetime.date(1995, 3, 15):date, columns={'discount': discount, 'extended_price': extended_price, 'order_key': order_key})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'order_key': l_orderkey, 'ship_date': l_shipdate})

````

## File: tests/test_plan_refsols/tpch_q4.txt

````

ROOT(columns=[('O_ORDERPRIORITY', O_ORDERPRIORITY), ('ORDER_COUNT', ORDER_COUNT)], orderings=[(ordering_1):asc_first])

PROJECT(columns={'ORDER_COUNT': ORDER_COUNT, 'O_ORDERPRIORITY': O_ORDERPRIORITY, 'ordering_1': O_ORDERPRIORITY})), ChunkSearchResult(score=0.027, text=PROJECT(columns={'ORDER_COUNT': DEFAULT_TO(agg_0, 0:int64), 'O_ORDERPRIORITY': order_priority})

AGGREGATE(keys={'order_priority': order_priority}, aggregations={'agg_0': COUNT()})

JOIN(conditions=[t0.key == t1.order_key], types=['semi'], columns={'order_priority': t0.order_priority})

FILTER(condition=order_date < datetime.date(1993, 10, 1):date & order_date >= datetime.date(1993, 7, 1):date, columns={'key': key, 'order_priority': order_priority})

SCAN(table=tpch.ORDERS, columns={'key': o_orderkey, 'order_date': o_orderdate, 'order_priority': o_orderpriority})

FILTER(condition=commit_date < receipt_date, columns={'order_key': order_key})

SCAN(table=tpch.LINEITEM, columns={'commit_date': l_commitdate, 'order_key': l_orderkey, 'receipt_date': l_receiptdate})

````

## File: tests/test_plan_refsols/tpch_q5.txt

````

ROOT(columns=[('N_NAME', N_NAME), ('REVENUE', REVENUE)], orderings=[(ordering_1):desc_last])

PROJECT(columns={'N_NAME': N_NAME, 'REVENUE': REVENUE, 'ordering_1': REVENUE})

PROJECT(columns={'N_NAME': agg_3, 'REVENUE': DEFAULT_TO(agg_0, 0:int64)})

AGGREGATE(keys={'key': key}, aggregations={'agg_0': SUM(value), 'agg_3': ANYTHING(name)})

PROJECT(columns={'key': key, 'name': name, 'value': extended_price * 1:int64 - discount})

FILTER(condition=name_12 == nation_name, columns={'discount': discount, 'extended_price': extended_price, 'key': key, 'name': name})

JOIN(conditions=[t0.supplier_key == t1.key], types=['left'], columns={'discount': t0.discount, 'extended_price': t0.extended_price, 'key': t0.key, 'name': t0.name, 'name_12': t1.name_12, 'nation_name': t0.nation_name})

JOIN(conditions=[t0.key_8 == t1.order_key], types=['inner'], columns={'discount': t1.discount, 'extended_price': t1.extended_price, 'key': t0.key, 'name': t0.name, 'nation_name': t0.nation_name, 'supplier_key': t1.supplier_key})

JOIN(conditions=[t0.key_5 == t1.customer_key], types=['inner'], columns={'key': t0.key, 'key_8': t1.key, 'name': t0.name, 'nation_name': t0.nation_name})

JOIN(conditions=[t0.key == t1.nation_key], types=['inner'], columns={'key': t0.key, 'key_5': t1.key, 'name': t0.name, 'nation_name': t0.nation_name})

JOIN(conditions=[t0.region_key == t1.key], types=['inner'], columns={'key': t0.key, 'name': t0.name, 'nation_name': t0.nation_name})

PROJECT(columns={'key': key, 'name': name, 'nation_name': name, 'region_key': region_key})

SCAN(table=tpch.NATION, columns={'key': n_nationkey, 'name': n_name, 'region_key': n_regionkey})

FILTER(condition=name == 'ASIA':string, columns={'key': key})

SCAN(table=tpch.REGION, columns={'key': r_regionkey, 'name': r_name})

SCAN(table=tpch.CUSTOMER, columns={'key': c_custkey, 'nation_key': c_nationkey})

FILTER(condition=order_date < datetime.date(1995, 1, 1):date & order_date >= datetime.date(1994, 1, 1):date, columns={'customer_key': customer_key, 'key': key})

SCAN(table=tpch.ORDERS, columns={'customer_key': o_custkey, 'key': o_orderkey, 'order_date': o_orderdate})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'order_key': l_orderkey, 'supplier_key': l_suppkey})

JOIN(conditions=[t0.nation_key == t1.key], types=['inner'], columns={'key': t0.key, 'name_12': t1.name})

SCAN(table=tpch.SUPPLIER, columns={'key': s_suppkey, 'nation_key': s_nationkey})

SCAN(table=tpch.NATION, columns={'key': n_nationkey, 'name': n_name})

````

## File: tests/test_plan_refsols/tpch_q6.txt

````

ROOT(columns=[('REVENUE', REVENUE)], orderings=[])

PROJECT(columns={'REVENUE': DEFAULT_TO(agg_0, 0:int64)})

AGGREGATE(keys={}, aggregations={'agg_0': SUM(amt)})

PROJECT(columns={'amt': extended_price * discount})

FILTER(condition=discount <= 0.07:float64 & quantity < 24:int64 & ship_date < datetime.date(1995, 1, 1):date & discount >= 0.05:float64 & ship_date >= datetime.date(1994, 1, 1):date, columns={'discount': discount, 'extended_price': extended_price})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'quantity': l_quantity, 'ship_date': l_shipdate})

````

## File: tests/test_plan_refsols/tpch_q7.txt

````), ChunkSearchResult(score=0.026, text=ROOT(columns=[('SUPP_NATION', SUPP_NATION), ('CUST_NATION', CUST_NATION), ('L_YEAR', L_YEAR), ('REVENUE', REVENUE)], orderings=[(ordering_1):asc_first, (ordering_2):asc_first, (ordering_3):asc_first])

PROJECT(columns={'CUST_NATION': CUST_NATION, 'L_YEAR': L_YEAR, 'REVENUE': REVENUE, 'SUPP_NATION': SUPP_NATION, 'ordering_1': SUPP_NATION, 'ordering_2': CUST_NATION, 'ordering_3': L_YEAR})

PROJECT(columns={'CUST_NATION': cust_nation, 'L_YEAR': l_year, 'REVENUE': DEFAULT_TO(agg_0, 0:int64), 'SUPP_NATION': supp_nation})

AGGREGATE(keys={'cust_nation': cust_nation, 'l_year': l_year, 'supp_nation': supp_nation}, aggregations={'agg_0': SUM(volume)})

PROJECT(columns={'cust_nation': name_8, 'l_year': YEAR(ship_date), 'supp_nation': name_3, 'volume': extended_price * 1:int64 - discount})

FILTER(condition=name_3 == 'FRANCE':string & name_8 == 'GERMANY':string | name_3 == 'GERMANY':string & name_8 == 'FRANCE':string, columns={'discount': discount, 'extended_price': extended_price, 'name_3': name_3, 'name_8': name_8, 'ship_date': ship_date})

JOIN(conditions=[t0.order_key == t1.key], types=['left'], columns={'discount': t0.discount, 'extended_price': t0.extended_price, 'name_3': t0.name_3, 'name_8': t1.name_8, 'ship_date': t0.ship_date})

JOIN(conditions=[t0.supplier_key == t1.key], types=['left'], columns={'discount': t0.discount, 'extended_price': t0.extended_price, 'name_3': t1.name_3, 'order_key': t0.order_key, 'ship_date': t0.ship_date})

FILTER(condition=ship_date <= datetime.date(1996, 12, 31):date & ship_date >= datetime.date(1995, 1, 1):date, columns={'discount': discount, 'extended_price': extended_price, 'order_key': order_key, 'ship_date': ship_date, 'supplier_key': supplier_key})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'order_key': l_orderkey, 'ship_date': l_shipdate, 'supplier_key': l_suppkey})

JOIN(conditions=[t0.nation_key == t1.key], types=['inner'], columns={'key': t0.key, 'name_3': t1.name})

SCAN(table=tpch.SUPPLIER, columns={'key': s_suppkey, 'nation_key': s_nationkey})

SCAN(table=tpch.NATION, columns={'key': n_nationkey, 'name': n_name})

JOIN(conditions=[t0.nation_key == t1.key], types=['inner'], columns={'key': t0.key, 'name_8': t1.name})

JOIN(conditions=[t0.customer_key == t1.key], types=['inner'], columns={'key': t0.key, 'nation_key': t1.nation_key})

SCAN(table=tpch.ORDERS, columns={'customer_key': o_custkey, 'key': o_orderkey})

SCAN(table=tpch.CUSTOMER, columns={'key': c_custkey, 'nation_key': c_nationkey})

SCAN(table=tpch.NATION, columns={'key': n_nationkey, 'name': n_name})

````

## File: tests/test_plan_refsols/tpch_q8.txt

````

ROOT(columns=[('O_YEAR', O_YEAR), ('MKT_SHARE', MKT_SHARE)], orderings=[])

PROJECT(columns={'MKT_SHARE': DEFAULT_TO(agg_0, 0:int64) / DEFAULT_TO(agg_1, 0:int64), 'O_YEAR': o_year})

AGGREGATE(keys={'o_year': o_year}, aggregations={'agg_0': SUM(brazil_volume), 'agg_1': SUM(volume)})

JOIN(conditions=[t0.customer_key == t1.key], types=['inner'], columns={'brazil_volume': t0.brazil_volume, 'o_year': t0.o_year, 'volume': t0.volume})

PROJECT(columns={'brazil_volume': IFF(nation_name == 'BRAZIL':string, volume, 0:int64), 'customer_key': customer_key, 'o_year': YEAR(order_date), 'volume': volume})

JOIN(conditions=[t0.order_key == t1.key], types=['inner'], columns={'customer_key': t1.customer_key, 'nation_name': t0.nation_name, 'order_date': t1.order_date, 'volume': t0.volume})

PROJECT(columns={'nation_name': nation_name, 'order_key': order_key, 'volume': extended_price * 1:int64 - discount})

JOIN(conditions=[t0.part_key == t1.part_key & t0.supplier_key == t1.supplier_key], types=['inner'], columns={'discount': t1.discount, 'extended_price': t1.extended_price, 'nation_name': t0.nation_name, 'order_key': t1.order_key})

JOIN(conditions=[t0.part_key == t1.key], types=['inner'], columns={'nation_name': t0.nation_name, 'part_key': t0.part_key, 'supplier_key': t0.supplier_key})), ChunkSearchResult(score=0.025, text=AGGREGATE(keys={}, aggregations={'agg_0': MAX(total_revenue)})

PROJECT(columns={'total_revenue': DEFAULT_TO(agg_0, 0:int64)})

JOIN(conditions=[t0.key == t1.supplier_key], types=['left'], columns={'agg_0': t1.agg_0})

SCAN(table=tpch.SUPPLIER, columns={'key': s_suppkey})

AGGREGATE(keys={'supplier_key': supplier_key}, aggregations={'agg_0': SUM(expr_3)})

PROJECT(columns={'expr_3': extended_price * 1:int64 - discount, 'supplier_key': supplier_key})

FILTER(condition=ship_date < datetime.date(1996, 4, 1):date & ship_date >= datetime.date(1996, 1, 1):date, columns={'discount': discount, 'extended_price': extended_price, 'supplier_key': supplier_key})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'ship_date': l_shipdate, 'supplier_key': l_suppkey})

SCAN(table=tpch.SUPPLIER, columns={'address': s_address, 'key': s_suppkey, 'name': s_name, 'phone': s_phone})

AGGREGATE(keys={'supplier_key': supplier_key}, aggregations={'agg_1': SUM(expr_4)})

PROJECT(columns={'expr_4': extended_price * 1:int64 - discount, 'supplier_key': supplier_key})

FILTER(condition=ship_date < datetime.date(1996, 4, 1):date & ship_date >= datetime.date(1996, 1, 1):date, columns={'discount': discount, 'extended_price': extended_price, 'supplier_key': supplier_key})

SCAN(table=tpch.LINEITEM, columns={'discount': l_discount, 'extended_price': l_extendedprice, 'ship_date': l_shipdate, 'supplier_key': l_suppkey})

````

## File: tests/test_plan_refsols/tpch_q16.txt

````

ROOT(columns=[('P_BRAND', P_BRAND), ('P_TYPE', P_TYPE), ('P_SIZE', P_SIZE), ('SUPPLIER_COUNT', SUPPLIER_COUNT)], orderings=[(ordering_1):desc_last, (ordering_2):asc_first, (ordering_3):asc_first, (ordering_4):asc_first])

LIMIT(limit=Literal(value=10, type=Int64Type()), columns={'P_BRAND': P_BRAND, 'P_SIZE': P_SIZE, 'P_TYPE': P_TYPE, 'SUPPLIER_COUNT': SUPPLIER_COUNT, 'ordering_1': ordering_1, 'ordering_2': ordering_2, 'ordering_3': ordering_3, 'ordering_4': ordering_4}, orderings=[(ordering_1):desc_last, (ordering_2):asc_first, (ordering_3):asc_first, (ordering_4):asc_first])

PROJECT(columns={'P_BRAND': P_BRAND, 'P_SIZE': P_SIZE, 'P_TYPE': P_TYPE, 'SUPPLIER_COUNT': SUPPLIER_COUNT, 'ordering_1': SUPPLIER_COUNT, 'ordering_2': P_BRAND, 'ordering_3': P_TYPE, 'ordering_4': P_SIZE})

PROJECT(columns={'P_BRAND': p_brand, 'P_SIZE': p_size, 'P_TYPE': p_type, 'SUPPLIER_COUNT': agg_0})

AGGREGATE(keys={'p_brand': p_brand, 'p_size': p_size, 'p_type': p_type}, aggregations={'agg_0': NDISTINCT(supplier_key)})

FILTER(condition=NOT(LIKE(comment_2, '%Customer%Complaints%':string)), columns={'p_brand': p_brand, 'p_size': p_size, 'p_type': p_type, 'supplier_key': supplier_key})

JOIN(conditions=[t0.supplier_key == t1.key], types=['left'], columns={'comment_2': t1.comment, 'p_brand': t0.p_brand, 'p_size': t0.p_size, 'p_type': t0.p_type, 'supplier_key': t0.supplier_key})

JOIN(conditions=[t0.key == t1.part_key], types=['inner'], columns={'p_brand': t0.p_brand, 'p_size': t0.p_size, 'p_type': t0.p_type, 'supplier_key': t1.supplier_key})

PROJECT(columns={'key': key, 'p_brand': brand, 'p_size': size, 'p_type': part_type})

FILTER(condition=brand != 'BRAND#45':string & ISIN(size, [49, 14, 23, 45, 19, 3, 36, 9]:array[unknown]) & NOT(STARTSWITH(part_type, 'MEDIUM POLISHED%':string)), columns={'brand': brand, 'key': key, 'part_type': part_type, 'size': size})

SCAN(table=tpch.PART, columns={'brand': p_brand, 'key': p_partkey, 'part_type': p_type, 'size': p_size})

SCAN(table=tpch.PARTSUPP, columns={'part_key': ps_partkey, 'supplier_key': ps_suppkey})

SCAN(table=tpch.SUPPLIER, columns={'comment': s_comment, 'key': s_suppkey})

````

## File: tests/test_plan_refsols/tpch_q17.txt

````

ROOT(columns=[('AVG_YEARLY', AVG_YEARLY)], orderings=[])

PROJECT(columns={'AVG_YEARLY': DEFAULT_TO(agg_0, 0:int64) / 7.0:float64})

AGGREGATE(keys={}, aggregations={'agg_0': SUM(extended_price)})

FILTER(condition=quantity < 0.2:float64 * part_avg_quantity, columns={'extended_price': extended_price})), ChunkSearchResult(score=0.015, text=## Larger Examples

The rest of the document are examples of questions asked about the data in the people/addresses/packages graph and the corresponding PyDough code, which uses several of the features described in this document.

<!-- TOC --><a name="example-1-highest-residency-density-states"></a>

### Example 1: Highest Residency Density States

**Question**: Find the 5 states with the highest average number of occupants per address.

**Answer**:

```py

%%pydough

# For each address, identify how many current occupants it has

addr_info = Addresses.CALCULATE(n_occupants=COUNT(current_occupants))

# Partition the addresses by the state, and for each state calculate the

# average value of `n_occupants` for all addresses in that state

states = PARTITION(

addr_info,

name="addrs",

by=state

).CALCULATE(

state,

average_occupants=AVG(addrs.n_occupants)

)

# Obtain the top-5 states with the highest average

result = states.TOP_K(5, by=average_occupants.DESC())

```

<!-- TOC --><a name="example-2-yearly-trans-coastal-shipments"></a>

### Example 2: Yearly Trans-Coastal Shipments

**Question**: For every calendar year, what percentage of all packages are from a customer living in the west coast to an address on the east coast? Only include packages that have already arrived, and order by the year.

**Answer**:

```py

%%pydough

# Contextless expression: identifies if a package comes from the west coast

west_coast_states = ("CA", "OR", "WA", "AK")

from_west_coast = ISIN(customer.current_address.state, west_coast_states)

# Contextless expression: identifies if a pcakge is shipped to the east coast

east_coast_states = ("FL", "GA", "SC", "NC", "VA", "MD", "DE", "NJ", "NY", "CT", "RI", "MA", "NH", "MA")

to_east_coast = ISIN(shipping_address.state, east_coast_states)

# Filter packages to only include ones that have arrived, and derive additional

# terms for if they are trans-coastal + the year they were ordered

package_info = Packages.WHERE(

PRESENT(arrival_date)

).CALCULATE(

is_trans_coastal=from_west_coast & to_east_coast,

year=YEAR(order_date),

)

# Partition the packages by the order year & count how many have a True value

# for is_trans_coastal, vs the total number in that year

year_info = PARTITION(

package_info,

name="packs",

by=year,

).CALCULATE(

year,

pct_trans_coastal=100.0 * SUM(packs.is_trans_coastal) / COUNT(packs),

)

# Output the results ordered by year

result = year_info.ORDER_BY(year.ASC())

```

<!-- TOC --><a name="example-3-email-of-oldest-non-customer-resident"></a>

### Example 3: Email of Oldest Non-Customer Resident

**Question**: For every city/state, find the email of the oldest resident of that city/state who has never ordered a package (break ties in favor of the lower social security number). Also include the zip code of that occupant. Order alphabetically by state, followed by city.

**Answer**:

```py

%%pydough

# Partition every address by the city/state

cities = PARTITION(

Addresses.CALCULATE(city, state, zip_code),

name="addrs",

by=(city, state)

)

# For each city, find the oldest occupant out of any address in that city

# and include the desired information about that occupant.

oldest_occupants = cities.BEST(

addrs.current_occupants.WHERE(HASNOT(packages)),

by=(birth_date.ASC(), ssn.ASC()),

).CALCULATE(

state,

city,

email,

zip_code

)

# Sort the output by state, followed by city

result = oldest_occupants.ORDER_BY(

state.ASC(),

city.ASC(),

)

```

<!-- TOC --><a name="example-4-outlier-packages-per-month-of-2017"></a>

### Example 4: Outlier Packages Per Month Of 2017

**Question**: For every month of the year 2017, identify the percentage of packages ordered in that month that are at least 10x the average value of all packages ordered in 2017. Order the results by month.

**Answer**:

```py

%%pydough

# Contextless expression: identifies is a package was ordered in 2017

is_2017 = YEAR(order_date) == 2017

# Identify the average package cost of all packages ordered in 2017

global_info = GRAPH.CALCULATE(), ChunkSearchResult(score=0.015, text="source": [

"## Query 9\n",

"\n",

"This question asks about **the profit made for a particular line of parts looking at the supplying nation and particular year in question**. More specifically, it finds, for each nation and each year, the profit for all parts ordered in that year that contain a specified substring in their names and that were filled by a supplier in that nation. The profit is defined as the sum of the extended price times one minus the discount, minus the product of the supply cost and quantity, for all lineitems describing parts in the specified line. The query lists the nations in ascending alphabetical order and, for each nation, the year and profit in descending order by year (most recent first). The substring in question is `'green'`.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" NATION,\n",

" O_YEAR,\n",

" SUM(AMOUNT) AS SUM_PROFIT\n",

"FROM (\n",

" SELECT\n",

" N_NAME AS NATION,\n",

" EXTRACT(YEAR FROM O_ORDERDATE) AS O_YEAR,\n",

" L_EXTENDEDPRICE * (1 - L_DISCOUNT) - PS_SUPPLYCOST * L_QUANTITY AS AMOUNT\n",

" FROM\n",

" PART,\n",

" SUPPLIER,\n",

" LINEITEM,\n",

" PARTSUPP,\n",

" ORDERS,\n",

" NATION\n",

" WHERE\n",

" S_SUPPKEY = L_SUPPKEY\n",

" AND PS_SUPPKEY = L_SUPPKEY\n",

" AND PS_PARTKEY = L_PARTKEY\n",

" AND P_PARTKEY = L_PARTKEY\n",

" AND O_ORDERKEY = L_ORDERKEY\n",

" AND S_NATIONKEY = N_NATIONKEY\n",

" AND P_NAME LIKE '%green%'\n",

") PROFIT\n",

"GROUP BY\n",

" NATION,\n",

" O_YEAR\n",

"ORDER BY\n",

" NATION,\n",

" O_YEAR;\n",

"```"

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "3f2d470d-7bf4-4000-b049-9cac0c635ae2",

"metadata": {},

"outputs": [],

"source": [

"%%pydough\n",

"\n",

"selected_lines = (\n",

" nations.CALCULATE(nation_name=name)\n",

" .suppliers.supply_records.CALCULATE(supplycost)\n",

" .WHERE(CONTAINS(part.name, \"green\"))\n",

" .lines.CALCULATE(\n",

" o_year=YEAR(order.order_date),\n",

" value=extended_price * (1 - discount) - supplycost * quantity,\n",

" )\n",

")\n",

"output = (\n",

" PARTITION(selected_lines, name=\"l\", by=(nation_name, o_year))\n",

" .CALCULATE(NATION=nation_name, O_YEAR=o_year, AMOUNT=SUM(l.value))\n",

" .TOP_K(10, by=(NATION.ASC(), O_YEAR.DESC()))\n",

")\n",

"pydough.to_df(output)"

]

},

{

"cell_type": "markdown",

"id": "efe1a2f4-3198-4cd5-9807-3f054d0901e8",

"metadata": {},

"source": [

"## Query 10\n",

"\n",

"This question **determines the top 20 customers based on impact in revenue due to having returned parts within a particular quarter**. Revenue lost is defined as the sum of the extended price times one minus the discount for all qualifying lineitems. The chosen quarter is the last 3 months of 1993. The query lists the customer's name, address, nation, phone number, account balance, comment information and revenue lost.\n",

"\n",

"\n",

"\n",

"Here is the corresponding SQL:\n",

"\n",

"```SQL\n",

"SELECT\n",

" C_CUSTKEY,\n",

" C_NAME,\n",

" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\n",

" C_ACCTBAL,\n",

" N_NAME,\n",

" C_ADDRESS,\n",

" C_PHONE,\n",

" C_COMMENT\n",

"FROM\n",

" CUSTOMER,\n",

" ORDERS,\n",

" LINEITEM,\n",

" NATION\n",

"WHERE\n",

" C_CUSTKEY = O_CUSTKEY\n",

" AND L_ORDERKEY = O_ORDERKEY\n",

" AND O_ORDERDATE >= DATE '1993-10-01'\n",

" AND O_ORDERDATE < DATE '1994-01-01'\n",

" AND L_RETURNFLAG = 'R'\n",

" AND C_NATIONKEY = N_NATIONKEY\n",

"GROUP BY\n",

" C_CUSTKEY,\n",

" C_NAME,\n",

" C_ACCTBAL,\n",

" C_PHONE,\n",

" N_NAME,\n",

" C_ADDRESS,\n",

" C_COMMENT\n",

"ORDER BY\n",

" REVENUE DESC\n",

"LIMIT 20;\n",

"```\n",

"\n",

"In the original query, a wide variety of columns need to be aggregated in the `GROUP BY` clause. PyDough greatly simplifies this if we phrase this question in the form of \"for each customer...\" since aggregating per-customer can be done implicitly without any manual partitioning."

]

},

{

"cell_type": "code",

"execution_count": null,

"id": "7d65be30-98fb-42af-aaff-8db79d8c981b",

"metadata": {},

"outputs": [],), ChunkSearchResult(score=0.015, text=INSERT INTO wallet_merchant_balance_daily (merchant_id, balance, updated_at) VALUES

(1, 3897.99, '2023-06-07 23:59:59'),

(2, 155.24, '2023-06-07 23:59:59'),

(3, 2775.25, '2023-06-07 23:59:59'),

(4, 2500.00, '2023-06-07 23:59:59'),

(5, 155.99, '2023-06-07 23:59:59'),

(6, 29.95, '2023-06-07 23:59:59'),

(7, 172.98, '2023-06-07 23:59:59'),

(8, 0.00, '2023-06-07 23:59:59'),

(9, 125.00, '2023-06-07 23:59:59'),

(10, 219.98, '2023-06-07 23:59:59'),

(1, 82.10, DATE('now', '-8 days')),

(2, 82.12, DATE('now', '-8 days')),

(1, 82.92, DATE('now', '-7 days')),

(2, 55.24, DATE('now', '-7 days')),

(3, 75.25, DATE('now', '-7 days')),

(1, 50.00, DATE('now')),

(2, 55.99, DATE('now')),

(3, 29.95, DATE('now')),

(4, 89.99, DATE('now')),

(5, 599.99, DATE('now'));

INSERT INTO notifications (id, user_id, message, type, status, created_at, device_type, device_id, action_url) VALUES

(1, 1, 'Your order #123abc has been shipped!', 'transaction', 'unread', '2023-06-01 10:16:00', 'mobile_app', 'mobile_8fh2k1', 'app://orders/123abc'),

(2, 1, 'Get 20% off your next purchase! Limited time offer.', 'promotion', 'unread', '2023-06-02 09:00:00', 'email', NULL, 'https://techmart.com/promo/TECH20'),

(3, 2, 'A package is being returned to you. Refund processing...', 'transaction', 'read', '2023-06-07 10:12:00', 'mobile_app', 'mobile_1av8p0', 'app://orders?status=returned'),

(4, 2, 'Your FitLife membership is up for renewal on 7/1', 'general', 'unread', '2023-06-05 15:30:00', 'email', NULL, 'https://fitlifegear.com/renew'),

(5, 3, 'An order from UrbanDining was unsuccessful', 'transaction', 'read', '2023-06-05 12:06:00', 'sms', NULL, 'https://urbandining.co/orders/37cf052d'),

(6, 4, 'Your rental request is pending approval', 'transaction', 'unread', '2023-06-02 20:46:00', 'mobile_app', 'mobile_34jdkl', 'app://bookings/a7659c81'),

(7, 5, 'Claim your 25% discount on craft supplies!', 'promotion', 'archived', '2023-06-01 08:00:00', 'email', NULL, 'https://handycraft.store/CRAFTY10'),

(8, 6, 'Your CodeSuite subscription will renew on 7/1', 'general', 'unread', '2023-06-01 12:00:00', 'email', NULL, 'https://codesuite.io/subscriptions'),

(9, 7, 'Thanks for shopping at ZenHomeGoods! How did we do?', 'general', 'read', '2023-06-02 09:31:00', 'mobile_app', 'mobile_yjp08q', 'https://zenhomesurvey.com/order/c51e10d1'),

(10, 8, 'Playtime! New games and toys have arrived', 'promotion', 'archived', '2023-06-01 18:00:00', 'email', NULL, 'https://kidzplayhouse.com/new-arrivals'),

(11, 9, 'Here''s $10 to start your glow up!', 'promotion', 'unread', '2023-06-01 10:15:00', 'email', NULL, 'https://beautytrending.com/new-customer'),

(12, 10, 'Your order #ord_mjs337 is being processed', 'transaction', 'read', '2023-06-04 19:31:30', 'web_app', 'web_d8180kaf', 'https://gamerush.co/orders/32e2b29c'),

(13, 1, 'New promotion: Get 10% off your next order!', 'promotion', 'unread', DATETIME('now', '-7 days'), 'email', NULL, 'https://techmart.com/promo/TECH10'),

(14, 1, 'Your order #456def has been delivered', 'transaction', 'unread', DATETIME('now', '-14 days'), 'mobile_app', 'mobile_8fh2k1', 'app://orders/456def'),

(15, 2, 'Reminder: Your FitLife membership expires in 7 days', 'general', 'unread', DATETIME('now', '-21 days'), 'email', NULL, 'https://fitlifegear.com/renew'),

(16, 2, 'Weekend Flash Sale: 25% off all activewear!', 'promotion', 'unread', DATETIME('now', '-7 days', '+2 day'), 'mobile_app', 'mobile_yjp08q', 'app://shop/activewear');)], graph_search_results=[], web_search_results=None, document_search_results=None), 'citations': [Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='407f517', object='citation', is_new=True, span=None, source_type=None, payload={'id': '407f5178-bcd0-58c5-aa7f-7a16d132e196', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.04666516279419505, 'text': '"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"customer_info = customers.CALCULATE(\\n",\n\n" key,\\n",\n\n" num_non_special_orders=COUNT(\\n",\n\n" orders.WHERE(~(LIKE(comment, \\"%special%requests%\\")))\\n",\n\n" ),\\n",\n\n")\\n",\n\n"output = PARTITION(customer_info, name=\\"custs\\", by=num_non_special_orders).CALCULATE(\\n",\n\n" C_COUNT=num_non_special_orders, CUSTDIST=COUNT(custs)\\n",\n\n").ORDER_BY(CUSTDIST.DESC(), C_COUNT.DESC())\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "1f793b72-d8ce-4f82-84b5-7e568ee0600a",\n\n"metadata": {},\n\n"source": [\n\n"## Query 14\\n",\n\n"\\n",\n\n"This question seeks seeks to determine **the impact of a promotion on revenue within a particular month**. More specifically, it determines what percentage of the revenue in a given year and month was derived from promotional parts. The query considers only parts actually shipped in that month and gives the percentage. Revenue is defined as extended price times one minus the discount. The chosen year and month are September of 1995.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" 100.00 * SUM(CASE\\n",\n\n" WHEN P_TYPE LIKE \'PROMO%\'\\n",\n\n" THEN L_EXTENDEDPRICE * (1 - L_DISCOUNT)\\n",\n\n" ELSE 0\\n",\n\n" END) / SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS PROMO_REVENUE\\n",\n\n"FROM\\n",\n\n" LINEITEM,\\n",\n\n" PART\\n",\n\n"WHERE\\n",\n\n" L_PARTKEY = P_PARTKEY\\n",\n\n" AND L_SHIPDATE >= DATE \'1995-09-01\'\\n",\n\n" AND L_SHIPDATE < DATE \'1995-10-01\';\\n",\n\n"```"\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "8a843681-0893-4636-a312-75095c730de3",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"value = extended_price * (1 - discount)\\n",\n\n"selected_lines = lines.WHERE(\\n",\n\n" (ship_date >= datetime.date(1995, 9, 1))\\n",\n\n" & (ship_date < datetime.date(1995, 10, 1))\\n",\n\n").CALCULATE(\\n",\n\n" value=value,\\n",\n\n" promo_value=IFF(STARTSWITH(part.part_type, \\"PROMO\\"), value, 0),\\n",\n\n")\\n",\n\n"output = TPCH.CALCULATE(PROMO_REVENUE=100.0 * SUM(selected_lines.promo_value) / SUM(selected_lines.value))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "1734b0e1-a4bb-456b-a41e-fa6440c87e85",\n\n"metadata": {},\n\n"source": [\n\n"## Query 15\\n",\n\n"\\n",\n\n"This question seeks to determine **the top supplier within a particular quarter**. It does so by finding the supplier who contributed the most to the overall revenue for parts shipped during a given quarter of a given year. In case of a tie, the query lists all suppliers whose contribution was equal to the maximum, presented in supplier number order. The chosen quarter is the first 3 months of 1996.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"with REVENUE (SUPPLIER_NO, TOTAL_REVENUE) AS\\n",\n\n" SELECT\\n",\n\n" L_SUPPKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT))\\n",\n\n" FROM\\n",\n\n" LINEITEM\\n",\n\n" WHERE\\n",\n\n" L_SHIPDATE >= DATE \'1996-01-01\'\\n",\n\n" AND L_SHIPDATE < DATE \'1996-04-01\'\\n",\n\n" GROUP BY\\n",\n\n" L_SUPPKEY;\\n",\n\n"\\n",\n\n"SELECT\\n",\n\n" S_SUPPKEY,\\n",\n\n" S_NAME,\\n",\n\n" S_ADDRESS,\\n",\n\n" S_PHONE,\\n",\n\n" TOTAL_REVENUE\\n",\n\n"FROM\\n",\n\n" SUPPLIER,\\n",\n\n" REVENUE\\n",\n\n"WHERE\\n",\n\n" S_SUPPKEY = SUPPLIER_NO AND\\n",\n\n" TOTAL_REVENUE = (\\n",\n\n" SELECT\\n",\n\n" MAX(TOTAL_REVENUE)\\n",\n\n" FROM\\n",\n\n" REVENUE0\\n",\n\n" )\\n",\n\n"ORDER BY\\n",\n\n" SUPPLIER_NO;\\n",\n\n"```\\n",\n\n"\\n",\n\n"With PyDough, the total revenue per-supplier can be expressed via contextless expressions which are first placed into context for the global aggregation to find the maximum revenue overall, then used again to be associated per-supplier."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "a3f9b025-3ae7-4c7d-888c-a430cbe536b2",\n\n"metadata": {},\n\n"outputs": [],', 'metadata': {'version': 'v0', 'chunk_order': 30, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 6, 'full_text_rank': 26, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='e676197', object='citation', is_new=True, span=None, source_type=None, payload={'id': 'e676197f-fc6b-5330-99cf-656de9832e44', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.046300398759415155, 'text': '# names in a rolling window.\n\n⋮----\n\ndef avg_order_diff_per_customer()\n\n⋮----\n\n# Finds the 5 customers with the highest average difference in days between\n\n# orders made.\n\nprev_order_date_by_cust = PREV(order_date, by=order_date.ASC(), levels=1)\n\norder_info = orders.CALCULATE(\n\nselected_customers = Customers.WHERE(HAS(order_info))\n\n⋮----\n\ndef yoy_change_in_num_orders()\n\n⋮----\n\n# For every year, counts the number of orders made in that year and the\n\n# percentage change from the previous year.\n\nyears = PARTITION(\n\ncurrent_year_orders = COUNT(orders_in_year)\n\nprev_year_orders = PREV(COUNT(orders_in_year), by=year.ASC())\n\n⋮----\n\ndef first_order_in_year()\n\n⋮----\n\n# Find all orders that do not have a previous order in the same year\n\n# (breaking ties by order key).\n\nprevious_order_date = PREV(order_date, by=(order_date.ASC(), key.ASC()))\n\n⋮----\n\ndef customer_largest_order_deltas()\n\n⋮----\n\n# For each customer, find the highest positive/negative difference in\n\n# revenue between one of their orders and and the most recent order before\n\n# it, ignoring their first ever order. Return the 5 customers with the\n\n# largest such difference. Only consider customers with orders.\n\nline_revenue = extended_price * (1 - discount)\n\norder_revenue = SUM(lines.CALCULATE(r=line_revenue).r)\n\nprevious_order_revenue = PREV(order_revenue, by=order_date.ASC(), levels=1)\n\norders_info = orders.WHERE(PRESENT(previous_order_revenue)).CALCULATE(\n\n⋮----\n\ndef suppliers_bal_diffs()\n\n⋮----\n\n# Finds the 5 suppliers with the largest difference in account balance from\n\n# the supplier with the next smallest account balance in the same region.\n\n⋮----\n\ndef month_year_sliding_windows()\n\n⋮----\n\n# Finds all months where the total amount spent by customers on orders in\n\n# that month was more than the preceding/following month, and the amount\n\n# spent in that year was more than the following year.\n\nym_groups = PARTITION(\n\ny_groups = (\n\n⋮----\n\ndef avg_gap_prev_urgent_same_clerk()\n\n⋮----\n\n# Finds the average gap in days between each urgent order and the previous\n\n# urgent order handled by the same clerk\n\nurgent_orders = Orders.WHERE(order_priority == "1-URGENT")\n\nclerks = PARTITION(urgent_orders, name="orders", by=clerk)\n\norder_info = clerks.orders.CALCULATE(\n\n⋮----\n\ndef nation_window_aggs()\n\n⋮----\n\n# Calculating multiple global windowed aggregations for each nation, only\n\n# considering nations whose names do not start with a vowel.\n\n⋮----\n\ndef region_nation_window_aggs()\n\n⋮----\n\n# per-region, considering nations whose names do not start with a vowel.\n\n⋮----\n\ndef supplier_pct_national_qty()\n\n⋮----\n\n# Find the 5 African suppliers with the highest percentage of total\n\n# quantity of product shipped from them out of all suppliers in that nation\n\n# meeting certain criteria. Include for each such supplier their name,\n\n# nation name, the quantity, and the percentage. The criteria are that the\n\n# shipments were done in 1998, they were shipped by ship, the part shipped\n\n# had had "tomato" in the name and was a large container. Also, when\n\n# finding the sum for each naiton and the best suppliers, ignore all\n\n# suppliers with a negative account balance and whose comments do not\n\n# contain the word "careful".\n\nselected_lines = lines.WHERE(\n\nsupp_qty = SUM(selected_lines.quantity)\n\n⋮----\n\ndef highest_priority_per_year()\n\n⋮----\n\n# For each year, identify the priority with the highest percentage of\n\n# made in that year with that priority, listing the year, priority, and\n\n# percentage. Sort the results by year.\n\norder_info = Orders.CALCULATE(order_year=YEAR(order_date))\n\nyear_priorities = PARTITION(\n\nyears = PARTITION(year_priorities, name="priorities", by=order_year)\n\n⋮----\n\ndef nation_best_order()\n\n⋮----\n\n# For each Asian nation, identify the most expensive order made by a\n\n# customer in that nation in 1998, listing the nation name, customer\n\n# name, order key, the order\'s price, and percentage of the price of\n\n# all orders made in 1998. Order the nations alphabetically.\n\nselected_nations = Nations.WHERE(region.name == "ASIA")\n\nbest_order = (\n\n⋮----', 'metadata': {'version': 'v0', 'chunk_order': 414, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 1, 'full_text_rank': 18, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='e676197', object='citation', is_new=True, span=None, source_type=None, payload={'id': 'e676197f-fc6b-5330-99cf-656de9832e44', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.046300398759415155, 'text': '# names in a rolling window.\n\n⋮----\n\ndef avg_order_diff_per_customer()\n\n⋮----\n\n# Finds the 5 customers with the highest average difference in days between\n\n# orders made.\n\nprev_order_date_by_cust = PREV(order_date, by=order_date.ASC(), levels=1)\n\norder_info = orders.CALCULATE(\n\nselected_customers = Customers.WHERE(HAS(order_info))\n\n⋮----\n\ndef yoy_change_in_num_orders()\n\n⋮----\n\n# For every year, counts the number of orders made in that year and the\n\n# percentage change from the previous year.\n\nyears = PARTITION(\n\ncurrent_year_orders = COUNT(orders_in_year)\n\nprev_year_orders = PREV(COUNT(orders_in_year), by=year.ASC())\n\n⋮----\n\ndef first_order_in_year()\n\n⋮----\n\n# Find all orders that do not have a previous order in the same year\n\n# (breaking ties by order key).\n\nprevious_order_date = PREV(order_date, by=(order_date.ASC(), key.ASC()))\n\n⋮----\n\ndef customer_largest_order_deltas()\n\n⋮----\n\n# For each customer, find the highest positive/negative difference in\n\n# revenue between one of their orders and and the most recent order before\n\n# it, ignoring their first ever order. Return the 5 customers with the\n\n# largest such difference. Only consider customers with orders.\n\nline_revenue = extended_price * (1 - discount)\n\norder_revenue = SUM(lines.CALCULATE(r=line_revenue).r)\n\nprevious_order_revenue = PREV(order_revenue, by=order_date.ASC(), levels=1)\n\norders_info = orders.WHERE(PRESENT(previous_order_revenue)).CALCULATE(\n\n⋮----\n\ndef suppliers_bal_diffs()\n\n⋮----\n\n# Finds the 5 suppliers with the largest difference in account balance from\n\n# the supplier with the next smallest account balance in the same region.\n\n⋮----\n\ndef month_year_sliding_windows()\n\n⋮----\n\n# Finds all months where the total amount spent by customers on orders in\n\n# that month was more than the preceding/following month, and the amount\n\n# spent in that year was more than the following year.\n\nym_groups = PARTITION(\n\ny_groups = (\n\n⋮----\n\ndef avg_gap_prev_urgent_same_clerk()\n\n⋮----\n\n# Finds the average gap in days between each urgent order and the previous\n\n# urgent order handled by the same clerk\n\nurgent_orders = Orders.WHERE(order_priority == "1-URGENT")\n\nclerks = PARTITION(urgent_orders, name="orders", by=clerk)\n\norder_info = clerks.orders.CALCULATE(\n\n⋮----\n\ndef nation_window_aggs()\n\n⋮----\n\n# Calculating multiple global windowed aggregations for each nation, only\n\n# considering nations whose names do not start with a vowel.\n\n⋮----\n\ndef region_nation_window_aggs()\n\n⋮----\n\n# per-region, considering nations whose names do not start with a vowel.\n\n⋮----\n\ndef supplier_pct_national_qty()\n\n⋮----\n\n# Find the 5 African suppliers with the highest percentage of total\n\n# quantity of product shipped from them out of all suppliers in that nation\n\n# meeting certain criteria. Include for each such supplier their name,\n\n# nation name, the quantity, and the percentage. The criteria are that the\n\n# shipments were done in 1998, they were shipped by ship, the part shipped\n\n# had had "tomato" in the name and was a large container. Also, when\n\n# finding the sum for each naiton and the best suppliers, ignore all\n\n# suppliers with a negative account balance and whose comments do not\n\n# contain the word "careful".\n\nselected_lines = lines.WHERE(\n\nsupp_qty = SUM(selected_lines.quantity)\n\n⋮----\n\ndef highest_priority_per_year()\n\n⋮----\n\n# For each year, identify the priority with the highest percentage of\n\n# made in that year with that priority, listing the year, priority, and\n\n# percentage. Sort the results by year.\n\norder_info = Orders.CALCULATE(order_year=YEAR(order_date))\n\nyear_priorities = PARTITION(\n\nyears = PARTITION(year_priorities, name="priorities", by=order_year)\n\n⋮----\n\ndef nation_best_order()\n\n⋮----\n\n# For each Asian nation, identify the most expensive order made by a\n\n# customer in that nation in 1998, listing the nation name, customer\n\n# name, order key, the order\'s price, and percentage of the price of\n\n# all orders made in 1998. Order the nations alphabetically.\n\nselected_nations = Nations.WHERE(region.name == "ASIA")\n\nbest_order = (\n\n⋮----', 'metadata': {'version': 'v0', 'chunk_order': 414, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 1, 'full_text_rank': 18, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='407f517', object='citation', is_new=True, span=None, source_type=None, payload={'id': '407f5178-bcd0-58c5-aa7f-7a16d132e196', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.04666516279419505, 'text': '"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"customer_info = customers.CALCULATE(\\n",\n\n" key,\\n",\n\n" num_non_special_orders=COUNT(\\n",\n\n" orders.WHERE(~(LIKE(comment, \\"%special%requests%\\")))\\n",\n\n" ),\\n",\n\n")\\n",\n\n"output = PARTITION(customer_info, name=\\"custs\\", by=num_non_special_orders).CALCULATE(\\n",\n\n" C_COUNT=num_non_special_orders, CUSTDIST=COUNT(custs)\\n",\n\n").ORDER_BY(CUSTDIST.DESC(), C_COUNT.DESC())\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "1f793b72-d8ce-4f82-84b5-7e568ee0600a",\n\n"metadata": {},\n\n"source": [\n\n"## Query 14\\n",\n\n"\\n",\n\n"This question seeks seeks to determine **the impact of a promotion on revenue within a particular month**. More specifically, it determines what percentage of the revenue in a given year and month was derived from promotional parts. The query considers only parts actually shipped in that month and gives the percentage. Revenue is defined as extended price times one minus the discount. The chosen year and month are September of 1995.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" 100.00 * SUM(CASE\\n",\n\n" WHEN P_TYPE LIKE \'PROMO%\'\\n",\n\n" THEN L_EXTENDEDPRICE * (1 - L_DISCOUNT)\\n",\n\n" ELSE 0\\n",\n\n" END) / SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS PROMO_REVENUE\\n",\n\n"FROM\\n",\n\n" LINEITEM,\\n",\n\n" PART\\n",\n\n"WHERE\\n",\n\n" L_PARTKEY = P_PARTKEY\\n",\n\n" AND L_SHIPDATE >= DATE \'1995-09-01\'\\n",\n\n" AND L_SHIPDATE < DATE \'1995-10-01\';\\n",\n\n"```"\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "8a843681-0893-4636-a312-75095c730de3",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"value = extended_price * (1 - discount)\\n",\n\n"selected_lines = lines.WHERE(\\n",\n\n" (ship_date >= datetime.date(1995, 9, 1))\\n",\n\n" & (ship_date < datetime.date(1995, 10, 1))\\n",\n\n").CALCULATE(\\n",\n\n" value=value,\\n",\n\n" promo_value=IFF(STARTSWITH(part.part_type, \\"PROMO\\"), value, 0),\\n",\n\n")\\n",\n\n"output = TPCH.CALCULATE(PROMO_REVENUE=100.0 * SUM(selected_lines.promo_value) / SUM(selected_lines.value))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "1734b0e1-a4bb-456b-a41e-fa6440c87e85",\n\n"metadata": {},\n\n"source": [\n\n"## Query 15\\n",\n\n"\\n",\n\n"This question seeks to determine **the top supplier within a particular quarter**. It does so by finding the supplier who contributed the most to the overall revenue for parts shipped during a given quarter of a given year. In case of a tie, the query lists all suppliers whose contribution was equal to the maximum, presented in supplier number order. The chosen quarter is the first 3 months of 1996.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"with REVENUE (SUPPLIER_NO, TOTAL_REVENUE) AS\\n",\n\n" SELECT\\n",\n\n" L_SUPPKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT))\\n",\n\n" FROM\\n",\n\n" LINEITEM\\n",\n\n" WHERE\\n",\n\n" L_SHIPDATE >= DATE \'1996-01-01\'\\n",\n\n" AND L_SHIPDATE < DATE \'1996-04-01\'\\n",\n\n" GROUP BY\\n",\n\n" L_SUPPKEY;\\n",\n\n"\\n",\n\n"SELECT\\n",\n\n" S_SUPPKEY,\\n",\n\n" S_NAME,\\n",\n\n" S_ADDRESS,\\n",\n\n" S_PHONE,\\n",\n\n" TOTAL_REVENUE\\n",\n\n"FROM\\n",\n\n" SUPPLIER,\\n",\n\n" REVENUE\\n",\n\n"WHERE\\n",\n\n" S_SUPPKEY = SUPPLIER_NO AND\\n",\n\n" TOTAL_REVENUE = (\\n",\n\n" SELECT\\n",\n\n" MAX(TOTAL_REVENUE)\\n",\n\n" FROM\\n",\n\n" REVENUE0\\n",\n\n" )\\n",\n\n"ORDER BY\\n",\n\n" SUPPLIER_NO;\\n",\n\n"```\\n",\n\n"\\n",\n\n"With PyDough, the total revenue per-supplier can be expressed via contextless expressions which are first placed into context for the global aggregation to find the maximum revenue overall, then used again to be associated per-supplier."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "a3f9b025-3ae7-4c7d-888c-a430cbe536b2",\n\n"metadata": {},\n\n"outputs": [],', 'metadata': {'version': 'v0', 'chunk_order': 30, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 6, 'full_text_rank': 26, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}}), Citation(id='82a3091', object='citation', is_new=True, span=None, source_type=None, payload={'id': '82a30918-a85a-569a-8426-4a8af21165ab', 'document_id': '87c20b3c-907d-59ae-8d82-c50d5db9e73f', 'owner_id': 'e91aeb9c-e28a-5d58-aabb-d8a9c076a798', 'collection_ids': ['81ae9232-fdb2-576d-b7e2-f3ada019def2'], 'score': 0.048651507139079855, 'text': ']\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "27365f94-32a0-48f1-9589-711d57cf145b",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"selected_parts = (\\n",\n\n" nations.CALCULATE(n_name=name)\\n",\n\n" .WHERE(region.name == \\"EUROPE\\")\\n",\n\n" .suppliers.CALCULATE(\\n",\n\n" s_acctbal=account_balance,\\n",\n\n" s_name=name,\\n",\n\n" s_address=address,\\n",\n\n" s_phone=phone,\\n",\n\n" s_comment=comment,\\n",\n\n" )\\n",\n\n" .supply_records.CALCULATE(\\n",\n\n" supplycost=supplycost,\\n",\n\n" )\\n",\n\n" .part.WHERE(ENDSWITH(part_type, \\"BRASS\\") & (size == 15))\\n",\n\n" )\\n",\n\n"part_groups = PARTITION(selected_parts, name=\\"p\\", by=key).CALCULATE(\\n",\n\n" best_cost=MIN(p.supplycost)\\n",\n\n")\\n",\n\n"output = part_groups.p.WHERE(\\n",\n\n" (supplycost == best_cost)\\n",\n\n" & ENDSWITH(part_type, \\"BRASS\\")\\n",\n\n" & (size == 15)\\n",\n\n").CALCULATE(\\n",\n\n" S_ACCTBAL=s_acctbal,\\n",\n\n" S_NAME=s_name,\\n",\n\n" N_NAME=n_name,\\n",\n\n" P_PARTKEY=key,\\n",\n\n" P_MFGR=manufacturer,\\n",\n\n" S_ADDRESS=s_address,\\n",\n\n" S_PHONE=s_phone,\\n",\n\n" S_COMMENT=s_comment,\\n",\n\n").TOP_K(\\n",\n\n" 100,\\n",\n\n" by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\\n",\n\n")\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "c4979e37-388e-48df-9165-ecd3c71571c1",\n\n"metadata": {},\n\n"source": [\n\n"## Query 3\\n",\n\n"\\n",\n\n"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.\\n",\n\n"\\n",\n\n"Here is the corresponding SQL:\\n",\n\n"\\n",\n\n"```SQL\\n",\n\n"SELECT\\n",\n\n" L_ORDERKEY,\\n",\n\n" SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"FROM\\n",\n\n" CUSTOMER,\\n",\n\n" ORDERS,\\n",\n\n" LINEITEM\\n",\n\n"WHERE\\n",\n\n" C_MKTSEGMENT = \'BUILDING\'\\n",\n\n" AND C_CUSTKEY = O_CUSTKEY\\n",\n\n" AND L_ORDERKEY = O_ORDERKEY\\n",\n\n" AND O_ORDERDATE < DATE \'1995-03-15\'\\n",\n\n" AND L_SHIPDATE > DATE \'1995-03-15\'\\n",\n\n"GROUP BY\\n",\n\n" L_ORDERKEY,\\n",\n\n" O_ORDERDATE,\\n",\n\n" O_SHIPPRIORITY\\n",\n\n"ORDER BY\\n",\n\n" REVENUE DESC,\\n",\n\n" O_ORDERDATE\\n",\n\n"LIMIT 10;\\n",\n\n"```\\n",\n\n"\\n",\n\n"PyDough allows us to first derive `selected_lines` as the data to be partitioned, before grouping it by certain partition keys to compute the aggregations."\n\n]\n\n},\n\n{\n\n"cell_type": "code",\n\n"execution_count": null,\n\n"id": "95975cba-e8e2-4ac9-bbc2-874c0ab43418",\n\n"metadata": {},\n\n"outputs": [],\n\n"source": [\n\n"%%pydough\\n",\n\n"\\n",\n\n"cutoff_date = datetime.date(1995, 3, 15)\\n",\n\n"selected_orders = orders.CALCULATE(\\n",\n\n" order_date, ship_priority\\n",\n\n").WHERE(\\n",\n\n" (customer.mktsegment == \\"BUILDING\\") & (order_date < cutoff_date)\\n",\n\n")\\n",\n\n"selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)\\n",\n\n"output = PARTITION(\\n",\n\n" selected_lines, name=\\"l\\", by=(order_key, order_date, ship_priority)\\n",\n\n").CALCULATE(\\n",\n\n" L_ORDERKEY=order_key,\\n",\n\n" REVENUE=SUM(l.extended_price * (1 - l.discount)),\\n",\n\n" O_ORDERDATE=order_date,\\n",\n\n" O_SHIPPRIORITY=ship_priority,\\n",\n\n").TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\\n",\n\n"pydough.to_df(output)"\n\n]\n\n},\n\n{\n\n"cell_type": "markdown",\n\n"id": "a72bd083-12c7-402e-8b44-22d640308a7f",\n\n"metadata": {},', 'metadata': {'version': 'v0', 'chunk_order': 23, 'document_type': 'md', 'unstructured_filetype': 'text/plain', 'unstructured_languages': ['eng'], 'partitioned_by_unstructured': True, 'semantic_rank': 3, 'full_text_rank': 7, 'associated_query': '2. Retrieve the ten unshipped orders that have the greatest revenue, also providing their shipping priority and potential revenue defined as the sum of the extended price times one minus the discount, for those orders that were not shipped by March 15, 1995. Ensure the'}})], 'metadata': {'id': 'msg_01YHrndE1jzSxHj8sCWjMqvt', 'choices': [{'finish_reason': 'stop', 'index': 0, 'message': {'refusal': None, 'role': 'assistant', 'function_call': None, 'tool_calls': None, 'structured_content': None}}], 'created': 1745981644, 'model': 'claude-3-7-sonnet-20250219', 'object': 'chat.completion', 'service_tier': None, 'system_fingerprint': None, 'usage': {'prompt_tokens': 31328, 'completion_tokens': 1976, 'total_tokens': 33304}}, 'completion': '# Explanation of Pydough Code for Finding Top 10 Unshipped Orders\n\n## Overview\n\nThe provided Pydough code implements TPC-H query #3, which finds the 10 unshipped orders with the highest value as of March 15th, 1995. Let me explain the code in detail based on the provided documentation.\n\n## Pydough-Specific Functions and Patterns\n\n### 1. WHERE Function\nThe code uses the `WHERE` function to filter data based on specific conditions:\n\n```python\nselected_orders = orders.WHERE(\n    (customer.mktsegment == "BUILDING") & (order_date < cutoff_date)\n)\n```\n\nThis pattern is seen in multiple examples in the documentation [82a3091], where `WHERE` is used to filter collections based on boolean conditions.\n\n### 2. PARTITION Function\nThe `PARTITION` function is used to group data by specific keys and perform aggregations:\n\n```python\nresult = PARTITION(\n    selected_lines, name="l", by=(order_key, order_date, ship_priority)\n)(\n    L_ORDERKEY=order_key,\n    REVENUE=SUM(l.extended_price * (1 - l.discount)),\n    O_ORDERDATE=order_date,\n    O_SHIPPRIORITY=ship_priority,\n)\n```\n\nThis is similar to the pattern shown in [407f517] where `PARTITION` is used to group customer information by the number of non-special orders:\n\n```python\noutput = PARTITION(customer_info, name="custs", by=num_non_special_orders).CALCULATE(\n    C_COUNT=num_non_special_orders, CUSTDIST=COUNT(custs)\n)\n```\n\n### 3. TOP_K Function\nThe `TOP_K` function is used to limit results to the top K items based on specified ordering:\n\n```python\n.TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\n```\n\nThis pattern is demonstrated in [82a3091] where `TOP_K` is used to get the top 100 results:\n\n```python\n.TOP_K(\n    100,\n    by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),\n)\n```\n\n### 4. BACK Function\nThe `BACK` function is used to reference parent collections in the data hierarchy:\n\n```python\nselected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)(\n    BACK(1).order_date,\n    BACK(1).ship_priority,\n)\n```\n\nAccording to [e676197], `BACK` is used to reference previous items in a sequence, such as in time-series data.\n\n### 5. Aggregation Functions (SUM)\nThe code uses the `SUM` aggregation function to calculate the total revenue:\n\n```python\nREVENUE=SUM(l.extended_price * (1 - l.discount))\n```\n\nThis pattern is seen in [82a3091] where `SUM` is used to calculate various aggregations.\n\n## Data Flow and Transformations\n\nThe code follows a clear data flow:\n\n1. **Define a cutoff date**: `cutoff_date = datetime.date(1995, 3, 15)`\n\n2. **Filter orders**: Select orders from the "BUILDING" market segment that were placed before the cutoff date [82a3091]:\n   ```python\n   selected_orders = orders.WHERE(\n       (customer.mktsegment == "BUILDING") & (order_date < cutoff_date)\n   )\n   ```\n\n3. **Filter line items**: From the selected orders, get line items that haven\'t shipped yet (ship date after cutoff date) and include order date and shipping priority from the parent order [82a3091]:\n   ```python\n   selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)(\n       BACK(1).order_date,\n       BACK(1).ship_priority,\n   )\n   ```\n\n4. **Group and aggregate**: Group the selected line items by order key, order date, and shipping priority, then calculate the revenue for each group [82a3091]:\n   ```python\n   result = PARTITION(\n       selected_lines, name="l", by=(order_key, order_date, ship_priority)\n   )(\n       L_ORDERKEY=order_key,\n       REVENUE=SUM(l.extended_price * (1 - l.discount)),\n       O_ORDERDATE=order_date,\n       O_SHIPPRIORITY=ship_priority,\n   )\n   ```\n\n5. **Sort and limit**: Get the top 10 orders with the highest revenue, breaking ties by order date (ascending) and then order key (ascending) [82a3091]:\n   ```python\n   .TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))\n   ```\n\n## Pydough Best Practices Demonstrated\n\n1. **Clear variable naming**: Variables like `cutoff_date`, `selected_orders`, and `selected_lines` clearly indicate their purpose [82a3091].\n\n2. **Progressive data refinement**: The code starts with all orders and progressively filters and transforms the data [82a3091].\n\n3. **Efficient use of relationships**: The code leverages the relationship between orders and line items using the `.lines` accessor [82a3091].\n\n4. **Proper use of BACK**: The code uses `BACK(1)` to reference parent collections when needed [e676197].\n\n5. **Appropriate sorting**: The code uses multiple sorting criteria to ensure deterministic results [82a3091].\n\n## How the Code Follows Pydough Conventions\n\n1. **Chaining operations**: The code chains operations like `WHERE`, `PARTITION`, and `TOP_K` to create a readable data pipeline [82a3091].\n\n2. **Using parentheses for method arguments**: The code uses parentheses to pass arguments to methods [82a3091].\n\n3. **Using aliases in PARTITION**: The code assigns a name (`"l"`) to the partitioned elements for reference in aggregations [407f517].\n\n4. **Using descriptive column names**: The output columns are named according to the TPC-H specification (L_ORDERKEY, REVENUE, etc.) [82a3091].\n\n## How the Code Addresses the Original Question\n\nThe code directly addresses the requirements of TPC-H query #3:\n\n1. It filters orders to those from the "BUILDING" market segment placed before March 15th, 1995 [82a3091].\n\n2. It identifies line items that haven\'t shipped yet (ship date after March 15th, 1995) [82a3091].\n\n3. It calculates the potential revenue for each order as the sum of extended price times (1 - discount) [82a3091].\n\n4. It returns the top 10 orders with the highest revenue, sorted by revenue (descending), order date (ascending), and order key (ascending) [82a3091].\n\n5. For each order, it includes the order key, revenue, order date, and shipping priority [82a3091].\n\n## Comparison with SQL\n\nThe Pydough code is equivalent to the SQL query shown in [82a3091]:\n\n```sql\nSELECT\n  L_ORDERKEY,\n  SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,\n  O_ORDERDATE,\n  O_SHIPPRIORITY\nFROM\n  CUSTOMER,\n  ORDERS,\n  LINEITEM\nWHERE\n  C_MKTSEGMENT = \'BUILDING\'\n  AND C_CUSTKEY = O_CUSTKEY\n  AND L_ORDERKEY = O_ORDERKEY\n  AND O_ORDERDATE < DATE \'1995-03-15\'\n  AND L_SHIPDATE > DATE \'1995-03-15\'\nGROUP BY\n  L_ORDERKEY,\n  O_ORDERDATE,\n  O_SHIPPRIORITY\nORDER BY\n  REVENUE DESC,\n  O_ORDERDATE\nLIMIT 10;\n```\n\nThe Pydough code achieves the same result with a more readable and concise syntax, leveraging the relationships between entities in the data model.'}
