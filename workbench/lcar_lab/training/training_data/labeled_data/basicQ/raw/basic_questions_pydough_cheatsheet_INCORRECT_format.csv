question,gemini_answer
What function must be used to verify a 1-to-N relationship between tables, identified by a plural subcollection name?,Use the `HAS` function. Example: `nations.WHERE(HAS(customers.orders)==1)`
Is PyDough syntax identical to SQL?,No. The cheat sheet explicitly states: "This is NOT SQL, so don't make assumptions about its syntax or behavior."
When should `TOP_K` be used instead of `ORDER_BY`?,Use `TOP_K` when you need to order records *and* select a specific number (k) of highest, lowest, or specific records.
If a query asks for a year-over-year comparison but doesn't specify years, which years should be included according to the TPC data context?,The calculation must be performed for each available year: 1995, 1996, 1997, and 1998, using the `SINGULAR` function for each year's result.
What must be done before referencing an attribute from a previous collection in a subsequent operation?,The attribute must have been previously calculated using `CALCULATE`.
What is the limitation of the `CALCULATE` function regarding plural sub-collections?,`CALCULATE` ONLY supports singular expressions. Aggregation functions MUST be used if you need to operate on plural sub-collections.
How is ranking performed in PyDough? Is it a method or a function?,Ranking is used as a function (`RANKING(...)`), not a method.
What type of argument must be provided to the `by` parameter in functions like `TOP_K` and `ORDER_BY`?,You must ALWAYS provide an expression, not a collection or subcollection.
What are the two mandatory parameters for the `PARTITION` function?,`name` and `by`.
What types of arguments are forbidden within the `by` parameter of the `PARTITION` function?,Collections, subcollections, or direct calculations are forbidden. Any required variable must be pre-calculated.
Can `PARTITION` accept a collection as its primary input?,No, `PARTITION` does not support receiving a collection directly; it must be used as a method on an existing collection or expression result.
Can you partition by the key of the collection itself using `PARTITION`?,No, you should never partition by the key or the collection key using the `PARTITION` method.
Can `CALCULATE` directly output a collection generated by a function like `TOP_K`?,No, `CALCULATE` always needs an expression, not a collection. `TOP_K` returns a collection.
What is the recommended approach in PyDough for complex calculations instead of breaking them into many intermediate steps?,Leverage `CALCULATE` for direct aggregation, use `WHERE` for filtering at the correct scope, apply functions like `SUM` or `TOP_K` hierarchically, and avoid unnecessary partitioning unless required.
How should you handle calculations involving attributes from different child collections within the same parent (e.g., `price * discount` from `lines`)?,Use an intermediate `CALCULATE` on the child collection first (e.g., `lines.CALCULATE(value = extended_price * (1 - discount))`) and then aggregate the result (e.g., `SUM(... .value)`).
If you need to find the top-ranked items within a `CALCULATE` operation, which function is suitable?,Use the `RANKING` function and then filter the results based on the rank number.
How do you access the 'People' collection?,`People`
How do you access the 'current_address' linked to 'People'?,`People.current_address`
How do you access the 'customer' linked to 'Packages'?,`Packages.customer`
What is the primary purpose of the `CALCULATE` function?,To derive new fields, rename existing ones, or select specific fields.
Write the syntax to select only the `first_name` and `last_name` from the `People` collection.,`People.CALCULATE(first_name=first_name, last_name=last_name)`
Write the syntax to create a `customer_name` field by joining `first_name` and `last_name` from a `customer` sub-collection within `Packages`.,`Packages.CALCULATE(customer_name=JOIN_STRINGS(' ', customer.first_name, customer.last_name))`
Can you use `SUM(orders)` directly inside a `CALCULATE` if `orders` is a plural sub-collection?,No, you must use an aggregation function like `SUM` or `COUNT` for plural sub-collections within `CALCULATE`. E.g., `CALCULATE(order_count=COUNT(orders))`.
In `CALCULATE(new_field=a+b, another_field=new_field*2)`, is `another_field` calculated correctly in the same step?,No. New fields defined in `CALCULATE` only take effect *after* it completes. A second `CALCULATE` is needed to use `new_field`.
If a field exists before a `CALCULATE` but is not mentioned inside it, can it still be referenced later?,Yes, existing fields not included in a `CALCULATE` can still be referenced but won't be part of that specific `CALCULATE`'s output unless included in the *final* `CALCULATE` clause.
What does performing a `CALCULATE` directly on the graph (e.g., `GRAPH.CALCULATE(...)`) create?,It creates a collection with one row and columns corresponding to the properties defined inside the `CALCULATE`.
What is the syntax for filtering records using `WHERE`?,`.WHERE(condition)`
Write the PyDough code to filter `People` with an `acctbal` less than 0.,`People.WHERE(acctbal < 0)`
Write the PyDough code to filter `Packages` ordered in the year 2023.,`Packages.WHERE(YEAR(order_date) == 2023)`
Write the PyDough code to filter `Addresses` that have at least one `current_occupants`.,`Addresses.WHERE(HAS(current_occupants)==1)`
What operators are used for logical AND, OR, and NOT in `WHERE` clauses?,`&` (AND), `|` (OR), `~` (NOT).
How should you express a chained comparison like `a < b < c` in a `WHERE` clause?,Use `(a < b) & (b < c)`.
What is the syntax for sorting records using `ORDER_BY`?,`.ORDER_BY(field.ASC()/DESC(), ...)`
How do you specify ascending sort order with nulls appearing last?,`.ASC(na_pos='last')`
How do you specify descending sort order with nulls appearing first?,`.DESC(na_pos='first')`
Write the PyDough code to sort `People` alphabetically by `last_name` then `first_name`.,`People.ORDER_BY(last_name.ASC(), first_name.ASC())`
Write the PyDough code to sort `Packages` by `package_cost` with the most expensive first.,`Packages.ORDER_BY(package_cost.DESC())`
What is the syntax for selecting the top 'k' records using `TOP_K`?,`.TOP_K(k, by=field.DESC())` (or .ASC())
Write the PyDough code to find the top 10 `customers` based on the count of their `orders` (highest count first).,`customers.TOP_K(10, by=COUNT(orders).DESC())`
Are the `k` and `by` parameters optional in `TOP_K`?,No, both parameters are obligatory.
What function checks if a collection has at least one record?,`HAS(collection)`
What function checks if a collection is empty?,`HASNOT(collection)`
What function counts the number of non-null records in a collection?,`COUNT(collection)`
What function calculates the sum of values in a collection?,`SUM(collection)`
What function calculates the average of values in a collection?,`AVG(collection)`
What functions find the minimum and maximum values in a collection?,`MIN(collection)` and `MAX(collection)`
What function counts the number of distinct values in a collection?,`NDISTINCT(collection)`
Can aggregation functions be nested, e.g., `SUM(COUNT(orders))`?,No, aggregations function does not support calling aggregations inside of aggregations.
What is the primary purpose of the `PARTITION` function/method?,To group records based on one or more key fields.
What is the basic syntax for `PARTITION`?,`Collection.PARTITION(name='group_name', by=(key1, key2))`
In the `CALCULATE` following a `PARTITION`, how should you refer to the partition keys specified in the `by` clause?,Refer to them directly by their names (e.g., `state`), not by their original path (e.g., `Addresses.state`).
What type of fields must be used as partition keys in the `by` clause?,Scalar fields from the collection being partitioned. Calculations must be done beforehand.
How must plural sub-collections be accessed within a `CALCULATE` after a `PARTITION`?,Using aggregation functions (e.g., `COUNT`, `SUM`).
How can you access the original collection's data *after* a `PARTITION` operation, filtered by the partition groups?,By using the original collection name as if it were a sub-collection of the partitioned result (e.g., `partition_result.OriginalCollectionName`).
Consider `Addresses.PARTITION(name="states", by=(state))`. Write the `CALCULATE` to get the state and count of people (`current_occupants`) per state.,`Addresses.PARTITION(name="states", by=(state)).CALCULATE(state, n_people=COUNT(Addresses.current_occupants))`
Why is `Packages.PARTITION(name="years", by=YEAR(order_date))` invalid?,Because `YEAR(order_date)` is a calculation and cannot be directly used in the `by` clause. It must be calculated first using `CALCULATE`.
Why is `People.CALCULATE(birth_year=YEAR(birth_date)).PARTITION(name="years", by=birth_year).CALCULATE(birth_year, email, n_people=COUNT(People))` invalid?,Because `email` is referenced directly in the final `CALCULATE`, but it is not a partition key (`birth_year`). Non-key fields must be aggregated if they are plural relative to the partition group.
What does the `per` argument in window functions like `RANKING` specify?,It specifies an ancestor context (by name) relative to which the window function should be calculated (partitioning the calculation). If omitted, it applies globally to the current collection.
How do you disambiguate if there are multiple ancestors with the same name when using the `per` argument?,Use a suffix `:idx`, where `1` is the most recent ancestor, `2` is the second most recent, etc. (e.g., `per="groups:1"`).
What is the syntax for the `RANKING` function?,`RANKING(by=expression.ASC()/DESC(), per='collection_name', allow_ties=False, dense=False)`
How do you rank customers globally based on descending `acctbal`?,`customers.CALCULATE(r=RANKING(by=acctbal.DESC()))`
How do you rank customers based on descending `acctbal` *within* each `nation`?,`Nations.customers.CALCULATE(r=RANKING(by=acctbal.DESC(), per="Nations"))`
How do you find the most recent order for each customer, allowing for ties?,`Customers.orders.WHERE(RANKING(by=order_date.DESC(), per="Customers", allow_ties=True) == 1)`
What is the syntax for the `PERCENTILE` function?,`PERCENTILE(by=expression.ASC()/DESC(), n_buckets=100, per="name_ancestor")`
How do you filter `Customers` to keep only those in the top 0.1% of `acctbal` (highest balances)?,`Customers.WHERE(PERCENTILE(by=acctbal.ASC(), n_buckets=1000) == 1000)`
How do you filter customers within each `Region` to find those in the top 5% of `acctbal`?,`Regions.nations.customers.WHERE(PERCENTILE(by=acctbal.ASC(), per="Regions") > 95)`
What does the `RELSUM(expression, per=...)` function calculate?,It calculates the sum of the `expression` across multiple rows, either globally (if `per` is omitted) or per ancestor group (if `per` is specified).
How do you calculate the ratio of each customer's `acctbal` to the sum of `acctbal` across all customers in the same `Nations`?,`Nations.customers.CALCULATE(ratio=acctbal / RELSUM(acctbal, per="Nations"))`
What does the `RELAVG(expression, per=...)` function calculate?,It calculates the average of the `expression` across multiple rows, either globally or per ancestor group specified by `per`.
How do you find all customers whose `acctbal` is above the average `acctbal` for their specific `Nations`?,`Nations.customers.WHERE(acctbal > RELAVG(acctbal, per="Nations"))`
What does the `RELCOUNT(expression, per=...)` function calculate?,It counts the number of non-null results of the `expression` across multiple rows, either globally or per ancestor group specified by `per`.
How do you calculate the ratio of a customer's `acctbal` to the number of positive account balances within their `Nations`?,`Nations.customers.CALCULATE(ratio = acctbal / RELCOUNT(KEEP_IF(acctbal, acctbal > 0.0), per="Nations"))`
What does the `RELSIZE(per=...)` function calculate?,It returns the total number of rows, either globally or per ancestor group specified by `per`.
How do you calculate the ratio of a customer's `acctbal` to the total number of customers within their `Nations`?,`Nations.customers.CALCULATE(ratio = acctbal / RELSIZE(per="Nations"))`
What is a contextless expression in PyDough?,A reusable code snippet, often assigned to a variable, like a predefined filter condition.
What is the purpose of the `SINGULAR` function?,To explicitly assert that a collection or expression result should be treated as having only one record within its current context, preventing errors when accessing singular fields.
Is `Addresses.CALCULATE(package_id=current_occupants.WHERE(first_name == "John").SINGULAR().packages.package_id)` likely valid according to the cheat sheet? Why or why not?,Likely invalid. 1) Multiple occupants named "John" might exist per address, making `.SINGULAR()` conceptually wrong. 2) `packages` is plural relative to `current_occupants`, so accessing `.package_id` directly violates singularity rules even if the first part worked.
What are the arithmetic operators available in PyDough?,`+`, `-`, `*`, `/`, `**` (exponentiation)
What are the comparison operators available?,`<=`, `<`, `==`, `!=`, `>`, `>=`
What are the logical operators available?,`&` (AND), `|` (OR), `~` (NOT)
What is the unary negation operator?,`-` (flips the sign)
What is the syntax for slicing a string?,`string[start:stop:step]`
What are the limitations on slicing parameters (`start`, `stop`, `step`)?,`step` must be 1 or omitted. `start`/`stop` must be non-negative or omitted.
How do you convert a string `s` to lowercase?,`LOWER(s)`
How do you convert a string `s` to uppercase?,`UPPER(s)`
How do you get the length of a string `s`?,`LENGTH(s)`
How do you check if a string `s` starts with "prefix"?,`STARTSWITH(s, "prefix")`
How do you check if a string `s` ends with "suffix"?,`ENDSWITH(s, "suffix")`
How do you check if a string `s` contains "substring"?,`CONTAINS(s, "substring")`
How do you perform SQL-like pattern matching on string `s` with pattern `p`?,`LIKE(s, p)` (using % and _)
How do you join strings "A", "B", "C" with a hyphen delimiter?,`JOIN_STRINGS("-", "A", "B", "C")`
How do you extract the year from a datetime field `dt`?,`YEAR(dt)`
How do you extract the month (1-12) from `dt`?,`MONTH(dt)`
How do you extract the day (1-31) from `dt`?,`DAY(dt)`
How do you extract the hour (0-23) from `dt`?,`HOUR(dt)`
How do you extract the minute (0-59) from `dt`?,`MINUTE(dt)`
How do you extract the second (0-59) from `dt`?,`SECOND(dt)`
How do you get the current timestamp using the `DATETIME` function?,`DATETIME('now')` (or 'current_timestamp', etc.)
How do you get the start of the current month using `DATETIME`?,`DATETIME('now', 'start of month')`
How do you calculate the date that is 5 days after the `order_date` for each order?,`Orders.CALCULATE(plus_5_days=DATETIME(order_date, '+ 5 days'))`
How do you calculate the number of full days between `date1` and `date2`?,`DATEDIFF("days", date1, date2)`
Which units can be used in `DATEDIFF`?,`"years"`, `"months"`, `"days"`, `"hours"`, `"minutes"`, `"seconds"`
What does the `IFF(condition, value_if_true, value_if_false)` function do?,It returns `value_if_true` if `condition` is true, otherwise it returns `value_if_false`.
How do you check if a value `val` is present in the tuple `(x, y, z)`?,`ISIN(val, (x, y, z))`
What does `DEFAULT_TO(a, b)` return?,It returns `a` if `a` is not null, otherwise it returns `b`.
What does `KEEP_IF(value, condition)` return?,It returns `value` if `condition` is true, otherwise it returns null.
What does `MONOTONIC(a, b, c)` check?,It checks if `a <= b <= c` is true.
How do you get the absolute value of `x`?,`ABS(x)`
How do you round `x` to 2 decimal places?,`ROUND(x, 2)`
How do you calculate `x` raised to the power of `y`?,`POWER(x, y)`
How do you calculate the square root of `x`?,`SQRT(x)`
Find nations whose names start with 'A'. Use `STARTSWITH`.,`nations.CALCULATE(n_name=name).WHERE(STARTSWITH(n_name, 'A'))`
Find nations whose names start with 'A'. Use `LIKE`.,`nations.CALCULATE(n_name=name).WHERE(LIKE(n_name, 'A%'))`
Identify customers in the 'AMERICA' region (but not 'BRAZIL') with negative account balance and at least 5 orders.,`customers.WHERE((acctbal < 0) & (COUNT(orders) >= 5) & (nation.region.name == "AMERICA") & (nation.name != "BRAZIL"))`
Count the number of orders placed in 1998 for each customer and sort by the count descending.,`customers.WHERE(HAS(orders)==1).CALCULATE(key=key, name=name, num_orders=COUNT(orders.WHERE(YEAR(order_date) == 1998))).ORDER_BY(num_orders.DESC())`
Find customers in the 'ASIA' region whose total spending (sum of `orders.total_price`) is greater than $1000.,`customers.WHERE(HAS(orders)==1 & nation.region.name == "ASIA").CALCULATE(customer_key=key, customer_name=name, total_spent=SUM(orders.total_price)).WHERE(total_spent > 1000)`
Identify the top 5 nations with the highest total revenue (sum of `customers.orders.total_price`).,`nations.WHERE(HAS(customers.orders)==1).CALCULATE(nation_name=name, Total_revenue=SUM(customers.orders.total_price)).TOP_K(5, by=Total_revenue.DESC())`
Find customers who have never placed any orders.,`customers.WHERE(HASNOT(orders)==1).CALCULATE(customer_key=key, customer_name=name)`
For each nation, calculate the total number of customers, the number of active customers (at least one order), and inactive customers (no orders). Sort by total customers descending.,`cust_info = customers.CALCULATE(is_active=HAS(orders)==1); nations.CALCULATE(nation_name=name, total_customers=COUNT(cust_info), active_customers=SUM(IFF(cust_info.is_active==True, 1, 0)), inactive_customers=SUM(IFF(cust_info.is_active==False, 1, 0))).ORDER_BY(total_customers.DESC())`
Find customers who are in the top 10% based on `acctbal` (highest balance) but in the bottom 25% based on the number of orders (lowest count).,`customers.WHERE((PERCENTILE(by=acctbal.ASC(), n_buckets=10) == 10) & (PERCENTILE(by=COUNT(orders).ASC(), n_buckets=4) == 1))`
How would you get the name of the nation for each customer?,`customers.CALCULATE(cust_name=name, nation_name=nation.name)`
Calculate the total quantity sold for each part market segment in 1998. Requires navigating lines -> order -> customer -> mktsegment and lines -> part -> name.,`lines_1998_info = lines.WHERE(YEAR(order.order_date) == 1998).CALCULATE(mktsegment=order.customer.mktsegment, part_name=part.name, quantity=quantity); part_totals_per_segment = lines_1998_info.PARTITION(name="part_segment_groups", by=(mktsegment, part_name)).CALCULATE(mktsegment=mktsegment, part_name=part_name, total_quantity = SUM(lines.quantity))`
Find all unique states present in the `Addresses` collection.,`Addresses.PARTITION(name="states", by=state).CALCULATE(state)`
For every city/state combination in `Addresses`, count how many people (`current_occupants`) live there.,`Addresses.PARTITION(name="cities", by=(city, state)).CALCULATE(state, city, n_people=COUNT(Addresses.current_occupants))`
Find the top 5 years with the most people born in that year who have "@yahoo.com" email accounts.,`yahoo_people = People.CALCULATE(birth_year=YEAR(birth_date)).WHERE(ENDSWITH(email, "@yahoo.com")); yahoo_people.PARTITION(name="years", by=birth_year).CALCULATE(birth_year, n_people=COUNT(People)).TOP_K(5, by=n_people.DESC())`
Identify states whose current occupants account for at least 1% of all packages purchased globally.,`GRAPH.CALCULATE(total_packages=COUNT(Packages)).Addresses.WHERE(HAS(current_occupants.packages)==1).PARTITION(name="states", by=state).CALCULATE(state, pct_of_packages=100.0 * COUNT(Addresses.current_occupants.packages) / total_packages).WHERE(pct_of_packages >= 1.0)`
Identify the months of the year (1-12) that have a number of packages shipped greater than the average number of packages shipped per month across all months.,`pack_info = Packages.CALCULATE(order_month=MONTH(order_date)); month_info = pack_info.PARTITION(name="months", by=order_month).CALCULATE(order_month, n_packages=COUNT(Packages)); GRAPH.CALCULATE(avg_packages_per_month=AVG(month_info.n_packages)).month_info.WHERE(n_packages > avg_packages_per_month).CALCULATE(order_month)`
Find the 10 most frequent combinations of state (from `Addresses`) and the first letter of the `current_occupants`' first name.,`people_info = Addresses.WHERE(HAS(current_occupants)==1).CALCULATE(state=state).current_occupants.CALCULATE(first_letter=first_name[:1]); people_info.PARTITION(name="combinations", by=(state, first_letter)).CALCULATE(state, first_letter, n_people=COUNT(current_occupants)).TOP_K(10, by=n_people.DESC())`
Rewrite the previous query (state/first letter combinations) to include people without a current address (state as "N/A").,`people_info = People.CALCULATE(state=DEFAULT_TO(current_address.state, "N/A"), first_letter=first_name[:1]); people_info.PARTITION(name="state_letter_combos", by=(state, first_letter)).CALCULATE(state, first_letter, n_people=COUNT(People)).TOP_K(10, by=n_people.DESC())`
Partition current occupants by birth year. Filter to keep only years with >= 10000 births. For people in those years, list first name, last name, and state.,`people_info = Addresses.WHERE(HAS(current_occupants)==1).CALCULATE(state=state).current_occupants.CALCULATE(birth_year=YEAR(birth_date)); people_info.PARTITION(name="years", by=birth_year).WHERE(COUNT(current_occupants) >= 10000).current_occupants.CALCULATE(first_name, last_name, state)`
Find packages ordered in the last year present in the database, whose cost was below the global average package cost, and shipped to a state that received at least 10,000 packages *that specific year*.,`GRAPH.CALCULATE(avg_cost=AVG(Packages.package_cost), final_year=MAX(YEAR(Packages.order_date))).Packages.CALCULATE(order_year=YEAR(order_date), shipping_state=shipping_address.state).WHERE(order_year == final_year).PARTITION(name="states", by=shipping_state).WHERE(COUNT(Packages) > 10000).Packages.WHERE(package_cost < avg_cost).CALCULATE(shipping_state, package_id, order_date)`
For each state, find the largest number of packages shipped to a single city within that state.,`pack_info = Packages.CALCULATE(city=shipping_address.city, state=shipping_address.state); city_groups = pack_info.PARTITION(name="cities", by=(city, state)).CALCULATE(city, state, n_packages=COUNT(Packages)); city_groups.PARTITION(name="states", by=state).CALCULATE(state, max_packs=MAX(cities.n_packages))`
Why is partitioning by `current_address.state` directly (e.g., `People.PARTITION(by=current_address.state)`) invalid?,Partition keys must be scalar fields accessible directly from the collection being partitioned. You need to calculate the state first: `People.CALCULATE(state=current_address.state).PARTITION(by=state)`.
When accessing data after a `PARTITION` named `combinations` created from `people_info` (derived from `current_occupants`), what name should be used to count records within each partition: `COUNT(Addresses)`, `COUNT(current_occupants)`, or `COUNT(people_info)`?,Use the name of the collection immediately before the partition, which was `people_info` in this case, or the original source collection if appropriate (`current_occupants`). Accessing using an ancestor like `Addresses` is incorrect (Bad Example #9).
Can you aggregate data inside an aggregation function, like `AVG(SUM(lines.quantity))`?,No. Aggregation functions cannot be nested. You would typically calculate the inner sum first (possibly per group) and then average that result.
Write the code to get the first 3 characters of the customer's phone number.,`customers.CALCULATE(country_code = phone[:3])`
How do you calculate the value of line items considering a squared discount and adding a base value before dividing by retail price?,`Lineitems.CALCULATE(value = (extended_price * (1 - POWER(discount, 2)) + 1.0) / part.retail_price)`
Filter customers to find those who are either in 'ASIA' or 'EUROPE' regions.,`Customers.WHERE((nation.region.name == "ASIA") | (nation.region.name == "EUROPE"))`
Calculate the 'lost value' for line items, represented as the negative product of extended price and discount.,`Lineitems.CALCULATE(lost_value = extended_price * (-discount))`
Filter parts where the size is between 5 and 10 (inclusive) using `MONOTONIC`.,`Parts.WHERE(MONOTONIC(5, size, 10))`
Filter parts where the size is either 10 or 11 using `ISIN`.,`Parts.WHERE(ISIN(size, (10, 11)))`
Calculate the tax amount, defaulting to 0 if the `tax` field is null.,`CALCULATE(tax_amount = DEFAULT_TO(tax, 0.0))`
Calculate the account balance, but only keep it if it's positive (otherwise, it should be null).,`CALCULATE(positive_balance = KEEP_IF(acctbal, acctbal > 0))`
Round the `total_price` of orders to the nearest integer.,`Orders.CALCULATE(rounded_price = ROUND(total_price, 0))`
Calculate the square root of the `quantity` for each line item.,`Lineitems.CALCULATE(sqrt_quantity = SQRT(quantity))`
Combine the `name` and `comment` of nations into a single string separated by " -- ".,`nations.CALCULATE(combined = JOIN_STRINGS(" -- ", name, comment))`
Filter orders placed on the 1st day of any month.,`Orders.WHERE(DAY(order_date) == 1)`
Filter orders placed in the second half of the year (July onwards).,`Orders.WHERE(MONTH(order_date) >= 7)`
Calculate the date corresponding to the start of the year for each `order_date`.,`Orders.CALCULATE(order_year_start = DATETIME(order_date, 'start of year'))`
Calculate the number of months between `ship_date` and `receipt_date` for each line item.,`Lineitems.CALCULATE(shipping_duration_months = DATEDIFF("months", ship_date, receipt_date))`
Find all suppliers who supply parts.,`suppliers.WHERE(HAS(parts)==1)`
Count the number of distinct regions represented by the nations.,`NDISTINCT(nations.region.name)`
Calculate the average account balance for customers in the 'AFRICA' region.,`regions.WHERE(name=='AFRICA').nations.customers.CALCULATE(avg_bal=AVG(acctbal))` This assumes calculation context. A better way: `customers.WHERE(nation.region.name == 'AFRICA').CALCULATE(avg_bal=AVG(acctbal))` (But this gives one value). To get the single value: `GRAPH.CALCULATE(avg_african_bal=AVG(customers.WHERE(nation.region.name == 'AFRICA').acctbal))`
Find the minimum order date among all orders.,`GRAPH.CALCULATE(min_order_date=MIN(orders.order_date))`
Find the maximum price (`retail_price`) among all parts.,`GRAPH.CALCULATE(max_retail_price=MAX(parts.retail_price))`
Select the `part_key` and `name` for parts whose name contains the word 'tin' (case-insensitive).,`parts.CALCULATE(part_key=key, name=name).WHERE(CONTAINS(LOWER(name), 'tin'))`
Select the `supplier_key` and `name` for suppliers whose name ends with 'Ltd.'.,`suppliers.CALCULATE(supplier_key=key, name=name).WHERE(ENDSWITH(name, 'Ltd.'))`
Get the length of the comment for each region.,`regions.CALCULATE(region_name=name, comment_length=LENGTH(comment))`
Generate a derived field `order_priority_level` which is 'HIGH' if `order_priority` starts with '1', 'MEDIUM' if it starts with '2', and 'LOW' otherwise.,`orders.CALCULATE(order_priority_level = IFF(STARTSWITH(order_priority, '1'), 'HIGH', IFF(STARTSWITH(order_priority, '2'), 'MEDIUM', 'LOW')))`
Check if any nation has a comment longer than 150 characters.,`GRAPH.CALCULATE(long_comment_exists = HAS(nations.WHERE(LENGTH(comment)>150)) == 1)` Note: `HAS` operates on collections.
Calculate the absolute difference between `supply_cost` and `retail_price` for each part.,`parts.CALCULATE(price_diff = ABS(supply_cost - retail_price))`
For each year/priority combination, calculate its percentage of total orders for that year, then find the priority with the highest percentage for each year.,`order_info = orders.CALCULATE(year=YEAR(order_date), priority=order_priority); year_priority_counts = order_info.PARTITION(name="yp", by=(year, priority)).CALCULATE(year=year, priority=priority, n_orders=COUNT(orders)); year_priority_percentages = year_priority_counts.PARTITION(name="year_group", by=year).yp.CALCULATE(year=year, highest_priority=priority, priority_pct=100.0 * n_orders / RELSUM(n_orders, per="year_group")).WHERE(RANKING(by=priority_pct.DESC(), per="year_group") == 1).ORDER_BY(year.ASC())`
Group `DailyPrices` by ticker symbol and month. Calculate avg closing, max high, and min low price for each group.,`price_info = DailyPrices.CALCULATE(month=JOIN_STRINGS("-", YEAR(date), LPAD(MONTH(date), 2, "0")), symbol=ticker.symbol); ticker_months = price_info.PARTITION(name="months", by=(symbol, month)); month_stats = ticker_months.CALCULATE(symbol=symbol, month=month, avg_close=AVG(DailyPrices.close), max_high=MAX(DailyPrices.high), min_low=MIN(DailyPrices.low)); result = month_stats.CALCULATE(symbol, month, avg_close, max_high, min_low)` Note: Accessing DailyPrices within Calculate after Partition requires care. Correct approach might be: `month_stats = ticker_months.CALCULATE(symbol=symbol, month=month, avg_close=AVG(months.DailyPrices.close), max_high=MAX(months.DailyPrices.high), min_low=MIN(months.DailyPrices.low))` Check context rules carefully. The provided example seems okay.
Count how many part sizes have an above-average number of unique combinations of (part type, container).,`combo_groups = Parts.PARTITION(name="groups", by=(size, type, container)); size_groups = combo_groups.PARTITION(name="sizes", by=size).CALCULATE(size=size, n_combos=COUNT(groups)); GRAPH.CALCULATE(avg_n_combo=AVG(size_groups.n_combos)).size_groups.WHERE(n_combos > avg_n_combo).CALCULATE(count_above_avg = COUNT(size))` Note: Final calculation simplified to get the count.
Identify transactions below the average share count for their (customer, stock, type), AND below avg for (customer, stock), AND below avg for (customer).,`ctt_groups = Transactions.PARTITION(name="ctt", by=(customer_id, ticker_id, transaction_type)).CALCULATE(cus_tick_typ_avg_shares=AVG(Transactions.shares)); ct_groups = ctt_groups.PARTITION(name="ct", by=(customer_id, ticker_id)).CALCULATE(cust_tick_avg_shares=AVG(ctt.Transactions.shares)); c_groups = ct_groups.PARTITION(name="c", by=customer_id).CALCULATE(cust_avg_shares=AVG(ct.ctt.Transactions.shares)); c_groups.ct.ctt.Transactions.WHERE((shares < cus_tick_typ_avg_shares) & (shares < cust_tick_avg_shares) & (shares < cust_avg_shares)).CALCULATE(transaction_id, customer.name, ticker.symbol, transaction_type, shares, cus_tick_typ_avg_shares, cust_tick_avg_shares, cust_avg_shares).ORDER_BY(transaction_id.ASC())`
What general principle should guide writing complex PyDough queries regarding hierarchy and composition?,Combine filters, transformations, and aggregations hierarchically at the appropriate level. Avoid unnecessary intermediate steps or partitioning. Leverage `CALCULATE` for direct aggregations and `WHERE` for filtering at the correct scope.
If a query asks for the total value for "each year" without specifying which years, what must the PyDough code do?,It must calculate the value for each year present in the data (1995, 1996, 1997, 1998) and likely use `SINGULAR` to present each year's result distinctly.
Can you use `nation.name` directly in the `by` clause of a `PARTITION` on the `customers` collection?,Yes, if `nation.name` is a singular, scalar field accessible from `customers`. `by=(nation.name)` would be valid. *Correction based on examples*: It's better/required to calculate first: `customers.CALCULATE(nation_name=nation.name).PARTITION(by=nation_name)`.
Find the number of orders for every nation that has customers with orders.,`nations.WHERE(HAS(customers.orders)==1).CALCULATE(nation_name=name, num_of_orders=COUNT(customers.orders))`
Select the first name and last name of all people.,`People.CALCULATE(first_name=first_name, last_name=last_name)`
Calculate the cost per unit for packages (`package_cost / quantity`).,`Packages.CALCULATE(cost_per_unit=package_cost / quantity)`
Find addresses that do *not* have any current occupants.,`Addresses.WHERE(HASNOT(current_occupants)==1)`
Get the top 3 suppliers based on the sum of their line item extended prices (descending).,`suppliers.WHERE(HAS(lines)==1).CALCULATE(supplier_name=name, total_sales=SUM(lines.extended_price)).TOP_K(3, by=total_sales.DESC())` *Self-correction*: `TOP_K` needs expression, calculation must be separate or integrated if possible. Better: `suppliers.TOP_K(3, by=SUM(lines.extended_price).DESC()).CALCULATE(supplier_name=name, total_sales=SUM(lines.extended_price))` (Requires check if `total_sales` can be recalculated or needs pre-calculation). Let's try the example style: `suppliers.CALCULATE(supplier_name=name, total_sales=SUM(lines.extended_price)).TOP_K(3, by=total_sales.DESC())` This assumes total_sales is available for TOP_K. The rule "TOP_K ... must ALWAYS provide an expression" suggests `by=SUM(lines.extended_price).DESC()` is the correct part for `TOP_K`. The example `customers.CALCULATE(cust_name=name).TOP_K(10, by=COUNT(orders).DESC())` shows pre-calculation of selected fields, then TOP_K. Final Answer: `suppliers.CALCULATE(supplier_name=name).TOP_K(3, by=SUM(lines.extended_price).DESC())`
Group packages by the year and month of their `order_date`.,`package_info = Packages.CALCULATE(order_year=YEAR(order_date), order_month=MONTH(order_date)); package_info.PARTITION(name='packs', by=(order_year, order_month))`
For each year/month group of packages, find packages with a cost below the average cost for that specific year/month.,`package_info = Packages.CALCULATE(order_year=YEAR(order_date), order_month=MONTH(order_date)); package_info.PARTITION(name="months", by=(order_year, order_month)).CALCULATE(order_year, order_month, avg_package_cost=AVG(Packages.package_cost)).Packages.WHERE(package_cost < avg_package_cost)`
For each city/state, calculate the percentage of total packages (ordered by occupants of that city/state) that each occupant ordered.,`Addresses.WHERE(HAS(current_occupants.packages)==1).PARTITION(name="cities", by=(city, state)).CALCULATE(city=city, state=state, total_packages=COUNT(Addresses.current_occupants.packages)).Addresses.current_occupants.CALCULATE(first_name, last_name, city=city, state=state, pct_of_packages=100.0 * COUNT(packages) / total_packages)` Note slight adjustment needed based on example structure, ensuring city/state are available. Corrected: `Addresses.WHERE(HAS(current_occupants.packages)==1).PARTITION(name="cities", by=(city, state)).CALCULATE(total_packages=COUNT(Addresses.current_occupants.packages)).Addresses.CALCULATE(city=city, state=state).current_occupants.CALCULATE(first_name, last_name, city=city, state=state, pct_of_packages=100.0 * COUNT(packages) / total_packages)`
Rank every customer globally by their account balance (descending).,`customers.CALCULATE(rank=RANKING(by=acctbal.DESC()))`
Rank every customer by their account balance (descending) relative to other customers in the same Region.,`Regions.nations.customers.CALCULATE(rank=RANKING(by=acctbal.DESC(), per="Regions"))`
Calculate the ratio between each customer's account balance and the global sum of all customer account balances.,`Customers.CALCULATE(ratio=acctbal / RELSUM(acctbal))`
Find all customers whose account balance is above the global average customer account balance.,`Customers.WHERE(acctbal > RELAVG(acctbal))`
Calculate, for each order, the number of days since January 1st, 1992.,`Orders.CALCULATE(days_since=DATEDIFF("days", DATETIME('1992-01-01'), order_date))` Note: Date construction syntax might vary, assume standard ISO date works. Cheat sheet example uses `datetime.date(1992, 1, 1)`. Use that: `Orders.CALCULATE(days_since=DATEDIFF("days", datetime.date(1992, 1, 1), order_date))`
Truncate each order's `order_date` to the first day of its year.,`Orders.CALCULATE(order_year_start=DATETIME(order_date, 'START OF Y'))`
Find customers whose nation's name is either 'CANADA' or 'USA'.,`customers.WHERE(ISIN(nation.name, ('CANADA', 'USA')))`
Create a field `discount_category` for line items: 'High' if discount > 0.07, 'Low' if discount < 0.03, 'Mid' otherwise.,`lineitems.CALCULATE(discount_category = IFF(discount > 0.07, 'High', IFF(discount < 0.03, 'Low', 'Mid')))`
Get the name of the region for each supplier.,`suppliers.CALCULATE(supplier_name=name, region_name=nation.region.name)`
Count the number of suppliers in each region.,`regions.CALCULATE(region_name=name, supplier_count=COUNT(nations.suppliers))`
Find the supplier with the highest account balance.,`suppliers.TOP_K(1, by=acctbal.DESC()).CALCULATE(supplier_name=name, balance=acctbal)`
Calculate the total value (extended_price * (1 - discount)) for each line item.,`lines.CALCULATE(line_value = extended_price * (1 - discount))`
Calculate the total order value for all orders placed in 1996.,`GRAPH.CALCULATE(total_1996_value = SUM(orders.WHERE(YEAR(order_date)==1996).CALCULATE(value=extended_price*(1-discount)).value))` *Correction*: Need to use pre-calculated total_price if available or calculate line value sum. Assuming `total_price` exists on orders: `GRAPH.CALCULATE(total_1996_value = SUM(orders.WHERE(YEAR(order_date)==1996).total_price))`
Find the average quantity per part.,`parts.WHERE(HAS(lines)==1).CALCULATE(part_key=key, avg_quantity=AVG(lines.quantity))` *Correction*: AVG is aggregation. Global average: `GRAPH.CALCULATE(avg_part_quantity=AVG(parts.lines.quantity))` Average per part: Previous answer is correct structure.
Get the name and phone number of customers whose phone number starts with '25-'.,`customers.CALCULATE(name=name, phone=phone).WHERE(STARTSWITH(phone, '25-'))`
List nations that have at least 10 customers.,`nations.WHERE(COUNT(customers) >= 10).CALCULATE(nation_name=name)`
Find the orderkey and total price for orders placed on or after Jan 1, 1998.,`orders.WHERE(order_date >= DATETIME('1998-01-01')).CALCULATE(order_key=key, total_price=total_price)` Use example format: `orders.WHERE(order_date >= datetime.date(1998, 1, 1)).CALCULATE(order_key=key, total_price=total_price)`
Determine if all customers have a positive account balance.,`GRAPH.CALCULATE(all_positive = HASNOT(customers.WHERE(acctbal <= 0)) == 1)` Alternative: `GRAPH.CALCULATE(min_balance=MIN(customers.acctbal)).CALCULATE(all_positive = min_balance > 0)`
Calculate the age of each customer in years as of today (assuming 'now' gives date). DATEDIFF needed.,`People.CALCULATE(age=DATEDIFF("years", birth_date, DATETIME('now')))`
Find parts where the retail price is more than double the supply cost.,`parts.WHERE(retail_price > (2 * supply_cost))`
List the distinct market segments of customers.,`customers.PARTITION(name="segments", by=mktsegment).CALCULATE(mktsegment)`
Find the rank of each part within its container based on retail price (highest price = rank 1).,`Parts.CALCULATE(rank_in_container=RANKING(by=retail_price.DESC(), per="container"))` *Correction*: `per` needs an ancestor name or omit for global. Assuming partitioning first: `Parts.PARTITION(name="cont", by=container).Parts.CALCULATE(part_key=key, rank_in_container=RANKING(by=retail_price.DESC(), per="cont"))`
Calculate the percentage of the total quantity for each line item relative to its order's total quantity.,`orders.lines.CALCULATE(qty_pct = quantity / RELSUM(quantity, per="orders"))`
Find line items shipped more than 30 days after the order date.,`lines.WHERE(DATEDIFF("days", order.order_date, ship_date) > 30)`
Get the customer name and the number of orders they placed, for customers with more than 20 orders.,`customers.CALCULATE(name=name, order_count=COUNT(orders)).WHERE(order_count > 20)`
Calculate the running total of `total_price` for orders, ordered by `order_date`. (Requires window function not explicitly shown, but conceptually relates to RELSUM/RANKING).,PyDough cheat sheet does not explicitly show a standard `RUNNING_TOTAL` or `CUME_SUM` window function. Could be simulated with complex self-joins or UDFs, but not directly from provided functions. Closest might involve ranking and summing up to rank, but cumbersome. Answer: Not directly supported by shown functions.
Find the most common (mode) `order_priority`.,`orders.PARTITION(name="prios", by=order_priority).CALCULATE(priority=order_priority, count=COUNT(orders)).TOP_K(1, by=count.DESC()).CALCULATE(priority)`
Calculate the difference between the max and min `acctbal` for customers in each nation.,`nations.CALCULATE(nation_name=name, balance_range=MAX(customers.acctbal) - MIN(customers.acctbal))` Requires customers exist: `nations.WHERE(HAS(customers)==1).CALCULATE(...)`
Find suppliers who supply parts of type 'ECONOMY ANODIZED STEEL'.,`suppliers.WHERE(HAS(parts.WHERE(type == 'ECONOMY ANODIZED STEEL')) == 1)`