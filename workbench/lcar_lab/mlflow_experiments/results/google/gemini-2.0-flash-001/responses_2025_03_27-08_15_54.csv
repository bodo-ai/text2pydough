question,sql,similar_queries,response,extracted_python_code
List the total number of customers and suppliers in each nation. Order by nation name,"SELECT n_name AS nation_name, COUNT(DISTINCT c_custkey) AS total_customers, COUNT(DISTINCT s_suppkey) AS total_suppliers FROM nation LEFT JOIN customer ON n_nationkey = c_nationkey LEFT JOIN supplier ON n_nationkey = s_nationkey GROUP BY n_name;","1. Count customers and suppliers by region:

# Count customers and suppliers by region
nation_counts = regions.CALCULATE(
    region_name=name,
    n_customers=COUNT(nations.customers),
    n_suppliers=COUNT(nations.suppliers)
)","1.  We need to access the `nations` collection.
2.  For each nation, we need to count the number of customers and suppliers.
3.  We need to order the results by nation name.

Here's the PyDough code:

```python
nation_counts = nations.CALCULATE(
    nation_name=name,
    n_customers=COUNT(customers),
    n_suppliers=COUNT(suppliers)
).ORDER_BY(nation_name.ASC())
```
","nation_counts = nations.CALCULATE(
    nation_name=name,
    n_customers=COUNT(customers),
    n_suppliers=COUNT(suppliers)
).ORDER_BY(nation_name.ASC())"
Find the top 5 nations with the highest number of orders placed by their customers in 1995.,"SELECT n_name AS nation_name, COUNT(o_orderkey) AS total_orders FROM nation JOIN customer ON n_nationkey = c_nationkey JOIN orders ON c_custkey = o_custkey WHERE o_orderdate >= '1995-01-01' AND o_orderdate <= '1995-12-31' GROUP BY n_name ORDER BY total_orders DESC LIMIT 5;","1. Top 5 nations by average order value in 1995:

orders_in_1995= customers.orders.WHERE(YEAR(order_date) == 1995)

top_5_nations = nations.CALCULATE(
    nation_name=name,
    average_orders= AVG(orders_in_1995), 
    order_count=COUNT(orders_in_1995)
).TOP_K(5, by=average_orders.DESC())","Okay, let's break this down.

1.  We need to consider orders placed in 1995.
2.  We need to associate these orders with the customers who placed them.
3.  We need to associate the customers with their respective nations.
4.  We need to count the number of orders per nation.
5.  Finally, we need to find the top 5 nations based on this count.

Here's the PyDough code:

```python
orders_1995 = orders.WHERE(YEAR(order_date) == 1995)

nation_order_counts = nations.CALCULATE(
    nation_name=name,
    order_count=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))
).TOP_K(5, by=order_count.DESC())
```
","orders_1995 = orders.WHERE(YEAR(order_date) == 1995)

nation_order_counts = nations.CALCULATE(
    nation_name=name,
    order_count=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))
).TOP_K(5, by=order_count.DESC())"
"Find the region name with the highest total order value in 1996. The total order value is defined as potential revenue, defined as the sum of extended_price * (1 - discount)","SELECT r_name AS region_name, SUM(l_extendedprice * (1 - l_discount)) AS total_order_value FROM region JOIN nation ON r_regionkey = n_regionkey JOIN customer ON n_nationkey = c_nationkey JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey WHERE o_orderdate >= '1996-01-01' AND o_orderdate <= '1996-12-31' GROUP BY r_name ORDER BY total_order_value DESC LIMIT 1;",,"Here's how we can approach this problem:

1.  We need to calculate the potential revenue for each line item.
2.  We need to filter orders placed in 1996.
3.  We need to sum the potential revenue for each order.
4.  We need to associate each order with its customer and then with the customer's nation and region.
5.  We need to group by region and sum the total potential revenue.
6.  Finally, we need to find the region with the highest total potential revenue.

Here's the PyDough code:

```python
region_order_values_1996 = regions.CALCULATE(
    region_name=name,
    total_order_value=SUM(nations.customers.orders.WHERE(YEAR(order_date) == 1996).lines.CALCULATE(potential_revenue = extended_price * (1 - discount)).potential_revenue)
).TOP_K(1, by=total_order_value.DESC())
```","region_order_values_1996 = regions.CALCULATE(
    region_name=name,
    total_order_value=SUM(nations.customers.orders.WHERE(YEAR(order_date) == 1996).lines.CALCULATE(potential_revenue = extended_price * (1 - discount)).potential_revenue)
).TOP_K(1, by=total_order_value.DESC())"
Find the top 3 regions with the most distinct customers,"SELECT r_name AS region_name, COUNT(DISTINCT c_custkey) AS distinct_customers FROM region JOIN nation ON r_regionkey = n_regionkey JOIN customer ON n_nationkey = c_nationkey GROUP BY r_name ORDER BY distinct_customers DESC LIMIT 3;","1. Find the top 10 with the most distinct suppliers

top_regions = regions.CALCULATE(
    region_name=name,
    suppliers_count=NDISTINCT(nations.suppliers.key))
).TOP_K(10, by=customer_count.DESC())""
","1.  We need to start with the `regions` collection.
2.  For each region, we need to count the distinct number of customers. Since customers are accessed through the `nations` collection, we will use `NDISTINCT(nations.customers.key)` to count the distinct customer keys.
3.  We will use `CALCULATE` to create a new field `customer_count` that stores the result of the distinct count.
4.  Finally, we will use `TOP_K` to select the top 3 regions based on the `customer_count` in descending order.

```python
top_regions = regions.CALCULATE(
    region_name=name,
    customer_count=NDISTINCT(nations.customers.key)
).TOP_K(3, by=customer_count.DESC())
```","top_regions = regions.CALCULATE(
    region_name=name,
    customer_count=NDISTINCT(nations.customers.key)
).TOP_K(3, by=customer_count.DESC())"
Find the names of all customers and number of orders placed in 1995 in Europe who have an account balance greater than $700 and placed at least one order in 1995. Sorted in descending order by the number of orders.,"SELECT c.c_name AS customer_name, COUNT(o.o_orderkey) AS order_count_1995 FROM customer c JOIN nation n ON c.c_nationkey = n.n_nationkey JOIN region r ON n.n_regionkey = r.r_regionkey JOIN orders o ON c.c_custkey = o.o_custkey WHERE r.r_name = 'EUROPE' AND c.c_acctbal > 700 AND o.o_orderdate BETWEEN '1995-01-01' AND '1995-12-31' GROUP BY c.c_name, c.c_acctbal ORDER BY order_count_1995 DESC, c.c_acctbal DESC;",,"Okay, let's break this down into smaller parts.

1.  **Initial Collection**: We need to start with the `customers` collection.
2.  **Filtering**:
    *   Customers in Europe: `nation.region.name == ""EUROPE""`
    *   Account balance greater than $700: `acctbal > 700`
    *   Placed at least one order in 1995: `HAS(orders.WHERE(YEAR(order_date) == 1995))==1`
3.  **Calculation**: We need to calculate the number of orders placed in 1995 for each customer.
4.  **Sorting**: Sort the results in descending order by the number of orders.
5.  **Final Selection**: Select the customer's name and the number of orders.

Here's the PyDough code:

```python
european_customers = customers.WHERE(
    (nation.region.name == ""EUROPE"") & (acctbal > 700) & (HAS(orders.WHERE(YEAR(order_date) == 1995))==1)
).CALCULATE(
    customer_name=name,
    num_orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))
).ORDER_BY(num_orders_1995.DESC())
```","european_customers = customers.WHERE(
    (nation.region.name == ""EUROPE"") & (acctbal > 700) & (HAS(orders.WHERE(YEAR(order_date) == 1995))==1)
).CALCULATE(
    customer_name=name,
    num_orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))
).ORDER_BY(num_orders_1995.DESC())"
"Find suppliers in each nation who have a total availqty of more than 1000 units of parts with 'BRASS' in their type. List the supplier name, nation name, and the sum of the parts supplied.","SELECT s.s_name AS SupplierName, n.n_name AS Nation, SUM(ps.ps_availqty) AS TotalUnitsSupplied FROM supplier s JOIN nation n ON s.s_nationkey = n.n_nationkey JOIN partsupp ps ON s.s_suppkey = ps.ps_suppkey JOIN part p ON ps.ps_partkey = p.p_partkey WHERE p.p_type LIKE '%BRASS%' GROUP BY s.s_name, n.n_name HAVING SUM(ps.ps_availqty) > 1000 ORDER BY TotalUnitsSupplied DESC;",,"Okay, let's break this down into smaller parts.

1.  We need to find suppliers in each nation.
2.  We need to filter parts with 'BRASS' in their type.
3.  We need to calculate the total availqty of these parts for each supplier.
4.  We need to filter suppliers who have a total availqty of more than 1000.
5.  We need to list the supplier name, nation name, and the sum of the parts supplied.

Here's the PyDough code:

```python
supplier_parts = suppliers.CALCULATE(
    supplier_name=name,
    nation_name=nation.name,
    total_availqty=SUM(supply_records.WHERE(CONTAINS(part.part_type, 'BRASS')).availqty)
).WHERE(total_availqty > 1000)
```","supplier_parts = suppliers.CALCULATE(
    supplier_name=name,
    nation_name=nation.name,
    total_availqty=SUM(supply_records.WHERE(CONTAINS(part.part_type, 'BRASS')).availqty)
).WHERE(total_availqty > 1000)"
Find parts names that are supplied by at least five different nations. Show the part name and the count of distinct nations that supply each part,"SELECT p.P_NAME AS PartName, COUNT(DISTINCT n.N_NAME) AS NumberOfNations FROM PART p JOIN PARTSUPP ps ON p.P_PARTKEY = ps.PS_PARTKEY JOIN SUPPLIER s ON ps.PS_SUPPKEY = s.S_SUPPKEY JOIN NATION n ON s.S_NATIONKEY = n.N_NATIONKEY GROUP BY p.P_NAME HAVING COUNT(DISTINCT n.N_NAME) > 5 ORDER BY NumberOfNations DESC;",,"```python
part_nations = PARTITION(parts, name='part_group', by=name).CALCULATE(
    part_name=name,
    num_nations=NDISTINCT(part_group.supply_records.supplier.nation_key)
).WHERE(num_nations >= 5)
```","part_nations = PARTITION(parts, name='part_group', by=name).CALCULATE(
    part_name=name,
    num_nations=NDISTINCT(part_group.supply_records.supplier.nation_key)
).WHERE(num_nations >= 5)"
"Which 10 customers purchased the highest quantity of products with 'green' in the product name during 1998? Provide their names, adress and the total quantity ordered.","SELECT c_name AS customer_name, c_address AS customer_address, SUM(l_quantity) AS total_quantity_ordered FROM customer JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey JOIN part ON l_partkey = p_partkey WHERE p_name LIKE '%green%' AND strftime('%Y', o_orderdate) = '1998' GROUP BY c_name, c_address ORDER BY total_quantity_ordered DESC LIMIT 10;",,"Okay, let's break this down. We need to find the top 10 customers who purchased the highest quantity of products with 'green' in the product name during 1998. Here's how we can approach this:

1. **Filter lines for the year 1998:** We need to consider only the lines associated with orders placed in 1998.
2. **Filter lines for products with 'green' in the name:** We need to filter the lines to include only those where the associated part's name contains 'green'.
3. **Group by customer:** We need to group the filtered lines by customer to calculate the total quantity ordered by each customer.
4. **Calculate total quantity per customer:** For each customer, we need to sum the quantities of the 'green' products ordered in 1998.
5. **Select top 10 customers:** We need to select the top 10 customers based on the total quantity ordered.
6. **Retrieve customer information:** For the top 10 customers, we need to retrieve their names and addresses.

The error message `Unrecognized term of simple table collection 'lines' in graph 'TPCH': 'order_date'` indicates that we are trying to access `order_date` from the `lines` collection, but `order_date` is actually a property of the `orders` collection. We need to access the `order_date` through the `lines.order` relationship.

Here's the corrected PyDough code:

```python
customer_quantities = customers.CALCULATE(
    customer_name=name,
    customer_address=address,
    total_quantity=SUM(orders.lines.WHERE((YEAR(order.order_date) == 1998) & (CONTAINS(part.name, 'green'))).quantity)
).TOP_K(10, by=total_quantity.DESC())
```
","customer_quantities = customers.CALCULATE(
    customer_name=name,
    customer_address=address,
    total_quantity=SUM(orders.lines.WHERE((YEAR(order.order_date) == 1998) & (CONTAINS(part.name, 'green'))).quantity)
).TOP_K(10, by=total_quantity.DESC())"
Which is the average discount applied on orders for each market segment? Sorted in descending order,"SELECT c_mktsegment AS market_segment, AVG(l_discount) AS average_discount FROM customer JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey GROUP BY c_mktsegment;","1. Average shipping delay by supplier:
```python
avg_shipping_delay_by_supplier = suppliers.CALCULATE(
    supplier_name=name,
    average_shipping_delay=AVG(lines.ship_date - lines.commit_date)
)
```
2. Average price by part size:
```python
avg_price_by_part_size = GROUP_BY(
    parts,
    name= ""part"",
 by=(part_size)
).CALCULATE(
 part_size= part_size,
 average_retail_price= AVG(part.retail_price)
)```","Here's how we can approach this:

1.  We need to start with the `customers` collection since we want to group by market segment.
2.  For each customer, we need to access their orders and then the lines within those orders to get the discount.
3.  We need to calculate the average discount for each market segment.
4.  Finally, we need to sort the results in descending order.

Here's the PyDough code:

```python
market_segment_avg_discount = PARTITION(customers, name='custs', by=mktsegment).CALCULATE(
    mktsegment=mktsegment,
    avg_discount=AVG(custs.orders.lines.discount)
).ORDER_BY(avg_discount.DESC())
```
","market_segment_avg_discount = PARTITION(customers, name='custs', by=mktsegment).CALCULATE(
    mktsegment=mktsegment,
    avg_discount=AVG(custs.orders.lines.discount)
).ORDER_BY(avg_discount.DESC())"
What were the 20 most popular products (parts) within each market segment in 1998?,"WITH ProductPopularity AS (SELECT c_mktsegment AS market_segment, p_name AS product_name, SUM(l_quantity) AS total_quantity FROM customer JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey JOIN part ON l_partkey = p_partkey WHERE strftime('%Y', o_orderdate) = '1998' GROUP BY c_mktsegment, p_name) SELECT market_segment, product_name, total_quantity FROM (SELECT market_segment, product_name, total_quantity, ROW_NUMBER() OVER (PARTITION BY market_segment ORDER BY total_quantity DESC) AS rank FROM ProductPopularity) WHERE rank <= 20;",,"```python
# Calculate the year of the order
lines_with_year = lines.CALCULATE(order_year=YEAR(order.order_date))

# Calculate the market segment and filter for the year 1998
customer_data = customers.CALCULATE(cust_mktsegment=mktsegment).orders.WHERE(YEAR(order_date) == 1998)

# Partition by market segment
partitioned_data = PARTITION(customer_data, name='segment_group', by=customer.cust_mktsegment)

# Calculate the product order count and rank within each segment
ranked_products = partitioned_data.segment_group.lines.CALCULATE(
    customer_mktsegment=customer.cust_mktsegment,
    product_order_count=COUNT(part_key),
    product_rank=RANKING(by=COUNT(part_key).DESC(), levels=1)
)

# Filter for the top 20 products per market segment
top_products = ranked_products.WHERE(product_rank <= 20)

# Calculate the final result with market segment, product name, and order count
final_result = top_products.CALCULATE(
    market_segment=customer_mktsegment,
    product_name=part.name,
    order_count=product_order_count
)
```
","# CALCULATE the year of the order
lines_with_year = lines.CALCULATE(order_year=YEAR(order.order_date))

# CALCULATE the market segment and filter for the year 1998
customer_data = customers.CALCULATE(cust_mktsegment=mktsegment).orders.WHERE(YEAR(order_date) == 1998)

# PARTITION by market segment
partitioned_data = PARTITION(customer_data, name='segment_group', by=customer.cust_mktsegment)

# CALCULATE the product order count and rank within each segment
ranked_products = partitioned_data.segment_group.lines.CALCULATE(
    customer_mktsegment=customer.cust_mktsegment,
    product_order_count=COUNT(part_key),
    product_rank=RANKING(by=COUNT(part_key).DESC(), levels=1)
)

# Filter for the top 20 products per market segment
top_products = ranked_products.WHERE(product_rank <= 20)

# CALCULATE the final result with market segment, product name, and order count
final_result = top_products.CALCULATE(
    market_segment=customer_mktsegment,
    product_name=part.name,
    order_count=product_order_count
)"
Retrieves the top 3 suppliers with the highest total sales for each region,"WITH SupplierSales AS (SELECT r_name AS region_name, s_name AS supplier_name, SUM(l_extendedprice * l_quantity) AS total_sales FROM region JOIN nation ON r_regionkey = n_regionkey JOIN supplier ON n_nationkey = s_nationkey JOIN lineitem ON s_suppkey = l_suppkey JOIN orders ON l_orderkey = o_orderkey GROUP BY r_name, s_name) SELECT region_name, supplier_name, total_sales FROM (SELECT region_name, supplier_name, total_sales, ROW_NUMBER() OVER (PARTITION BY region_name ORDER BY total_sales DESC) AS rank FROM SupplierSales) WHERE rank <= 3;",,"Okay, let's break this down into smaller parts.

1.  We need to calculate the total sales for each supplier. Total sales is defined as `extended_price * quantity`.
2.  We need to group suppliers by region.
3.  Within each region, we need to rank suppliers based on their total sales.
4.  We need to filter and retrieve the top 3 suppliers from each region based on their ranking.
5.  Finally, we need to display the region name, supplier name, and total sales for these top suppliers.

Here's the PyDough code:

```python
region_supplier_sales = TPCH.regions.CALCULATE(
    region_name=name
).nations.suppliers.CALCULATE(
    supplier_name=name,
    region_name=region_name,
    total_sales=SUM(lines.extended_price * lines.quantity)
).WHERE(RANKING(by=total_sales.DESC(), levels=2) <= 3)

result = region_supplier_sales.CALCULATE(region_name=region_name, supplier_name=supplier_name, total_sales=total_sales)
```","region_supplier_sales = TPCH.regions.CALCULATE(
    region_name=name
).nations.suppliers.CALCULATE(
    supplier_name=name,
    region_name=region_name,
    total_sales=SUM(lines.extended_price * lines.quantity)
).WHERE(RANKING(by=total_sales.DESC(), levels=2) <= 3)

result = region_supplier_sales.CALCULATE(region_name=region_name, supplier_name=supplier_name, total_sales=total_sales)"
"For each European country, list the number of customers and the number of orders they placed in 1995, including customers who didn't place any orders that year.","SELECT n_name AS country_name, COUNT(DISTINCT c_custkey) AS total_customers, COUNT(DISTINCT CASE WHEN o_orderdate >= '1995-01-01' AND o_orderdate <= '1995-12-31' THEN o_orderkey END) AS total_orders_1995 FROM nation JOIN region ON n_regionkey = r_regionkey JOIN customer ON n_nationkey = c_nationkey LEFT JOIN orders ON c_custkey = o_custkey WHERE r_name = 'EUROPE' GROUP BY n_name;",,"Okay, let's break this down. We need to:

1.  Filter for European countries.
2.  For each of those countries, count the number of customers.
3.  For each of those countries, count the number of orders placed in 1995.
4.  Include customers who didn't place any orders in 1995.

Here's how we can approach this in PyDough:

```python
european_customer_order_counts = nations.WHERE(region.name == ""EUROPE"").CALCULATE(
    nation_name=name,
    customer_count=COUNT(customers),
    orders_1995_count=SUM(customers.CALCULATE(order_count=COUNT(orders.WHERE(YEAR(order_date) == 1995))).order_count)
)
```

Explanation:

*   We start with the `nations` collection and filter for nations in the ""EUROPE"" `region`.
*   We use `CALCULATE` to derive the `nation_name`, `customer_count`, and `orders_1995_count`.
*   `customer_count` is simply the count of all customers in that nation.
*   `orders_1995_count` is the sum of the order counts for each customer in 1995. We calculate the order count for each customer by counting the orders placed in 1995 and then summing those counts. This ensures that customers with no orders in 1995 are included with a count of 0, and that the final result is a singular value.
","european_customer_order_counts = nations.WHERE(region.name == ""EUROPE"").CALCULATE(
    nation_name=name,
    customer_count=COUNT(customers),
    orders_1995_count=SUM(customers.CALCULATE(order_count=COUNT(orders.WHERE(YEAR(order_date) == 1995))).order_count)
)"
Retrieve the customer name of the customers who placed more orders in 1995 than in 1994,"SELECT c_name AS customer_name FROM customer JOIN orders ON c_custkey = o_custkey WHERE (strftime('%Y', o_orderdate) = '1994' OR strftime('%Y', o_orderdate) = '1995') GROUP BY c_custkey, c_name HAVING SUM(CASE WHEN strftime('%Y', o_orderdate) = '1995' THEN 1 ELSE 0 END) > SUM(CASE WHEN strftime('%Y', o_orderdate) = '1994' THEN 1 ELSE 0 END);",,"Here's how we can approach this:

1.  We need to count the number of orders each customer placed in 1995 and 1994.
2.  We need to compare these counts for each customer.
3.  We need to filter for customers where the 1995 count is greater than the 1994 count.
4.  Finally, we need to return the names of these customers.

Here's the PyDough code:

```python
customer_order_counts = customers.CALCULATE(
    customer_name=name,
    orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995)),
    orders_1994=COUNT(orders.WHERE(YEAR(order_date) == 1994))
).WHERE(orders_1995 > orders_1994).CALCULATE(customer_name=customer_name)
```

Explanation:

*   We start with the `customers` collection.
*   We use `CALCULATE` to create new fields: `orders_1995` and `orders_1994`. These fields count the number of orders placed by each customer in the respective years using `COUNT` and `WHERE` to filter the orders by year.
*   We use `WHERE` to filter the customers, keeping only those where `orders_1995` is greater than `orders_1994`.
*   Finally, we use `CALCULATE` again to select only the `customer_name` for the filtered customers.
","customer_order_counts = customers.CALCULATE(
    customer_name=name,
    orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995)),
    orders_1994=COUNT(orders.WHERE(YEAR(order_date) == 1994))
).WHERE(orders_1995 > orders_1994).CALCULATE(customer_name=customer_name)"
Which is the average order value per Nation? List the nation name and average order value. The order value is defined as extended_price * quantity,"SELECT n_name AS nation_name, AVG(l_extendedprice * l_quantity) AS average_order_value FROM nation JOIN customer ON n_nationkey = c_nationkey JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey GROUP BY n_name;",,"```python
nation_order_values = nations.customers.orders.lines.CALCULATE(
    total_line_price = extended_price * quantity
)
nation_order_partition = PARTITION(nation_order_values, name='nation_orders', by=order.customer.nation.name).CALCULATE(
    nation_name = order.customer.nation.name,
    average_order_value = AVG(nation_orders.total_line_price)
)
```

**Reasoning for the fix:**

The error message `Unrecognized term of simple table collection 'lines' in graph 'TPCH': 'name'` indicates that the `name` attribute is not directly accessible from the `lines` collection. The original code attempts to partition by `order.customer.nation.name`, which tries to access the nation's name through the lines collection. However, the `PARTITION` function requires the `by` parameter to be a scalar field directly available within the collection being partitioned.

To fix this, we need to partition by a field that is directly available in the `nation_order_values` collection. Since we are calculating the average order value per nation, we can first calculate the nation name for each line item and then partition by that calculated field.

Here's the corrected code:

```python
nation_order_values = nations.customers.orders.lines.CALCULATE(
    total_line_price = extended_price * quantity,
    nation_name = order.customer.nation.name
)
nation_order_partition = PARTITION(nation_order_values, name='nation_orders', by=nation_name).CALCULATE(
    nation_name = nation_name,
    average_order_value = AVG(nation_orders.total_line_price)
)
```

**Explanation of Changes:**

1.  **Calculate `nation_name`:** In the first `CALCULATE` statement, we added `nation_name = order.customer.nation.name` to the `nation_order_values` collection. This calculates the nation name for each line item and makes it available as a field in the `nation_order_values` collection.
2.  **Partition by `nation_name`:** In the `PARTITION` function, we changed the `by` parameter to `nation_name`. This partitions the `nation_order_values` collection by the calculated `nation_name` field.
3.  **Access `nation_name` in CALCULATE:** In the second `CALCULATE` statement, we changed `order.customer.nation.name` to `nation_name` to access the nation name from the partitioned collection.

This corrected code first calculates the nation name for each line item, then partitions the data by nation name, and finally calculates the average order value for each nation. This resolves the original error and aligns with the intended functionality of the query.
","nation_order_values = nations.customers.orders.lines.CALCULATE(
    total_line_price = extended_price * quantity
)
nation_order_partition = PARTITION(nation_order_values, name='nation_orders', by=order.customer.nation.name).CALCULATE(
    nation_name = order.customer.nation.name,
    average_order_value = AVG(nation_orders.total_line_price)
)"
What 3 product brands saw the largest positive change in quantity sold from 1995 to 1996.,"WITH sales_1995 AS (
    SELECT
        p.p_brand,
        SUM(l.l_quantity) as total_quantity
    FROM
        lineitem l
    JOIN
        part p ON l.l_partkey = p.p_partkey
    JOIN
        orders o ON l.l_orderkey = o.o_orderkey
    WHERE
        strftime('%Y', o.o_orderdate) = '1995'
    GROUP BY
        p.p_brand
),

sales_1996 AS (
    SELECT
        p.p_brand,
        SUM(l.l_quantity) as total_quantity
    FROM
        lineitem l
    JOIN
        part p ON l.l_partkey = p.p_partkey
    JOIN
        orders o ON l.l_orderkey = o.o_orderkey
    WHERE
        strftime('%Y', o.o_orderdate) = '1996'
    GROUP BY
        p.p_brand
)

SELECT
    s96.p_brand as brand,
    COALESCE(s95.total_quantity, 0) as qty_1995,
    s96.total_quantity as qty_1996,
    (s96.total_quantity - COALESCE(s95.total_quantity, 0)) as quantity_change
FROM
    sales_1996 s96
LEFT JOIN
    sales_1995 s95 ON s96.p_brand = s95.p_brand
WHERE
    (s96.total_quantity - COALESCE(s95.total_quantity, 0)) > 0
ORDER BY
    quantity_change DESC
LIMIT 3;",,"```python
lines_with_year = lines.CALCULATE(
    part_brand=part.brand,
    year=YEAR(ship_date),
    quantity=quantity
)

brand_sales = PARTITION(lines_with_year, name='brand_group', by=part_brand).CALCULATE(
    brand=part_brand,
    total_quantity_1995=SUM(KEEP_IF(brand_group.quantity, brand_group.year == 1995)),
    total_quantity_1996=SUM(KEEP_IF(brand_group.quantity, brand_group.year == 1996))
)

difference = brand_sales.CALCULATE(
    brand=brand,
    difference=DEFAULT_TO(total_quantity_1996, 0) - DEFAULT_TO(total_quantity_1995, 0)
).WHERE(difference > 0).TOP_K(3, by=difference.DESC())
```
","lines_with_year = lines.CALCULATE(
    part_brand=part.brand,
    year=YEAR(ship_date),
    quantity=quantity
)

brand_sales = PARTITION(lines_with_year, name='brand_group', by=part_brand).CALCULATE(
    brand=part_brand,
    total_quantity_1995=SUM(KEEP_IF(brand_group.quantity, brand_group.year == 1995)),
    total_quantity_1996=SUM(KEEP_IF(brand_group.quantity, brand_group.year == 1996))
)

difference = brand_sales.CALCULATE(
    brand=brand,
    difference=DEFAULT_TO(total_quantity_1996, 0) - DEFAULT_TO(total_quantity_1995, 0)
).WHERE(difference > 0).TOP_K(3, by=difference.DESC())"
"What is the total revenue generated by each customer in 1994? Sorted by total revenue in descending order. The total revenue value is defined as the sum of extended_price * (1 - discount) What is the total revenue generated by each customer in 1994? The total revenue value is defined as the sum of extended_price * (1 - discount). Return the customer key, customer name and total revenue","SELECT c.c_custkey AS custkey, c.c_name AS cust_name, COALESCE(SUM(l.l_extendedprice * (1 - l.l_discount)), 0) AS total_revenue FROM customer c LEFT JOIN orders o ON c.c_custkey = o.o_custkey AND strftime('%Y', o.o_orderdate) = '1994' LEFT JOIN lineitem l ON o.o_orderkey = l.l_orderkey GROUP BY c.c_custkey ORDER BY total_revenue DESC;",,"Okay, let's break this down. We need to calculate the total revenue generated by each customer in 1994. The revenue is calculated as the sum of `extended_price * (1 - discount)` for each line item associated with the customer's orders in 1994. We need to return the customer's key, name, and the calculated total revenue, sorted by total revenue in descending order.

Here's how we can approach this:

1.  Start with the `customers` collection.
2.  For each customer, access their orders placed in 1994.
3.  For each order, calculate the revenue for each line item: `extended_price * (1 - discount)`.
4.  Sum the revenue for all line items in all orders for that customer in 1994.
5.  Return the customer's key, name, and the calculated total revenue.
6.  Sort the results by total revenue in descending order.

Here's the PyDough code:

```python
customer_revenue = customers.CALCULATE(
    cust_key=key,
    cust_name=name,
    total_revenue=SUM(orders.WHERE(YEAR(order_date) == 1994).lines.CALCULATE(line_revenue=extended_price * (1 - discount)).line_revenue)
).ORDER_BY(total_revenue.DESC())
```
","customer_revenue = customers.CALCULATE(
    cust_key=key,
    cust_name=name,
    total_revenue=SUM(orders.WHERE(YEAR(order_date) == 1994).lines.CALCULATE(line_revenue=extended_price * (1 - discount)).line_revenue)
).ORDER_BY(total_revenue.DESC())"
"Find all customers whose name ends with a zero and are in the 30-lowest account balances. Show the customer key, name and account balance","SELECT c_custkey, c_name, c_acctbal FROM customer WHERE c_name LIKE '%0' ORDER BY c_acctbal ASC LIMIT 30;",,"Here's how we can approach this:

1.  We need to access the `customers` collection.
2.  We need to filter the customers whose names end with ""0"".
3.  We need to find the 30 customers with the lowest account balances.
4.  We need to select the customer key, name, and account balance.

Here's the PyDough code:

```python
customers_ending_with_zero = customers.WHERE(ENDSWITH(name, ""0"")).TOP_K(30, by=acctbal.ASC()).CALCULATE(
    customer_key=key,
    customer_name=name,
    account_balance=acctbal
)
```
","customers_ending_with_zero = customers.WHERE(ENDSWITH(name, ""0"")).TOP_K(30, by=acctbal.ASC()).CALCULATE(
    customer_key=key,
    customer_name=name,
    account_balance=acctbal
)"
"For each of the 5 largest part sizes, find the part of that size with the largest retail price","WITH top_sizes AS (SELECT DISTINCT p_size FROM part ORDER BY p_size DESC LIMIT 5), ranked_parts AS (SELECT p.p_partkey, p.p_name, p.p_size, p.p_retailprice, RANK() OVER (PARTITION BY p.p_size ORDER BY p.p_retailprice DESC) AS price_rank FROM part p WHERE p.p_size IN (SELECT p_size FROM top_sizes)) SELECT p_partkey, p_name, p_size, p_retailprice FROM ranked_parts WHERE price_rank = 1 ORDER BY p_size DESC, p_retailprice DESC;",,"Here's how we can approach this:

1.  **Partition by Size**: Partition the `parts` collection by the `size` attribute.
2.  **Find 5 Largest Sizes**: Determine the 5 largest part sizes based on the partition.
3.  **Apply Ranking**: Within each of the 5 largest sizes, rank the parts by `retail_price` in descending order.
4.  **Return the part with the largest retail price**: Return the part with the largest retail price

```python
partitioned_parts = PARTITION(parts, name='part_group', by=size).CALCULATE(
    size=size,
    max_retail_price=MAX(part_group.retail_price)
).TOP_K(5, by=max_retail_price.DESC()).part_group.CALCULATE(
    part_name=name,
    size=size,
    retail_price=retail_price,
    price_rank=RANKING(by=retail_price.DESC(), levels=1)
).WHERE(price_rank == 1)
```
","partitioned_parts = PARTITION(parts, name='part_group', by=size).CALCULATE(
    size=size,
    max_retail_price=MAX(part_group.retail_price)
).TOP_K(5, by=max_retail_price.DESC()).part_group.CALCULATE(
    part_name=name,
    size=size,
    retail_price=retail_price,
    price_rank=RANKING(by=retail_price.DESC(), levels=1)
).WHERE(price_rank == 1)"
"For each region, calculate the average percentage of purchases made from suppliers in that region belonging to the most common part type shipped from the supplier region to the customer region, averaging across all customer region. Only considers lineitems from June of 1992 where the container is small. To know if a container is small the container should start with SM","WITH part_counts AS (
  SELECT 
    rs.R_NAME AS supp_region,
    rc.R_NAME AS cust_region,
    p.P_TYPE AS p_type,
    COUNT(*) AS type_count
  FROM lineitem l
  JOIN part p ON l.L_PARTKEY = p.P_PARTKEY
  JOIN supplier s ON l.L_SUPPKEY = s.S_SUPPKEY
  JOIN nation ns ON s.S_NATIONKEY = ns.N_NATIONKEY
  JOIN region rs ON ns.N_REGIONKEY = rs.R_REGIONKEY
  JOIN orders o ON l.L_ORDERKEY = o.O_ORDERKEY
  JOIN customer c ON o.O_CUSTKEY = c.C_CUSTKEY
  JOIN nation nc ON c.C_NATIONKEY = nc.N_NATIONKEY
  JOIN region rc ON nc.N_REGIONKEY = rc.R_REGIONKEY
  WHERE l.L_SHIPDATE BETWEEN '1992-06-01' AND '1992-06-30'
    AND  p.P_CONTAINER LIKE 'SM%'
  GROUP BY rs.R_NAME, rc.R_NAME, p.P_TYPE
),
region_customer AS (
  SELECT 
    supp_region,
    cust_region,
    SUM(type_count) AS total_count,
    MAX(type_count) AS max_type_count
  FROM part_counts
  GROUP BY supp_region, cust_region
),
region_avg AS (
  SELECT 
    supp_region,
    AVG(100.0 * max_type_count / total_count) AS avg_percentage
  FROM region_customer
  GROUP BY supp_region
)
SELECT 
  supp_region AS region,
  avg_percentage
FROM region_avg
ORDER BY region;
",,"```python
filtered_lines = lines.WHERE((MONTH(ship_date) == 6) & (YEAR(ship_date) == 1992) & STARTSWITH(part.container, ""SM""))

supplier_customer_regions = filtered_lines.CALCULATE(
    supplier_region_name=supplier.nation.region.name,
    customer_region_name=order.customer.nation.region.name,
    part_type=part.part_type
)

part_type_counts = PARTITION(supplier_customer_regions, name=""s_c_regions"", by=(supplier_region_name, customer_region_name, part_type)).CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    part_type=part_type,
    part_type_count=COUNT(s_c_regions)
)

most_common_part_types = PARTITION(part_type_counts, name=""ptc"", by=(supplier_region_name, customer_region_name)).CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    most_common_part_type=ptc.TOP_K(1, by=part_type_count.DESC()).SINGULAR().part_type
)

purchase_percentages = supplier_customer_regions.CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    part_type=part_type
).CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    is_most_common=IFF(part_type == most_common_part_types.WHERE((supplier_region_name == supplier_region_name) & (customer_region_name == customer_region_name)).SINGULAR().most_common_part_type, 1, 0)
)

region_percentages = PARTITION(purchase_percentages, name=""pp"", by=supplier_region_name).CALCULATE(
    supplier_region_name=supplier_region_name,
    total_purchases=COUNT(pp),
    most_common_purchases=SUM(pp.is_most_common)
).CALCULATE(
    supplier_region_name=supplier_region_name,
    average_percentage=100.0 * most_common_purchases / total_purchases
)

final_result = regions.CALCULATE(
    region_name=name
).CALCULATE(
    region_name=name,
    average_percentage=DEFAULT_TO(region_percentages.WHERE(supplier_region_name == name).SINGULAR().average_percentage, 0)
)
```","filtered_lines = lines.WHERE((MONTH(ship_date) == 6) & (YEAR(ship_date) == 1992) & STARTSWITH(part.container, ""SM""))

supplier_customer_regions = filtered_lines.CALCULATE(
    supplier_region_name=supplier.nation.region.name,
    customer_region_name=order.customer.nation.region.name,
    part_type=part.part_type
)

part_type_counts = PARTITION(supplier_customer_regions, name=""s_c_regions"", by=(supplier_region_name, customer_region_name, part_type)).CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    part_type=part_type,
    part_type_count=COUNT(s_c_regions)
)

most_common_part_types = PARTITION(part_type_counts, name=""ptc"", by=(supplier_region_name, customer_region_name)).CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    most_common_part_type=ptc.TOP_K(1, by=part_type_count.DESC()).SINGULAR().part_type
)

purchase_percentages = supplier_customer_regions.CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    part_type=part_type
).CALCULATE(
    supplier_region_name=supplier_region_name,
    customer_region_name=customer_region_name,
    is_most_common=IFF(part_type == most_common_part_types.WHERE((supplier_region_name == supplier_region_name) & (customer_region_name == customer_region_name)).SINGULAR().most_common_part_type, 1, 0)
)

region_percentages = PARTITION(purchase_percentages, name=""pp"", by=supplier_region_name).CALCULATE(
    supplier_region_name=supplier_region_name,
    total_purchases=COUNT(pp),
    most_common_purchases=SUM(pp.is_most_common)
).CALCULATE(
    supplier_region_name=supplier_region_name,
    average_percentage=100.0 * most_common_purchases / total_purchases
)

final_result = regions.CALCULATE(
    region_name=name
).CALCULATE(
    region_name=name,
    average_percentage=DEFAULT_TO(region_percentages.WHERE(supplier_region_name == name).SINGULAR().average_percentage, 0)
)"
"Break down how many customers, by country code of their phone number (only including customers from certain country codes), have not placed an order but have an account balance that is above the average for all positive account balances of such customers. Also include the total balance for all such customers for each country code. The country codes to include are 13, 23, 29, 30, 18 and 17.","WITH CountryAvg AS (
    SELECT 
        SUBSTR(C_PHONE, 1, INSTR(C_PHONE, '-') - 1) AS country_code,
        AVG(C_ACCTBAL) AS avg_balance
    FROM Customer
    WHERE C_ACCTBAL > 0
        AND CAST(SUBSTR(C_PHONE, 1, INSTR(C_PHONE, '-') - 1) AS INTEGER) IN (13, 23, 29, 30, 18, 17)
    GROUP BY country_code
)
SELECT 
    c.country_code,
    COUNT(*) AS customer_count,
    SUM(c.C_ACCTBAL) AS total_balance
FROM (
    SELECT 
        SUBSTR(C_PHONE, 1, INSTR(C_PHONE, '-') - 1) AS country_code,
        C_CUSTKEY,
        C_ACCTBAL
    FROM Customer
) c
LEFT JOIN Orders o ON c.C_CUSTKEY = o.O_CUSTKEY
INNER JOIN CountryAvg ca ON c.country_code = ca.country_code
WHERE o.O_CUSTKEY IS NULL
    AND c.C_ACCTBAL > ca.avg_balance
GROUP BY c.country_code;",,"```python
country_codes = (""13"", ""23"", ""29"", ""30"", ""18"", ""17"")

# Calculate the average account balance for customers with positive balances and the specified country codes
customers_with_country_code = customers.WHERE(ISIN(phone[:2], country_codes))
avg_acctbal = customers_with_country_code.WHERE(acctbal > 0).CALCULATE(avg_acctbal=AVG(acctbal)).SINGULAR().avg_acctbal

# Filter customers based on country code, no orders, and above-average account balance
filtered_customers = customers.WHERE(
    ISIN(phone[:2], country_codes) &
    HASNOT(orders) &
    (acctbal > avg_acctbal)
)

# Partition the filtered customers by country code and calculate the count and total balance
customer_summary = PARTITION(filtered_customers, name=""cust"", by=phone[:2]).CALCULATE(
    country_code=phone[:2],
    num_customers=COUNT(cust),
    total_balance=SUM(cust.acctbal)
)
```
","country_codes = (""13"", ""23"", ""29"", ""30"", ""18"", ""17"")

# CALCULATE the average account balance for customers with positive balances and the specified country codes
customers_with_country_code = customers.WHERE(ISIN(phone[:2], country_codes))
avg_acctbal = customers_with_country_code.WHERE(acctbal > 0).CALCULATE(avg_acctbal=AVG(acctbal)).SINGULAR().avg_acctbal

# Filter customers based on country code, no orders, and above-average account balance
filtered_customers = customers.WHERE(
    ISIN(phone[:2], country_codes) &
    HASNOT(orders) &
    (acctbal > avg_acctbal)
)

# PARTITION the filtered customers by country code and CALCULATE the count and total balance
customer_summary = PARTITION(filtered_customers, name=""cust"", by=phone[:2]).CALCULATE(
    country_code=phone[:2],
    num_customers=COUNT(cust),
    total_balance=SUM(cust.acctbal)
)"
Find the names of all customers and the number of orders placed in 1995 in Europe that placed a least one order in that same year. Sorted in descending order by the number of orders.,"SELECT
    c.c_name AS customer_name,
    COUNT(o.o_orderkey) AS order_count
FROM
    customer c
JOIN
    orders o ON c.c_custkey = o.o_custkey
JOIN
    nation n ON c.c_nationkey = n.n_nationkey
WHERE
    strftime('%Y', o.o_orderdate) = '1995'
    AND n.n_regionkey = (
        SELECT r_regionkey
        FROM region
        WHERE r_name = 'EUROPE'
    )
GROUP BY
    c.c_custkey, c.c_name
ORDER BY
    order_count DESC;",,"Okay, let's break this down into smaller parts.

1.  We need to access the `customers` collection.
2.  We need to filter customers from the ""EUROPE"" region.
3.  We need to count the number of orders placed by each customer in 1995.
4.  We need to filter out customers who did not place any orders in 1995.
5.  We need to sort the results in descending order based on the number of orders.
6.  We need to return the customer's name and the number of orders.

Here's the PyDough code:

```python
customer_order_counts = customers.WHERE(nation.region.name == ""EUROPE"").CALCULATE(
    customer_name=name,
    num_orders=COUNT(orders.WHERE(YEAR(order_date) == 1995))
).WHERE(num_orders > 0).ORDER_BY(num_orders.DESC())
```
","customer_order_counts = customers.WHERE(nation.region.name == ""EUROPE"").CALCULATE(
    customer_name=name,
    num_orders=COUNT(orders.WHERE(YEAR(order_date) == 1995))
).WHERE(num_orders > 0).ORDER_BY(num_orders.DESC())"
"List customers who ordered in 1996 but not in 1997 with a total spent of over 1000$. Include the number of months since the last order (relative to the current date) and sort by total spent, highest first.","SELECT
  customer_name,
  total_spent,
  months_since_last_order
FROM (
  SELECT
    total_spent AS ordering_4,
    customer_name,
    months_since_last_order,
    total_spent
  FROM (
    SELECT
      agg_2,
      agg_3,
      customer_name,
      months_since_last_order,
      total_spent
    FROM (
      SELECT
        agg_2,
        customer_name,
        key,
        months_since_last_order,
        total_spent
      FROM (
        SELECT
          COALESCE(agg_1, 0) AS total_spent,
          name AS customer_name,
          (
            CAST(STRFTIME('%Y', DATETIME('now')) AS INTEGER) - CAST(STRFTIME('%Y', agg_0) AS INTEGER)
          ) * 12 + CAST(STRFTIME('%m', DATETIME('now')) AS INTEGER) - CAST(STRFTIME('%m', agg_0) AS INTEGER) AS months_since_last_order,
          key
        FROM (
          SELECT
            agg_0,
            agg_1,
            key,
            name
          FROM (
            SELECT
              c_custkey AS key,
              c_name AS name
            FROM main.CUSTOMER
          )
          LEFT JOIN (
            SELECT
              MAX(order_date) AS agg_0,
              SUM(total_price) AS agg_1,
              customer_key
            FROM (
              SELECT
                o_custkey AS customer_key,
                o_orderdate AS order_date,
                o_totalprice AS total_price
              FROM main.ORDERS
            )
            GROUP BY
              customer_key
          )
            ON key = customer_key
        )
      )
      LEFT JOIN (
        SELECT
          COUNT() AS agg_2,
          customer_key
        FROM (
          SELECT
            customer_key
          FROM (
            SELECT
              o_custkey AS customer_key,
              o_orderdate AS order_date
            FROM main.ORDERS
          )
          WHERE
            CAST(STRFTIME('%Y', order_date) AS INTEGER) = 1996
        )
        GROUP BY
          customer_key
      )
        ON key = customer_key
    )
    LEFT JOIN (
      SELECT
        COUNT() AS agg_3,
        customer_key
      FROM (
        SELECT
          customer_key
        FROM (
          SELECT
            o_custkey AS customer_key,
            o_orderdate AS order_date
          FROM main.ORDERS
        )
        WHERE
          CAST(STRFTIME('%Y', order_date) AS INTEGER) = 1997
      )
      GROUP BY
        customer_key
    )
      ON key = customer_key
  )
  WHERE
    (
      (
        COALESCE(agg_2, 0) > 0
      ) = 1
    )
    AND (
      (
        COALESCE(agg_3, 0) = 0
      ) = 1
    )
    AND (
      total_spent > 1000
    )
)
ORDER BY
  ordering_4 DESC",,"```python
customers_1996_not_1997 = customers.CALCULATE(
    customer_key=key,
    customer_name=name,
    total_spent=SUM(orders.total_price),
    has_orders_1996=HAS(orders.WHERE(YEAR(order_date) == 1996))==1,
    has_orders_1997=HAS(orders.WHERE(YEAR(order_date) == 1997))==1,
    last_order_date=MAX(orders.order_date)
).WHERE(
    (total_spent > 1000) &
    (has_orders_1996 == True) &
    (has_orders_1997 == False)
).CALCULATE(
    months_since_last_order=DATEDIFF(""months"", last_order_date, DATETIME('now')),
    customer_name=customer_name,
    total_spent=total_spent
).ORDER_BY(total_spent.DESC())
```","customers_1996_not_1997 = customers.CALCULATE(
    customer_key=key,
    customer_name=name,
    total_spent=SUM(orders.total_price),
    has_orders_1996=HAS(orders.WHERE(YEAR(order_date) == 1996))==1,
    has_orders_1997=HAS(orders.WHERE(YEAR(order_date) == 1997))==1,
    last_order_date=MAX(orders.order_date)
).WHERE(
    (total_spent > 1000) &
    (has_orders_1996 == True) &
    (has_orders_1997 == False)
).CALCULATE(
    months_since_last_order=DATEDIFF(""months"", last_order_date, DATETIME('now')),
    customer_name=customer_name,
    total_spent=total_spent
).ORDER_BY(total_spent.DESC())"
What is the february 1996 SPM for the almond antique blue royal burnished part in China? SPM (Selling Profit Margin) = (Total Amount from Sells - (Tax + Commission)) / Total Amount from Sells * 100,"SELECT
  ROUND(
    (
      (
        -- Total Sales (Revenue after discount)
        SUM(l.l_extendedprice) 
        - 
        (
          -- Total Tax (on discounted sales)
          SUM(l.l_extendedprice  * l.l_tax) 
          + 
          -- Total Commission (discount amount)
          SUM(l.l_extendedprice * l.l_discount)
        )
      ) 
      / 
      SUM(l.l_extendedprice) 
    ) * 100, 2
  ) AS spm
FROM part p
JOIN lineitem l ON p.p_partkey = l.l_partkey
JOIN orders o ON l.l_orderkey = o.o_orderkey
JOIN customer c ON o.o_custkey = c.c_custkey
JOIN nation n ON c.c_nationkey = n.n_nationkey
WHERE
  -- Match the part name (case-sensitive wildcards)
  p.p_name LIKE '%rosy%black%navajo%cream%sky%'
  -- Filter for February 1996 orders
  AND strftime('%Y-%m', o.o_orderdate) = '1996-02'
  -- Optional: Filter for a specific nation (e.g., China)
  -- AND n.n_name = 'CHINA';",,"```python
lines_1996 = lines.WHERE(YEAR(order.order_date) == 1996)

part_china_feb_1996 = lines_1996.WHERE(
    (part.name == 'Rosy Black Navajo Cream Sky') &
    (order.customer.nation.name == 'CHINA') &
    (MONTH(order.order_date) == 2)
).CALCULATE(
    total_sales_amount=extended_price,
    tax_amount=tax,
    discount_amount=discount
)

spm_china_feb_1996 = part_china_feb_1996.CALCULATE(
    spm=((total_sales_amount - (tax_amount + discount_amount)) / total_sales_amount) * 100
)

result = spm_china_feb_1996
```","lines_1996 = lines.WHERE(YEAR(order.order_date) == 1996)

part_china_feb_1996 = lines_1996.WHERE(
    (part.name == 'Rosy Black Navajo Cream Sky') &
    (order.customer.nation.name == 'CHINA') &
    (MONTH(order.order_date) == 2)
).CALCULATE(
    total_sales_amount=extended_price,
    tax_amount=tax,
    discount_amount=discount
)

spm_china_feb_1996 = part_china_feb_1996.CALCULATE(
    spm=((total_sales_amount - (tax_amount + discount_amount)) / total_sales_amount) * 100
)

result = spm_china_feb_1996"
