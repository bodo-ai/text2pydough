question,sql,similar_queries,response,extracted_python_code,comparison_result,exception
List the total number of customers and suppliers in each nation. Order by nation name,"SELECT n_name AS nation_name, COUNT(DISTINCT c_custkey) AS total_customers, COUNT(DISTINCT s_suppkey) AS total_suppliers FROM nation LEFT JOIN customer ON n_nationkey = c_nationkey LEFT JOIN supplier ON n_nationkey = s_nationkey GROUP BY n_name;","1. Count customers and suppliers by region:

# Count customers and suppliers by region
nation_counts = regions.CALCULATE(
    region_name=name,
    n_customers=COUNT(nations.customers),
    n_suppliers=COUNT(nations.suppliers)
)","```python
import datetime

# Function Selection:
# 1. `nations`: Access the base collection of nations.
# 2. `CALCULATE`: To select the nation's name and compute the counts of customers and suppliers for each nation.
# 3. `COUNT`: Aggregation function to count the number of records in the `customers` and `suppliers` sub-collections for each nation.
# 4. `ORDER_BY`: To sort the final result alphabetically by nation name.

# Partitioning Strategy:
# Partitioning is not necessary for this query. We can directly calculate the counts for each nation using `CALCULATE` on the `nations` collection.

# Ranking Considerations:
# Ranking is not required for this query.

# Code Generation:
nation_summary = nations.CALCULATE(
    nation_name=name,
    num_customers=COUNT(customers),
    num_suppliers=COUNT(suppliers)
).ORDER_BY(nation_name.ASC())
```

**Explanation:**

1.  `nations.CALCULATE(...)`: We start with the `nations` collection and use `CALCULATE` to process each nation.
2.  `nation_name=name`: Selects the name of the nation and assigns it to the `nation_name` field in the output.
3.  `num_customers=COUNT(customers)`: Counts the number of customers associated with the current nation using the `COUNT` aggregation function on the `customers` sub-collection. The result is assigned to the `num_customers` field.
4.  `num_suppliers=COUNT(suppliers)`: Counts the number of suppliers associated with the current nation using the `COUNT` aggregation function on the `suppliers` sub-collection. The result is assigned to the `num_suppliers` field.
5.  `.ORDER_BY(nation_name.ASC())`: Sorts the resulting collection in ascending order based on the `nation_name` field.","import datetime

# Function Selection:
# 1. `nations`: Access the base collection of nations.
# 2. `CALCULATE`: To select the nation's name and compute the counts of customers and suppliers for each nation.
# 3. `COUNT`: Aggregation function to count the number of records in the `customers` and `suppliers` sub-collections for each nation.
# 4. `ORDER_BY`: To sort the final result alphabetically by nation name.

# Partitioning Strategy:
# Partitioning is not necessary for this query. We can directly CALCULATE the counts for each nation using `CALCULATE` on the `nations` collection.

# RANKING Considerations:
# RANKING is not required for this query.

# Code Generation:
nation_summary = nations.CALCULATE(
    nation_name=name,
    num_customers=COUNT(customers),
    num_suppliers=COUNT(suppliers)
).ORDER_BY(nation_name.ASC())",Match,
Find the top 5 nations with the highest number of orders placed by their customers in 1995.,"SELECT n_name AS nation_name, COUNT(o_orderkey) AS total_orders FROM nation JOIN customer ON n_nationkey = c_nationkey JOIN orders ON c_custkey = o_custkey WHERE o_orderdate >= '1995-01-01' AND o_orderdate <= '1995-12-31' GROUP BY n_name ORDER BY total_orders DESC LIMIT 5;","1. Top 5 nations by average order value in 1995:

orders_in_1995= customers.orders.WHERE(YEAR(order_date) == 1995)

top_5_nations = nations.CALCULATE(
    nation_name=name,
    average_orders= AVG(orders_in_1995), 
    order_count=COUNT(orders_in_1995)
).TOP_K(5, by=average_orders.DESC())","Okay, let's break this down.

1.  **Goal**: Find the top 5 nations ranked by the total number of orders placed by their customers in 1995.
2.  **Collections**: We need `nations` to get the nation names, `customers` linked to nations, and `orders` linked to customers.
3.  **Filtering**: We need to filter the `orders` to include only those placed in the year 1995. The `WHERE` clause combined with the `YEAR` function on `order_date` is suitable for this.
4.  **Aggregation**: For each nation, we need to count the relevant orders. The `COUNT` aggregation function is needed here, applied to the filtered orders (`customers.orders.WHERE(...)`).
5.  **Ranking/Selection**: We need the top 5 nations based on this count. The `TOP_K` function is the correct choice for selecting a specific number of top records based on an aggregated value.
6.  **Calculation**: The `CALCULATE` function will be used on the `nations` collection to compute the order count for 1995 and select the nation's name.

```python
# Calculate the number of orders per nation for the year 1995
nations_order_count_1995 = nations.CALCULATE(
    nation_name=name,
    num_orders_1995=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))
)

# Select the top 5 nations based on the calculated order count
top_5_nations_by_orders_1995 = nations_order_count_1995.TOP_K(
    5,
    by=num_orders_1995.DESC()
)
```

**Explanation:**

1.  `nations.CALCULATE(...)`: We start with the `nations` collection and use `CALCULATE` to create new fields or select existing ones for each nation.
2.  `nation_name=name`: We select the `name` of the nation and assign it to the `nation_name` field in the result.
3.  `num_orders_1995=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))`:
    *   We calculate a new field named `num_orders_1995`.
    *   `customers.orders`: We access the `orders` sub-collection through the `customers` linked to each nation.
    *   `.WHERE(YEAR(order_date) == 1995)`: We filter these orders, keeping only those where the `YEAR` extracted from the `order_date` is equal to 1995.
    *   `COUNT(...)`: We count the number of orders that remain after filtering for each nation.
4.  `.TOP_K(5, by=num_orders_1995.DESC())`:
    *   We apply `TOP_K` to the result of the `CALCULATE` operation.
    *   `5`: Specifies that we want the top 5 records.
    *   `by=num_orders_1995.DESC()`: Specifies that the ranking should be based on the `num_orders_1995` field in descending order (highest count first).

This code calculates the total number of orders placed in 1995 for customers belonging to each nation and then selects the top 5 nations with the highest counts.","# CALCULATE the number of orders per nation for the year 1995
nations_order_count_1995 = nations.CALCULATE(
    nation_name=name,
    num_orders_1995=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))
)

# Select the top 5 nations based on the calculated order count
top_5_nations_by_orders_1995 = nations_order_count_1995.TOP_K(
    5,
    by=num_orders_1995.DESC()
)",Match,
"Find the region name with the highest total order value in 1996. The total order value is defined as potential revenue, defined as the sum of extended_price * (1 - discount)","SELECT r_name AS region_name, SUM(l_extendedprice * (1 - l_discount)) AS total_order_value FROM region JOIN nation ON r_regionkey = n_regionkey JOIN customer ON n_nationkey = c_nationkey JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey WHERE o_orderdate >= '1996-01-01' AND o_orderdate <= '1996-12-31' GROUP BY r_name ORDER BY total_order_value DESC LIMIT 1;",,"Okay, let's break this down.

1.  **Goal**: Find the region with the highest total potential revenue in 1996. Potential revenue is `SUM(extended_price * (1 - discount))` for relevant line items.
2.  **Collections**: We need `regions` to get the region name and `lines` (accessed via `regions.nations.customers.orders.lines`) to calculate the revenue. We also need `orders` (accessed via `lines.order`) to filter by year.
3.  **Functions**:
    *   `CALCULATE`: To define the `region_name` and the `total_order_value`. Also needed within the aggregation to calculate `line_revenue = extended_price * (1 - discount)` for each line item before summing, as per the rule about operating on different child attributes.
    *   `SUM`: To aggregate the `line_revenue` per region.
    *   `WHERE`: To filter `lines` based on the order year (`YEAR(order.order_date) == 1996`).
    *   `YEAR`: To extract the year from `order_date`.
    *   `TOP_K`: To select the single region with the maximum `total_order_value`.
4.  **Partitioning**: Not needed. We can aggregate directly at the `regions` level.
5.  **Ranking**: Not needed. `TOP_K` is sufficient.

```python
# Calculate potential revenue for each region in 1996
region_potential_revenue_1996 = regions.CALCULATE(
    region_name=name,
    # Sum the potential revenue from line items within each region for orders in 1996
    total_order_value=SUM(
        # Navigate through the hierarchy to reach line items
        nations.customers.orders.lines
        # Filter line items associated with orders placed in 1996
        .WHERE(YEAR(order.order_date) == 1996)
        # Calculate potential revenue for each qualifying line item
        .CALCULATE(line_revenue=extended_price * (1 - discount))
        # Access the calculated line revenue for summation
        .line_revenue
    )
)

# Select the top region based on the calculated total order value
top_region_1996 = region_potential_revenue_1996.TOP_K(
    1, by=total_order_value.DESC()
# Select only the requested fields: region name and total order value
).CALCULATE(region_name=region_name, total_order_value=total_order_value)
```

**Explanation:**

1.  `regions.CALCULATE(...)`: We start at the `regions` collection and calculate two fields for each region.
2.  `region_name=name`: We select the name of the region.
3.  `total_order_value=SUM(...)`: We calculate the total potential revenue for the region.
4.  `nations.customers.orders.lines`: We navigate down the hierarchy from regions to line items.
5.  `.WHERE(YEAR(order.order_date) == 1996)`: We filter the line items, keeping only those whose corresponding order (`lines.order`) was placed in 1996.
6.  `.CALCULATE(line_revenue=extended_price * (1 - discount))`: For each filtered line item, we calculate its potential revenue (`extended_price * (1 - discount)`) and store it in a temporary field `line_revenue`. This intermediate calculation is necessary because we are multiplying two fields from the `lines` collection.
7.  `.line_revenue`: We access the calculated `line_revenue` for the `SUM` function.
8.  `SUM(...)`: Aggregates the `line_revenue` for all relevant line items within the current region.
9.  `.TOP_K(1, by=total_order_value.DESC())`: After calculating the `total_order_value` for all regions, we select the top 1 region based on this value in descending order.
10. `.CALCULATE(region_name=region_name, total_order_value=total_order_value)`: Finally, we select only the `region_name` and `total_order_value` from the top region result.","# CALCULATE potential revenue for each region in 1996
region_potential_revenue_1996 = regions.CALCULATE(
    region_name=name,
    # SUM the potential revenue from line items within each region for orders in 1996
    total_order_value=SUM(
        # Navigate through the hierarchy to reach line items
        nations.customers.orders.lines
        # Filter line items associated with orders placed in 1996
        .WHERE(YEAR(order.order_date) == 1996)
        # CALCULATE potential revenue for each qualifying line item
        .CALCULATE(line_revenue=extended_price * (1 - discount))
        # Access the calculated line revenue for summation
        .line_revenue
    )
)

# Select the top region based on the calculated total order value
top_region_1996 = region_potential_revenue_1996.TOP_K(
    1, by=total_order_value.DESC()
# Select only the requested fields: region name and total order value
).CALCULATE(region_name=region_name, total_order_value=total_order_value)",Match,
Find the top 3 regions with the most distinct customers,"SELECT r_name AS region_name, COUNT(DISTINCT c_custkey) AS distinct_customers FROM region JOIN nation ON r_regionkey = n_regionkey JOIN customer ON n_nationkey = c_nationkey GROUP BY r_name ORDER BY distinct_customers DESC LIMIT 3;","1. Find the top 10 with the most distinct suppliers

top_regions = regions.CALCULATE(
    region_name=name,
    suppliers_count=NDISTINCT(nations.suppliers.key))
).TOP_K(10, by=customer_count.DESC())""
","Okay, let's break this down.

1.  **Goal**: Find the top 3 regions with the highest number of unique customers.
2.  **Collections**: We need `regions` to get the region names and `customers` (accessed via `regions.nations.customers`) to count them.
3.  **Functions**:
    *   `CALCULATE`: To compute the distinct count of customers for each region and select the region name.
    *   `NDISTINCT`: To count the unique customers within each region. We'll count the distinct `key` from the `customers` collection accessible via `regions.nations.customers`.
    *   `TOP_K`: To select the top 3 regions based on the calculated distinct customer count.

```python
# Calculate the distinct customer count for each region and select the top 3
top_regions_by_customers = regions.CALCULATE(
    region_name=name,
    distinct_customer_count=NDISTINCT(nations.customers.key)
).TOP_K(3, by=distinct_customer_count.DESC())
```

**Explanation:**

1.  `regions.CALCULATE(...)`: We start with the `regions` collection and use `CALCULATE` to create new fields for each region.
2.  `region_name=name`: We select the name of the region and assign it to the `region_name` field.
3.  `distinct_customer_count=NDISTINCT(nations.customers.key)`: We calculate the number of distinct customers for each region. We navigate from `regions` to `nations` and then to `customers`, and use `NDISTINCT` on the customer `key` to count unique customers. This result is assigned to the `distinct_customer_count` field.
4.  `.TOP_K(3, by=distinct_customer_count.DESC())`: We take the results from `CALCULATE` and select the top 3 regions based on the `distinct_customer_count`, ordering them in descending order (`DESC`) so the region with the most distinct customers is ranked first.","# CALCULATE the distinct customer count for each region and select the top 3
top_regions_by_customers = regions.CALCULATE(
    region_name=name,
    distinct_customer_count=NDISTINCT(nations.customers.key)
).TOP_K(3, by=distinct_customer_count.DESC())",Match,
Find the names of all customers and number of orders placed in 1995 in Europe who have an account balance greater than $700 and placed at least one order in 1995. Sorted in descending order by the number of orders.,"SELECT c.c_name AS customer_name, COUNT(o.o_orderkey) AS order_count_1995 FROM customer c JOIN nation n ON c.c_nationkey = n.n_nationkey JOIN region r ON n.n_regionkey = r.r_regionkey JOIN orders o ON c.c_custkey = o.o_custkey WHERE r.r_name = 'EUROPE' AND c.c_acctbal > 700 AND o.o_orderdate BETWEEN '1995-01-01' AND '1995-12-31' GROUP BY c.c_name, c.c_acctbal ORDER BY order_count_1995 DESC, c.c_acctbal DESC;",,"*   **Function Selection & Justification**:
    *   `customers`: Access the base collection of customers.
    *   `WHERE`: Filter customers based on region (`nation.region.name == ""EUROPE""`), account balance (`acctbal > 700`), and having placed at least one order in 1995 (`order_count_1995 >= 1`).
    *   `CALCULATE`: Compute the number of orders placed in 1995 (`COUNT(orders.WHERE(YEAR(order_date) == 1995))`) and select the customer's name (`name`).
    *   `COUNT`: Aggregate function to count the orders per customer after filtering by year.
    *   `YEAR`: Datetime function to extract the year from the `order_date`.
    *   `ORDER_BY`: Sort the final result based on the calculated number of orders.
    *   `.DESC()`: Specify descending order for the sort.
*   **Partitioning Strategy**:
    *   `PARTITION` is not required. Filtering and aggregation can be performed directly on the `customers` collection and its `orders` sub-collection.
*   **Ranking Considerations**:
    *   `RANKING` is not needed for this query.

```python
european_customers_orders = customers.WHERE(
    (nation.region.name == ""EUROPE"") &  # Filter customers located in Europe
    (acctbal > 700)                     # Filter customers with account balance > $700
).CALCULATE(
    customer_name=name,                 # Select the customer's name
    order_count_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995)) # Calculate the count of orders placed in 1995
).WHERE(
    order_count_1995 >= 1               # Filter for customers who placed at least one order in 1995
).ORDER_BY(
    order_count_1995.DESC()             # Sort results by the number of orders in descending order
)
```

*   **Step-by-Step Explanation**:
    1.  `customers.WHERE(...)`: Start with the `customers` collection and filter it to include only those whose nation is in the ""EUROPE"" region and whose account balance (`acctbal`) is greater than 700.
    2.  `.CALCULATE(...)`: For the filtered customers, calculate two fields:
        *   `customer_name`: Renames the `name` field.
        *   `order_count_1995`: Counts the number of orders associated with each customer (`orders`) but only includes orders where the `YEAR` of the `order_date` is 1995.
    3.  `.WHERE(order_count_1995 >= 1)`: Further filter the results to keep only those customers for whom the calculated `order_count_1995` is greater than or equal to 1 (meaning they placed at least one order in 1995).
    4.  `.ORDER_BY(order_count_1995.DESC())`: Sort the final set of customers in descending order based on their `order_count_1995`.
    5.  The final result stored in `european_customers_orders` contains the `customer_name` and `order_count_1995` for customers meeting all the specified criteria, sorted as requested.","european_customers_orders = customers.WHERE(
    (nation.region.name == ""EUROPE"") &  # Filter customers located in Europe
    (acctbal > 700)                     # Filter customers with account balance > $700
).CALCULATE(
    customer_name=name,                 # Select the customer's name
    order_count_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995)) # CALCULATE the count of orders placed in 1995
).WHERE(
    order_count_1995 >= 1               # Filter for customers who placed at least one order in 1995
).ORDER_BY(
    order_count_1995.DESC()             # Sort results by the number of orders in descending order
)",Match,
"Find suppliers in each nation who have a total availqty of more than 1000 units of parts with 'BRASS' in their type. List the supplier name, nation name, and the sum of the parts supplied.","SELECT s.s_name AS SupplierName, n.n_name AS Nation, SUM(ps.ps_availqty) AS TotalUnitsSupplied FROM supplier s JOIN nation n ON s.s_nationkey = n.n_nationkey JOIN partsupp ps ON s.s_suppkey = ps.ps_suppkey JOIN part p ON ps.ps_partkey = p.p_partkey WHERE p.p_type LIKE '%BRASS%' GROUP BY s.s_name, n.n_name HAVING SUM(ps.ps_availqty) > 1000 ORDER BY TotalUnitsSupplied DESC;",,"Okay, let's break this down.

1.  **Goal:** Find suppliers in each nation whose total available quantity (`availqty`) for parts containing 'BRASS' in their type exceeds 1000. Display supplier name, nation name, and this total quantity.
2.  **Collections:** We need `nations` (for nation name), `suppliers` (for supplier name and linking to supply records), `supply_records` (for `availqty`), and `parts` (for `part_type`).
3.  **Path:** The natural path is `nations` -> `suppliers` -> `supply_records` -> `part`.
4.  **Functions:**
    *   `CALCULATE`: To select/rename fields (`nation_name`, `supplier_name`) and compute the sum.
    *   `SUM`: To aggregate `availqty` for the relevant parts per supplier.
    *   `WHERE`: To filter `supply_records` based on the part type containing 'BRASS' and then to filter the suppliers based on the calculated sum.
    *   `CONTAINS`: To check if `part.part_type` includes 'BRASS'.
5.  **Partitioning:** Not needed. We can achieve the per-nation grouping by starting with `nations` and calculating within the `suppliers` sub-collection context.
6.  **Logic:**
    *   Start from `nations` to get access to each nation's context.
    *   Calculate `nation_name`.
    *   Navigate to `suppliers` within each nation.
    *   For each `supplier`, calculate the sum of `availqty` from their `supply_records`, but only include records where the linked `part.part_type` contains 'BRASS'.
    *   Filter these suppliers to keep only those where the calculated sum is greater than 1000.
    *   Select the final required fields: `supplier_name`, `nation_name`, and the calculated sum.

```python
# Start with nations to access suppliers per nation
nation_level = nations.CALCULATE(
    nation_name=name  # Capture the nation name
)

# Access suppliers within each nation and calculate the sum of brass part quantities
supplier_level = nation_level.suppliers.CALCULATE(
    nation_name=nation_name,  # Carry over nation name from the parent context
    supplier_name=name,       # Get the supplier name
    total_brass_parts_qty=SUM( # Calculate the sum
        # Filter supply records for parts containing 'BRASS' in their type
        supply_records.WHERE(CONTAINS(part.part_type, 'BRASS')).availqty
    )
)

# Filter suppliers where the total quantity of brass parts is greater than 1000
filtered_suppliers = supplier_level.WHERE(total_brass_parts_qty > 1000)

# Select the final required fields
result = filtered_suppliers.CALCULATE(
    supplier_name=supplier_name,
    nation_name=nation_name,
    total_brass_parts_qty=total_brass_parts_qty
)
```

**Explanation:**

1.  `nation_level = nations.CALCULATE(nation_name=name)`: We start with the `nations` collection and use `CALCULATE` to create a field `nation_name` holding the name of each nation.
2.  `supplier_level = nation_level.suppliers.CALCULATE(...)`: We access the `suppliers` sub-collection for each nation. Inside this `CALCULATE`:
    *   `nation_name=nation_name`: We bring the `nation_name` from the parent `nation_level` context into the current supplier record.
    *   `supplier_name=name`: We get the name of the current supplier.
    *   `total_brass_parts_qty=SUM(...)`: We calculate the sum. The `SUM` function aggregates the `availqty` from the `supply_records` sub-collection *after* filtering it using `WHERE(CONTAINS(part.part_type, 'BRASS'))` to only include records linked to parts whose type contains 'BRASS'.
3.  `filtered_suppliers = supplier_level.WHERE(total_brass_parts_qty > 1000)`: We filter the results from the previous step, keeping only those suppliers whose calculated `total_brass_parts_qty` is greater than 1000.
4.  `result = filtered_suppliers.CALCULATE(...)`: Finally, we select only the required output fields: `supplier_name`, `nation_name`, and the calculated `total_brass_parts_qty`.","# Start with nations to access suppliers per nation
nation_level = nations.CALCULATE(
    nation_name=name  # Capture the nation name
)

# Access suppliers within each nation and CALCULATE the SUM of brass part quantities
supplier_level = nation_level.suppliers.CALCULATE(
    nation_name=nation_name,  # Carry over nation name from the parent context
    supplier_name=name,       # Get the supplier name
    total_brass_parts_qty=SUM( # CALCULATE the SUM
        # Filter supply records for parts containing 'BRASS' in their type
        supply_records.WHERE(CONTAINS(part.part_type, 'BRASS')).availqty
    )
)

# Filter suppliers WHERE the total quantity of brass parts is greater than 1000
filtered_suppliers = supplier_level.WHERE(total_brass_parts_qty > 1000)

# Select the final required fields
result = filtered_suppliers.CALCULATE(
    supplier_name=supplier_name,
    nation_name=nation_name,
    total_brass_parts_qty=total_brass_parts_qty
)",Match,
Find parts names that are supplied by at least five different nations. Show the part name and the count of distinct nations that supply each part,"SELECT p.P_NAME AS PartName, COUNT(DISTINCT n.N_NAME) AS NumberOfNations FROM PART p JOIN PARTSUPP ps ON p.P_PARTKEY = ps.PS_PARTKEY JOIN SUPPLIER s ON ps.PS_SUPPKEY = s.S_SUPPKEY JOIN NATION n ON s.S_NATIONKEY = n.N_NATIONKEY GROUP BY p.P_NAME HAVING COUNT(DISTINCT n.N_NAME) > 5 ORDER BY NumberOfNations DESC;",,"*   **Function Selection & Justification**:
    *   `PARTITION`: Required by the prompt to group the `parts` collection by `name`.
    *   `CALCULATE`: Used after `PARTITION` to define the output fields for each partition (part name and the count of distinct nations).
    *   `NDISTINCT`: Required by the prompt and used within `CALCULATE` to count the unique nations associated with the suppliers for each part group.
    *   `WHERE`: Used to filter the results to include only those parts supplied by at least five distinct nations.

*   **Partitioning Strategy**:
    *   Partitioning the `parts` collection by `name` is necessary as requested by the prompt to analyze suppliers on a per-part basis.

*   **Step-by-Step Explanation**:
    1.  `PARTITION(parts, name='part_group', by=name)`: Groups the `parts` collection by the `name` field. Each group, representing a unique part name, is accessible via the alias `part_group`.
    2.  `.CALCULATE(...)`: For each `part_group`:
        *   `part_name=name`: Selects the part name (the partitioning key).
        *   `nation_count=NDISTINCT(part_group.supply_records.supplier.nation.key)`: Calculates the number of distinct nations supplying this part. It navigates from the part group (`part_group`) through its `supply_records`, then to the `supplier` for each record, and finally to the `nation` of each supplier. `NDISTINCT` counts the unique `key` values of these nations.
    3.  `.WHERE(nation_count >= 5)`: Filters these results, keeping only the parts where the `nation_count` is greater than or equal to 5.

```python
parts_by_nation_count = PARTITION(
    parts,
    name='part_group',
    by=name
).CALCULATE(
    part_name=name,
    nation_count=NDISTINCT(part_group.supply_records.supplier.nation.key)
).WHERE(
    nation_count >= 5
)
```","parts_by_nation_count = PARTITION(
    parts,
    name='part_group',
    by=name
).CALCULATE(
    part_name=name,
    nation_count=NDISTINCT(part_group.supply_records.supplier.nation.key)
).WHERE(
    nation_count >= 5
)",Match,
"Which 10 customers purchased the highest quantity of products with 'green' in the product name during 1998? Provide their names, adress and the total quantity ordered.","SELECT c_name AS customer_name, c_address AS customer_address, SUM(l_quantity) AS total_quantity_ordered FROM customer JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey JOIN part ON l_partkey = p_partkey WHERE p_name LIKE '%green%' AND strftime('%Y', o_orderdate) = '1998' GROUP BY c_name, c_address ORDER BY total_quantity_ordered DESC LIMIT 10;",,"Okay, let's break this down.

1.  **Goal**: Find the top 10 customers by the total quantity of 'green' products ordered in 1998. Output their name, address, and the total quantity.
2.  **Collections**: We need `customers`, `orders` (to filter by year), `lines` (to get quantity and link to parts), and `parts` (to filter by name).
3.  **Functions**:
    *   `customers`: Base collection.
    *   `CALCULATE`: To compute the total quantity per customer and select the final fields (name, address, total quantity).
    *   `SUM`: To aggregate the `quantity` from relevant `lines`.
    *   `WHERE`: To filter `orders` by `order_date` (year 1998) and `lines` by `part.name` (containing 'green').
    *   `YEAR`: To extract the year from `order_date`.
    *   `CONTAINS`: To check if `part.name` contains 'green'.
    *   `TOP_K`: To select the top 10 customers based on the calculated total quantity.
4.  **Partitioning**: Not needed. Aggregation can happen directly within `CALCULATE` at the `customers` level.
5.  **Ranking**: `TOP_K` is used for ranking and selection.

```python
# Calculate the total quantity of 'green' parts ordered in 1998 for each customer
top_green_product_customers = customers.CALCULATE(
    # Select customer name and address
    cust_name=name,
    cust_address=address,
    # Calculate the total quantity of parts containing 'green' ordered in 1998
    total_green_quantity=SUM(
        # Access orders placed by the customer
        orders
        # Filter orders placed in 1998
        .WHERE(YEAR(order_date) == 1998)
        # Access line items for those orders
        .lines
        # Filter line items where the part name contains 'green'
        .WHERE(CONTAINS(part.name, 'green'))
        # Access the quantity of the filtered line items
        .quantity
    )
# Select the top 10 customers based on the calculated total quantity in descending order
).TOP_K(10, by=total_green_quantity.DESC())

```

**Explanation:**

1.  We start with the `customers` collection.
2.  We use `CALCULATE` to create new fields for each customer:
    *   `cust_name`: Renames the `name` field.
    *   `cust_address`: Renames the `address` field.
    *   `total_green_quantity`: This calculates the sum of quantities for specific items.
3.  Inside the `SUM` function for `total_green_quantity`:
    *   We access the customer's `orders`.
    *   We filter these `orders` using `WHERE` to keep only those where `YEAR(order_date)` is 1998.
    *   From these filtered orders, we access their `lines`.
    *   We filter these `lines` using `WHERE` to keep only those where the associated `part.name` `CONTAINS` the string 'green'.
    *   We then access the `quantity` field of these filtered lines.
    *   `SUM` aggregates these quantities for the customer.
4.  Finally, `TOP_K(10, by=total_green_quantity.DESC())` selects the 10 customers with the highest `total_green_quantity`, ordered from highest to lowest. The result includes the customer's name, address, and their calculated total quantity.","# CALCULATE the total quantity of 'green' parts ordered in 1998 for each customer
top_green_product_customers = customers.CALCULATE(
    # Select customer name and address
    cust_name=name,
    cust_address=address,
    # CALCULATE the total quantity of parts containing 'green' ordered in 1998
    total_green_quantity=SUM(
        # Access orders placed by the customer
        orders
        # Filter orders placed in 1998
        .WHERE(YEAR(order_date) == 1998)
        # Access line items for those orders
        .lines
        # Filter line items WHERE the part name CONTAINS 'green'
        .WHERE(CONTAINS(part.name, 'green'))
        # Access the quantity of the filtered line items
        .quantity
    )
# Select the top 10 customers based on the calculated total quantity in descending order
).TOP_K(10, by=total_green_quantity.DESC())",Match,
Which is the average discount applied on orders for each market segment? Sorted in descending order,"SELECT c_mktsegment AS market_segment, AVG(l_discount) AS average_discount FROM customer JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey GROUP BY c_mktsegment;","1. Average shipping delay by supplier:
```python
avg_shipping_delay_by_supplier = suppliers.CALCULATE(
    supplier_name=name,
    average_shipping_delay=AVG(lines.ship_date - lines.commit_date)
)
```
2. Average price by part size:
```python
avg_price_by_part_size = GROUP_BY(
    parts,
    name= ""part"",
 by=(part_size)
).CALCULATE(
 part_size= part_size,
 average_retail_price= AVG(part.retail_price)
)```","Okay, let's break this down.

1.  **Goal:** Calculate the average discount per market segment and sort the results.
2.  **Collections:** We need `customers` (for `mktsegment`) and `lines` (for `discount`), accessed via `customers.orders.lines`.
3.  **Grouping:** We need to group by `mktsegment`. `PARTITION` is the appropriate function for grouping.
4.  **Aggregation:** Within each group (market segment), we need the average (`AVG`) of the `discount` from the associated order lines.
5.  **Sorting:** The final result needs to be sorted by the calculated average discount in descending order (`ORDER_BY` with `.DESC()`).

**PyDough Code:**

```python
# Partition customers by market segment
avg_discount_by_segment = PARTITION(
    customers,  # Collection to partition
    name='segment_group',  # Name for the partition group
    by=mktsegment  # Field to partition by
).CALCULATE(
    # Select the market segment (partition key)
    market_segment=mktsegment,
    # Calculate the average discount for all lines within this segment's customer orders
    average_discount=AVG(segment_group.orders.lines.discount)
).ORDER_BY(
    # Sort by the calculated average discount in descending order
    average_discount.DESC()
)
```

**Explanation:**

1.  `PARTITION(customers, name='segment_group', by=mktsegment)`: This groups all records in the `customers` collection based on their `mktsegment` value. Each group is accessible via the name `segment_group`.
2.  `.CALCULATE(...)`: This operates on each partition group created in the previous step.
    *   `market_segment=mktsegment`: Selects the market segment value for the current group. Since `mktsegment` is the partitioning key, we refer to it directly.
    *   `average_discount=AVG(segment_group.orders.lines.discount)`: Calculates the average discount. We use `segment_group` to access the customers within the current partition, then navigate through their `orders` and `lines` to get the `discount` values. `AVG` aggregates these discounts across all lines for all customers in the segment.
3.  `.ORDER_BY(average_discount.DESC())`: Sorts the resulting collection (which contains one row per market segment) based on the `average_discount` field in descending order.","# PARTITION customers by market segment
avg_discount_by_segment = PARTITION(
    customers,  # Collection to PARTITION
    name='segment_group',  # Name for the PARTITION group
    by=mktsegment  # Field to PARTITION by
).CALCULATE(
    # Select the market segment (PARTITION key)
    market_segment=mktsegment,
    # CALCULATE the average discount for all lines within this segment's customer orders
    average_discount=AVG(segment_group.orders.lines.discount)
).ORDER_BY(
    # Sort by the calculated average discount in descending order
    average_discount.DESC()
)",Match,
What were the 20 most popular products (parts) within each market segment in 1998?,"WITH ProductPopularity AS (SELECT c_mktsegment AS market_segment, p_name AS product_name, SUM(l_quantity) AS total_quantity FROM customer JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey JOIN part ON l_partkey = p_partkey WHERE strftime('%Y', o_orderdate) = '1998' GROUP BY c_mktsegment, p_name) SELECT market_segment, product_name, total_quantity FROM (SELECT market_segment, product_name, total_quantity, ROW_NUMBER() OVER (PARTITION BY market_segment ORDER BY total_quantity DESC) AS rank FROM ProductPopularity) WHERE rank <= 20;",,"Okay, let's break this down.

1.  **Goal**: Find the top 20 most ordered products within each market segment for orders placed in 1998.
2.  **Data Needed**: We need information from `lines` (for order details and links), `orders` (for date and customer link), `customers` (for market segment), and `parts` (for product name).
3.  **Filtering**: We only care about orders from 1998. This requires filtering `lines` based on `lines.order.order_date`.
4.  **Grouping**: We need to group by `mktsegment` (from `lines.order.customer`) and `part_name` (from `lines.part`) to count orders for each product within each segment. `PARTITION` is the tool for this.
5.  **Aggregation**: We need to count the number of lines (representing orders for a specific product) within each group using `COUNT`.
6.  **Ranking**: After counting, we need to rank the products within each `mktsegment` based on their `order_count`. `RANKING` with `levels=1` is appropriate here to rank within the segment.
7.  **Filtering Top K**: We need to filter the ranked results to keep only those with a rank <= 20 using `WHERE`.
8.  **Selection**: Finally, select the required fields: `mktsegment`, `part_name`, and `order_count`.

**Function Selection Justification:**

*   `WHERE`: To filter the `lines` collection for orders placed in the year 1998 using `YEAR(order.order_date) == 1998`.
*   `CALCULATE`:
    *   Initially, to extract `mktsegment` and `part_name` from related collections (`order.customer.mktsegment`, `part.name`).
    *   After `PARTITION`, to compute the `order_count` using `COUNT(partition_group_name)`.
    *   After calculating counts, to compute the `rank_in_segment` using `RANKING(by=order_count.DESC(), levels=1)`.
    *   Finally, to select the desired output columns (`mktsegment`, `part_name`, `order_count`).
*   `PARTITION`: To group the filtered `lines` data by both `mktsegment` and `part_name`. This creates groups where each group represents a unique product within a unique market segment for the year 1998. The `by=(mktsegment, part_name)` keys define these groups.
*   `COUNT`: To aggregate the number of line items within each partition group (`spg`), effectively counting the orders for that specific product in that segment in 1998.
*   `RANKING`: To assign a rank to each product within its market segment based on the calculated `order_count`. `by=order_count.DESC()` ensures higher counts get lower ranks (rank 1 is highest). `levels=1` ensures ranking is performed independently for each `mktsegment`.
*   `YEAR`: To extract the year from the `order_date`.

```python
# 1. Filter lines for 1998 and calculate necessary segment and part information.
lines_1998_data = lines.WHERE(YEAR(order.order_date) == 1998).CALCULATE(
    mktsegment=order.customer.mktsegment,
    part_name=part.name
)

# 2. Partition by market segment and part name to create groups for counting.
segment_part_groups = PARTITION(
    lines_1998_data,
    name='spg', # Name for the partition group collection
    by=(mktsegment, part_name)
)

# 3. Calculate the order count for each product within each segment.
segment_part_counts = segment_part_groups.CALCULATE(
    mktsegment=mktsegment,       # Keep the market segment key
    part_name=part_name,         # Keep the part name key
    order_count=COUNT(spg)       # Count lines in the partition group
)

# 4. Calculate the rank for each part within its market segment based on order count.
#    levels=1 ensures ranking is done per mktsegment.
ranked_parts_in_segment = segment_part_counts.CALCULATE(
    mktsegment=mktsegment,
    part_name=part_name,
    order_count=order_count,
    rank_in_segment=RANKING(by=order_count.DESC(), levels=1)
)

# 5. Filter to keep only the top 20 ranked products per segment.
top_20_per_segment = ranked_parts_in_segment.WHERE(rank_in_segment <= 20)

# 6. Select the final required fields: market segment, product name, and order count.
#    Optionally order the results for clarity.
result = top_20_per_segment.CALCULATE(
    mktsegment=mktsegment,
    part_name=part_name,
    order_count=order_count
).ORDER_BY(mktsegment.ASC(), order_count.DESC())
```

**Explanation:**

1.  `lines_1998_data`: Filters the `lines` collection to include only those associated with orders placed in 1998. It then calculates and adds the `mktsegment` (from the customer associated with the order) and the `part_name` (from the part associated with the line) to each record.
2.  `segment_part_groups`: Takes the filtered data and partitions it. It creates groups based on unique combinations of `mktsegment` and `part_name`. The collection within each partition group is accessible via the name `spg`.
3.  `segment_part_counts`: Operates on the result of the partition. For each unique `(mktsegment, part_name)` group, it calculates the total number of records within that group using `COUNT(spg)`, naming this count `order_count`. It retains the `mktsegment` and `part_name` keys.
4.  `ranked_parts_in_segment`: Takes the counts per product/segment and calculates a rank (`rank_in_segment`) for each product. The `RANKING` function orders products by `order_count` descending (`DESC`) and crucially uses `levels=1` to ensure the ranking is performed *within* each `mktsegment` independently.
5.  `top_20_per_segment`: Filters the ranked results, keeping only the rows where `rank_in_segment` is 20 or less.
6.  `result`: Selects only the final required columns (`mktsegment`, `part_name`, `order_count`) from the filtered top 20 results and orders them first by market segment and then by order count descending for readability.","# 1. Filter lines for 1998 and CALCULATE necessary segment and part information.
lines_1998_data = lines.WHERE(YEAR(order.order_date) == 1998).CALCULATE(
    mktsegment=order.customer.mktsegment,
    part_name=part.name
)

# 2. PARTITION by market segment and part name to create groups for counting.
segment_part_groups = PARTITION(
    lines_1998_data,
    name='spg', # Name for the PARTITION group collection
    by=(mktsegment, part_name)
)

# 3. CALCULATE the order count for each product within each segment.
segment_part_counts = segment_part_groups.CALCULATE(
    mktsegment=mktsegment,       # Keep the market segment key
    part_name=part_name,         # Keep the part name key
    order_count=COUNT(spg)       # Count lines in the PARTITION group
)

# 4. CALCULATE the rank for each part within its market segment based on order count.
#    levels=1 ensures RANKING is done per mktsegment.
ranked_parts_in_segment = segment_part_counts.CALCULATE(
    mktsegment=mktsegment,
    part_name=part_name,
    order_count=order_count,
    rank_in_segment=RANKING(by=order_count.DESC(), levels=1)
)

# 5. Filter to keep only the top 20 ranked products per segment.
top_20_per_segment = ranked_parts_in_segment.WHERE(rank_in_segment <= 20)

# 6. Select the final required fields: market segment, product name, and order count.
#    Optionally order the results for clarity.
result = top_20_per_segment.CALCULATE(
    mktsegment=mktsegment,
    part_name=part_name,
    order_count=order_count
).ORDER_BY(mktsegment.ASC(), order_count.DESC())",No Match,
Retrieves the top 3 suppliers with the highest total sales for each region,"WITH SupplierSales AS (SELECT r_name AS region_name, s_name AS supplier_name, SUM(l_extendedprice * l_quantity) AS total_sales FROM region JOIN nation ON r_regionkey = n_regionkey JOIN supplier ON n_nationkey = s_nationkey JOIN lineitem ON s_suppkey = l_suppkey JOIN orders ON l_orderkey = o_orderkey GROUP BY r_name, s_name) SELECT region_name, supplier_name, total_sales FROM (SELECT region_name, supplier_name, total_sales, ROW_NUMBER() OVER (PARTITION BY region_name ORDER BY total_sales DESC) AS rank FROM SupplierSales) WHERE rank <= 3;",,"*   **Function Selection & Justification**:
    *   `regions.nations.suppliers`: To access suppliers grouped by region and nation.
    *   `CALCULATE`: To compute the `total_sales` for each supplier, bring the `region_name` and `supplier_name` into the context, and calculate the rank.
    *   `SUM`: To aggregate the sales from line items for each supplier. The calculation `extended_price * quantity` needs an inner `CALCULATE` as per the rules.
    *   `RANKING`: To rank suppliers within each region based on `total_sales`. `levels=2` is used because we are accessing suppliers via `regions.nations.suppliers`, and we want to rank within the grandparent collection (`regions`).
    *   `WHERE`: To filter the results to include only the top 3 suppliers (rank <= 3).
    *   `ORDER_BY`: To sort the final output for better readability (optional but good practice).

*   **Partitioning Strategy**: `PARTITION` is not explicitly needed here because the ranking is handled hierarchically using `RANKING` with the `levels` parameter, effectively partitioning the ranking by region.

*   **Ranking Considerations**: The ranking needs to be performed at the supplier level (`regions.nations.suppliers`) relative to other suppliers within the same region (`levels=2`).

```python
# Calculate total sales for each supplier and rank them within their region
ranked_suppliers = regions.nations.suppliers.CALCULATE(
    region_name=nation.region.name,  # Access region name via nation's region
    supplier_name=name,
    # Calculate total sales: SUM(extended_price * quantity) for each supplier's lines
    total_sales=SUM(lines.CALCULATE(line_total=extended_price * quantity).line_total)
).CALCULATE(
    region_name=region_name,
    supplier_name=supplier_name,
    total_sales=total_sales,
    # Rank suppliers within each region (levels=2 corresponds to regions)
    rank_in_region=RANKING(by=total_sales.DESC(), levels=2)
)

# Filter for the top 3 suppliers in each region
top_3_suppliers_by_region = ranked_suppliers.WHERE(
    rank_in_region <= 3
).CALCULATE(
    # Select the required fields
    region_name=region_name,
    supplier_name=supplier_name,
    total_sales=total_sales
).ORDER_BY(
    # Order by region name ascending, then by total sales descending
    region_name.ASC(),
    total_sales.DESC()
)

result = top_3_suppliers_by_region
```

*   **Step-by-Step Explanation**:
    1.  The query starts from the `regions` collection and navigates through `nations` to `suppliers`.
    2.  The first `CALCULATE` computes `total_sales` for each supplier by summing the product of `extended_price` and `quantity` for all associated `lines`. It also brings the `region_name` (accessed via `nation.region.name`) and `supplier_name` into the current context.
    3.  The second `CALCULATE` computes the `rank_in_region` for each supplier using the `RANKING` function. The ranking is based on `total_sales` in descending order (`DESC`) and is performed within each region (`levels=2`).
    4.  The `WHERE` clause filters these ranked suppliers, keeping only those whose `rank_in_region` is less than or equal to 3 (the top 3).
    5.  The final `CALCULATE` selects only the required output fields: `region_name`, `supplier_name`, and `total_sales`.
    6.  `ORDER_BY` sorts the final result first by region name alphabetically and then by total sales in descending order within each region.
    7.  The final result is assigned to the `result` variable.","# CALCULATE total sales for each supplier and rank them within their region
ranked_suppliers = regions.nations.suppliers.CALCULATE(
    region_name=nation.region.name,  # Access region name via nation's region
    supplier_name=name,
    # CALCULATE total sales: SUM(extended_price * quantity) for each supplier's lines
    total_sales=SUM(lines.CALCULATE(line_total=extended_price * quantity).line_total)
).CALCULATE(
    region_name=region_name,
    supplier_name=supplier_name,
    total_sales=total_sales,
    # Rank suppliers within each region (levels=2 corresponds to regions)
    rank_in_region=RANKING(by=total_sales.DESC(), levels=2)
)

# Filter for the top 3 suppliers in each region
top_3_suppliers_by_region = ranked_suppliers.WHERE(
    rank_in_region <= 3
).CALCULATE(
    # Select the required fields
    region_name=region_name,
    supplier_name=supplier_name,
    total_sales=total_sales
).ORDER_BY(
    # Order by region name ascending, then by total sales descending
    region_name.ASC(),
    total_sales.DESC()
)

result = top_3_suppliers_by_region",Match,
"For each European country, list the number of customers and the number of orders they placed in 1995, including customers who didn't place any orders that year.","SELECT n_name AS country_name, COUNT(DISTINCT c_custkey) AS total_customers, COUNT(DISTINCT CASE WHEN o_orderdate >= '1995-01-01' AND o_orderdate <= '1995-12-31' THEN o_orderkey END) AS total_orders_1995 FROM nation JOIN region ON n_regionkey = r_regionkey JOIN customer ON n_nationkey = c_nationkey LEFT JOIN orders ON c_custkey = o_custkey WHERE r_name = 'EUROPE' GROUP BY n_name;",,"Okay, let's break this down.

1.  **Goal**: Get customer count and 1995 order count for each European nation.
2.  **Collections**: We need `nations`, `customers`, and `orders`.
3.  **Filtering**: We need to filter `nations` to only include those where `region.name` is ""EUROPE"".
4.  **Calculations**: For each filtered nation, we need:
    *   The nation's `name`.
    *   The total count of `customers` associated with that nation (`COUNT(customers)`).
    *   The count of `orders` placed by those customers *only* in 1995. This involves accessing `customers.orders`, filtering by `YEAR(order_date) == 1995`, and then counting the resulting orders (`COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))`).
5.  **Function**: `CALCULATE` is suitable for performing these calculations per nation after filtering.

```python
# Filter nations to include only those in Europe
european_nations = nations.WHERE(region.name == ""EUROPE"")

# Calculate the required counts for each European nation
european_nation_stats = european_nations.CALCULATE(
    nation_name=name,
    customer_count=COUNT(customers),
    orders_1995_count=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))
)
```

**Explanation:**

1.  `nations.WHERE(region.name == ""EUROPE"")`: This selects only the nations belonging to the ""EUROPE"" region.
2.  `.CALCULATE(...)`: This function operates on each selected European nation.
3.  `nation_name=name`: Selects the name of the nation.
4.  `customer_count=COUNT(customers)`: Counts all customers associated with the current nation. This includes customers regardless of whether they placed orders in 1995.
5.  `orders_1995_count=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))`: This accesses the orders for all customers within the current nation, filters those orders to keep only the ones placed in 1995 (`YEAR(order_date) == 1995`), and then counts the remaining orders. If a nation's customers placed no orders in 1995, this count will correctly be zero.","# Filter nations to include only those in Europe
european_nations = nations.WHERE(region.name == ""EUROPE"")

# CALCULATE the required counts for each European nation
european_nation_stats = european_nations.CALCULATE(
    nation_name=name,
    customer_count=COUNT(customers),
    orders_1995_count=COUNT(customers.orders.WHERE(YEAR(order_date) == 1995))
)",Match,
Retrieve the customer name of the customers who placed more orders in 1995 than in 1994,"SELECT c_name AS customer_name FROM customer JOIN orders ON c_custkey = o_custkey WHERE (strftime('%Y', o_orderdate) = '1994' OR strftime('%Y', o_orderdate) = '1995') GROUP BY c_custkey, c_name HAVING SUM(CASE WHEN strftime('%Y', o_orderdate) = '1995' THEN 1 ELSE 0 END) > SUM(CASE WHEN strftime('%Y', o_orderdate) = '1994' THEN 1 ELSE 0 END);",,"Okay, let's break this down.

1.  **Goal**: Find customers who had more orders in 1995 than in 1994.
2.  **Collections**: We need the `customers` collection and their associated `orders`.
3.  **Logic**:
    *   For each customer, we need to count their orders in 1994.
    *   For each customer, we need to count their orders in 1995.
    *   We then filter the customers where the 1995 count is strictly greater than the 1994 count.
    *   Finally, we select only the customer's name.
4.  **PyDough Functions**:
    *   `customers`: To start with the customer data.
    *   `CALCULATE`: To compute the order counts for each year and to select the final name.
    *   `COUNT`: To count the orders within the `CALCULATE`.
    *   `WHERE`: To filter the orders by year inside the `COUNT` and to filter the customers based on the comparison of counts.
    *   `YEAR`: To extract the year from the `order_date`.

```python
# Calculate the number of orders for each customer in 1994 and 1995
customer_order_comparison = customers.CALCULATE(
    cust_name=name,
    orders_count_1994=COUNT(orders.WHERE(YEAR(order_date) == 1994)),
    orders_count_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))
)

# Filter customers where the order count in 1995 is greater than in 1994
filtered_customers = customer_order_comparison.WHERE(orders_count_1995 > orders_count_1994)

# Select only the customer name
result = filtered_customers.CALCULATE(customer_name=cust_name)
```

**Explanation:**

1.  `customer_order_comparison = customers.CALCULATE(...)`: We start with the `customers` collection. Inside `CALCULATE`, we compute two new fields for each customer:
    *   `orders_count_1994`: Counts the orders associated with the customer (`orders`) but only includes those where the `YEAR` of the `order_date` is 1994.
    *   `orders_count_1995`: Similarly, counts the orders for the year 1995.
    *   We also keep the customer's `name` and assign it to `cust_name`.
2.  `filtered_customers = customer_order_comparison.WHERE(...)`: We filter the results from the previous step. The `WHERE` clause keeps only those rows (customers) where the calculated `orders_count_1995` is greater than `orders_count_1994`.
3.  `result = filtered_customers.CALCULATE(customer_name=cust_name)`: Finally, we select only the `cust_name` field from the filtered customers and rename it to `customer_name` as requested in the output description.","# CALCULATE the number of orders for each customer in 1994 and 1995
customer_order_comparison = customers.CALCULATE(
    cust_name=name,
    orders_count_1994=COUNT(orders.WHERE(YEAR(order_date) == 1994)),
    orders_count_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))
)

# Filter customers WHERE the order count in 1995 is greater than in 1994
filtered_customers = customer_order_comparison.WHERE(orders_count_1995 > orders_count_1994)

# Select only the customer name
result = filtered_customers.CALCULATE(customer_name=cust_name)",Match,
Which is the average order value per Nation? List the nation name and average order value. The order value is defined as extended_price * quantity,"SELECT n_name AS nation_name, AVG(l_extendedprice * l_quantity) AS average_order_value FROM nation JOIN customer ON n_nationkey = c_nationkey JOIN orders ON c_custkey = o_custkey JOIN lineitem ON o_orderkey = l_orderkey GROUP BY n_name;",,"*   **Function Selection & Justification**:
    *   `nations.CALCULATE`: Used as the primary operation to iterate through each nation and compute aggregated values. This implicitly groups the results by nation, fulfilling the ""per Nation"" requirement.
    *   `SUM`: Required to aggregate the total value across all relevant line items within each nation. It operates on the result of the inner `CALCULATE`.
    *   `COUNT`: Needed to count the total number of orders within each nation, which is necessary to calculate the average order value.
    *   Nested `CALCULATE`: Necessary on the `lines` sub-collection (`customers.orders.lines`) to compute `line_value = extended_price * quantity` for each line item *before* the `SUM` aggregation. This adheres to the rule that calculations involving multiple fields from the same sub-collection must be done within a `CALCULATE` before aggregation. The original request defines ""order value"" based on this line-level calculation.
    *   `IFF`: Used to handle potential division by zero if a nation has no orders, returning 0.0 in that case for the average value.
    *   Second `CALCULATE`: Used to compute the final `average_order_value` by dividing the total value by the order count, referencing the fields computed in the first `CALCULATE`. This separation is necessary because fields defined in a `CALCULATE` are not available until after it completes.

*   **Code Generation**:
    ```python
    # Calculate the average order value for each nation.
    # Order value is defined based on the sum of (extended_price * quantity) for its lines.
    # Average order value per nation = (Sum of values of all lines for the nation) / (Total number of orders for the nation)
    nation_avg_order_value = nations.CALCULATE(
        nation_name=name,
        # Calculate the sum of (extended_price * quantity) for all lines across all orders for all customers in this nation.
        total_value_all_lines = SUM(
            customers.orders.lines.CALCULATE(
                line_value=extended_price * quantity
            ).line_value
        ),
        # Count the total number of orders for all customers in this nation.
        order_count = COUNT(customers.orders)
    ).CALCULATE(
        # Select the nation name.
        nation_name=nation_name,
        # Calculate the average order value, handling cases where a nation might have zero orders.
        average_order_value = IFF(order_count > 0, total_value_all_lines / order_count, 0.0)
    )
    ```

*   **Step-by-Step Explanation**:
    1.  `nations.CALCULATE(...)`: Starts the operation at the `nations` collection level. For each nation, it calculates intermediate values.
    2.  `nation_name=name`: Selects the name of the current nation.
    3.  `total_value_all_lines = SUM(...)`: Calculates the total value sum derived from all line items associated with the current nation.
        *   `customers.orders.lines`: Accesses all line items for all orders placed by customers belonging to the current nation.
        *   `.CALCULATE(line_value=extended_price * quantity)`: For each individual line item, calculates its value (`line_value`) by multiplying `extended_price` and `quantity`.
        *   `.line_value`: Selects the calculated `line_value` from the inner calculation.
        *   `SUM(...)`: Sums up all the calculated `line_value`s across all relevant lines for the nation.
    4.  `order_count = COUNT(customers.orders)`: Counts the total number of orders placed by customers belonging to the current nation.
    5.  `.CALCULATE(...)`: Performs a second calculation using the results (`total_value_all_lines`, `order_count`, `nation_name`) from the first `CALCULATE`.
    6.  `nation_name=nation_name`: Passes the nation name through to the final result set.
    7.  `average_order_value = IFF(order_count > 0, total_value_all_lines / order_count, 0.0)`: Calculates the final average order value. It divides the `total_value_all_lines` by the `order_count`. The `IFF` function ensures that if a nation has zero orders (`order_count` is 0), the average is set to 0.0, preventing a division-by-zero error.
    8.  The final result `nation_avg_order_value` is a collection where each record represents a nation and contains the `nation_name` and its corresponding `average_order_value`.",,Unknown,
What 3 product brands saw the largest positive change in quantity sold from 1995 to 1996.,"WITH sales_1995 AS (
    SELECT
        p.p_brand,
        SUM(l.l_quantity) as total_quantity
    FROM
        lineitem l
    JOIN
        part p ON l.l_partkey = p.p_partkey
    JOIN
        orders o ON l.l_orderkey = o.o_orderkey
    WHERE
        strftime('%Y', o.o_orderdate) = '1995'
    GROUP BY
        p.p_brand
),

sales_1996 AS (
    SELECT
        p.p_brand,
        SUM(l.l_quantity) as total_quantity
    FROM
        lineitem l
    JOIN
        part p ON l.l_partkey = p.p_partkey
    JOIN
        orders o ON l.l_orderkey = o.o_orderkey
    WHERE
        strftime('%Y', o.o_orderdate) = '1996'
    GROUP BY
        p.p_brand
)

SELECT
    s96.p_brand as brand,
    COALESCE(s95.total_quantity, 0) as qty_1995,
    s96.total_quantity as qty_1996,
    (s96.total_quantity - COALESCE(s95.total_quantity, 0)) as quantity_change
FROM
    sales_1996 s96
LEFT JOIN
    sales_1995 s95 ON s96.p_brand = s95.p_brand
WHERE
    (s96.total_quantity - COALESCE(s95.total_quantity, 0)) > 0
ORDER BY
    quantity_change DESC
LIMIT 3;",,"Okay, let's break this down.

1.  **Analyze the Input**:
    *   We need data from the `lines` collection.
    *   We need the `brand` from the related `parts` collection (`lines.part.brand`).
    *   We need the `order_date` from the related `orders` collection (`lines.order.order_date`) to filter by year (1995 and 1996).
    *   We need the `quantity` from the `lines` collection.
    *   We need to group the data by `brand`.
    *   We need to calculate the sum of `quantity` for each brand specifically for 1995 and 1996.
    *   We need to calculate the difference between the 1996 quantity and the 1995 quantity.
    *   We need to find the top 3 brands based on this difference, sorted in descending order.
    *   The final output should include the brand name, quantity sold in 1995, quantity sold in 1996, and the calculated difference.

2.  **Function Selection & Justification**:
    *   `lines.CALCULATE`: To access related fields (`part.brand`, `order.order_date`) and rename/select `quantity`.
    *   `YEAR()`: To extract the year from `order.order_date`.
    *   `.WHERE()`: To filter the lines for the years 1995 and 1996 using `ISIN`.
    *   `PARTITION()`: To group the filtered lines by `brand`. This is necessary because we need to perform calculations (sum of quantity per year) within each brand group.
    *   `SUM()`: To aggregate the `quantity` within each partition group.
    *   `KEEP_IF()`: To conditionally sum quantities based on the year (1995 or 1996) within each brand partition.
    *   `DEFAULT_TO()`: To handle cases where a brand might have sales in one year but not the other, ensuring the difference calculation doesn't fail due to nulls. We default missing year quantities to 0.
    *   `.CALCULATE`: Used multiple times: first after `PARTITION` to calculate yearly sums, then again to calculate the difference using the results of the first `CALCULATE`.
    *   `.TOP_K()`: To select the top 3 brands based on the calculated `difference`, ordered descendingly.

3.  **Partitioning Strategy**:
    *   Partitioning is necessary to group sales data by brand before calculating yearly totals and the difference.
    *   We will partition the pre-filtered and calculated `lines` data by the `brand_name`.

4.  **Ranking Considerations**:
    *   `RANKING` is not needed here; `TOP_K` is sufficient for selecting the top 3 based on the calculated difference.

5.  **Code Generation**:

```python
# Step 1: Filter lines for 1995 and 1996, calculating necessary fields
lines_filtered_by_year = lines.CALCULATE(
    brand_name=part.brand,
    order_year=YEAR(order.order_date),
    line_quantity=quantity
).WHERE(ISIN(order_year, (1995, 1996)))

# Step 2: Partition by brand
partitioned_by_brand = PARTITION(lines_filtered_by_year, name='brand_group', by=brand_name)

# Step 3: Calculate total quantity for 1995 and 1996 within each brand partition
brand_yearly_sales = partitioned_by_brand.CALCULATE(
    brand=brand_name,
    # Sum quantity only if the year is 1995 within the brand group
    qty_1995=SUM(KEEP_IF(brand_group.line_quantity, brand_group.order_year == 1995)),
    # Sum quantity only if the year is 1996 within the brand group
    qty_1996=SUM(KEEP_IF(brand_group.line_quantity, brand_group.order_year == 1996))
)

# Step 4: Handle potential nulls (if no sales in a year) and calculate the difference
brand_sales_difference = brand_yearly_sales.CALCULATE(
    brand=brand,
    # Default to 0 if no sales were found for the year
    quantity_1995=DEFAULT_TO(qty_1995, 0),
    quantity_1996=DEFAULT_TO(qty_1996, 0)
).CALCULATE( # Second CALCULATE needed to use the defaulted values
    brand=brand,
    quantity_1995=quantity_1995,
    quantity_1996=quantity_1996,
    difference=quantity_1996 - quantity_1995
)

# Step 5: Select the top 3 brands with the largest positive difference
top_brands_by_difference = brand_sales_difference.TOP_K(3, by=difference.DESC())

# Assign the final result to a variable
result = top_brands_by_difference
```

6.  **Step-by-Step Explanation**:
    1.  `lines_filtered_by_year`: We start with the `lines` collection. We use `CALCULATE` to bring in the `brand` from the related `part` (`part.brand` aliased as `brand_name`), extract the `order_year` from the related `order` (`YEAR(order.order_date)`), and select the `quantity` (aliased as `line_quantity`). Then, we `.WHERE` to keep only the lines where the `order_year` is either 1995 or 1996 using `ISIN`.
    2.  `partitioned_by_brand`: We use the `PARTITION` function on the filtered data (`lines_filtered_by_year`). We group by `brand_name` and name the resulting groups `brand_group`.
    3.  `brand_yearly_sales`: We apply `CALCULATE` to the partitioned data. For each partition (i.e., for each `brand`), we calculate `qty_1995` by summing `brand_group.line_quantity` only where `brand_group.order_year` is 1995 (using `SUM(KEEP_IF(...))`). We do the same for `qty_1996`. We also select the `brand` itself (using `brand_name` which was the partition key).
    4.  `brand_sales_difference`: We apply another `CALCULATE` to handle cases where a brand might not have sales in 1995 or 1996. `DEFAULT_TO(qty_1995, 0)` ensures that if `qty_1995` is null (no sales in 1995), we use 0 instead. We do the same for `qty_1996`. A subsequent `CALCULATE` is used to compute the `difference` between the (potentially defaulted) `quantity_1996` and `quantity_1995`. We also pass through the `brand`, `quantity_1995`, and `quantity_1996` fields.
    5.  `top_brands_by_difference`: We use `.TOP_K(3, by=difference.DESC())` on the result to select the 3 rows (brands) with the highest `difference` value, sorting them in descending order.
    6.  `result`: The final result containing the top 3 brands with their 1995 quantity, 1996 quantity, and the difference is assigned to the `result` variable.","# Step 1: Filter lines for 1995 and 1996, calculating necessary fields
lines_filtered_by_year = lines.CALCULATE(
    brand_name=part.brand,
    order_year=YEAR(order.order_date),
    line_quantity=quantity
).WHERE(ISIN(order_year, (1995, 1996)))

# Step 2: PARTITION by brand
partitioned_by_brand = PARTITION(lines_filtered_by_year, name='brand_group', by=brand_name)

# Step 3: CALCULATE total quantity for 1995 and 1996 within each brand PARTITION
brand_yearly_sales = partitioned_by_brand.CALCULATE(
    brand=brand_name,
    # SUM quantity only if the year is 1995 within the brand group
    qty_1995=SUM(KEEP_IF(brand_group.line_quantity, brand_group.order_year == 1995)),
    # SUM quantity only if the year is 1996 within the brand group
    qty_1996=SUM(KEEP_IF(brand_group.line_quantity, brand_group.order_year == 1996))
)

# Step 4: Handle potential nulls (if no sales in a year) and CALCULATE the difference
brand_sales_difference = brand_yearly_sales.CALCULATE(
    brand=brand,
    # Default to 0 if no sales were found for the year
    quantity_1995=DEFAULT_TO(qty_1995, 0),
    quantity_1996=DEFAULT_TO(qty_1996, 0)
).CALCULATE( # SECOND CALCULATE needed to use the defaulted values
    brand=brand,
    quantity_1995=quantity_1995,
    quantity_1996=quantity_1996,
    difference=quantity_1996 - quantity_1995
)

# Step 5: Select the top 3 brands with the largest positive difference
top_brands_by_difference = brand_sales_difference.TOP_K(3, by=difference.DESC())

# Assign the final result to a variable
result = top_brands_by_difference",Match,
"What is the total revenue generated by each customer in 1994? Sorted by total revenue in descending order. The total revenue value is defined as the sum of extended_price * (1 - discount) What is the total revenue generated by each customer in 1994? The total revenue value is defined as the sum of extended_price * (1 - discount). Return the customer key, customer name and total revenue","SELECT c.c_custkey AS custkey, c.c_name AS cust_name, COALESCE(SUM(l.l_extendedprice * (1 - l.l_discount)), 0) AS total_revenue FROM customer c LEFT JOIN orders o ON c.c_custkey = o.o_custkey AND strftime('%Y', o.o_orderdate) = '1994' LEFT JOIN lineitem l ON o.o_orderkey = l.l_orderkey GROUP BY c.c_custkey ORDER BY total_revenue DESC;",,"Okay, let's break this down.

1.  **Goal:** Calculate the total revenue for each customer in 1994, defined as the sum of `extended_price * (1 - discount)` for their order lines in that year. Return customer key, name, and total revenue, sorted descending by revenue.
2.  **Collections:** We need `customers`, their `orders`, and the `lines` within those orders.
3.  **Filtering:** We need to filter `orders` to only include those where `YEAR(order_date) == 1994`.
4.  **Calculation:** For each relevant `line`, we need to calculate `extended_price * (1 - discount)`. This requires a `CALCULATE` on the `lines` collection.
5.  **Aggregation:** We need to `SUM` the calculated line revenues for each customer's 1994 orders. This aggregation happens at the `customers` level.
6.  **Selection:** We need to select the customer's `key`, `name`, and the calculated total revenue. This is done using `CALCULATE` on the `customers` collection.
7.  **Sorting:** The final result needs to be sorted using `ORDER_BY` based on the calculated total revenue in descending order.

**Function Selection:**

*   `customers`: To start the query from the customer level.
*   `CALCULATE`: To compute the revenue per line item (`extended_price * (1 - discount)`), and again at the customer level to define the final output fields (`cust_key`, `cust_name`, `total_revenue_1994`).
*   `WHERE`: To filter `orders` based on the year (`YEAR(order_date) == 1994`).
*   `SUM`: To aggregate the calculated revenue from the filtered lines for each customer.
*   `YEAR`: To extract the year from `order_date`.
*   `ORDER_BY`: To sort the final results by the calculated total revenue.
*   `DESC`: To specify descending order for sorting.

**Partitioning Strategy:**

`PARTITION` is not needed here. We are aggregating results per customer, which can be achieved directly by starting the query from the `customers` collection and using `SUM` within a `CALCULATE` clause.

```python
# Calculate total revenue per customer for orders placed in 1994
customer_revenue_1994 = customers.CALCULATE(
    # Select customer key
    cust_key=key,
    # Select customer name
    cust_name=name,
    # Calculate total revenue by summing line revenues for 1994 orders
    total_revenue_1994=SUM(
        # Filter orders placed in 1994
        orders.WHERE(YEAR(order_date) == 1994)
        # Access lines for these orders
        .lines
        # Calculate revenue for each line item
        .CALCULATE(line_rev=extended_price * (1 - discount))
        # Access the calculated line revenue for summation
        .line_rev
    )
# Sort the results by total revenue in descending order
).ORDER_BY(total_revenue_1994.DESC())
```

**Explanation:**

1.  `customers.CALCULATE(...)`: We start with the `customers` collection and use `CALCULATE` to define the output fields.
2.  `cust_key=key, cust_name=name`: We select the customer's key and name, renaming them to `cust_key` and `cust_name`.
3.  `total_revenue_1994=SUM(...)`: We define a new field `total_revenue_1994` which will hold the aggregated revenue.
4.  `orders.WHERE(YEAR(order_date) == 1994)`: We access the `orders` sub-collection for each customer and filter them to keep only those placed in the year 1994 using the `YEAR` function on `order_date`.
5.  `.lines`: From the filtered orders, we access their corresponding `lines`.
6.  `.CALCULATE(line_rev=extended_price * (1 - discount))`: For each line item, we calculate its revenue (`extended_price * (1 - discount)`) and store it in a temporary field `line_rev`. This nested `CALCULATE` is necessary because we are performing an operation involving multiple fields (`extended_price`, `discount`) within the `lines` collection before aggregation.
7.  `.line_rev`: We access the calculated `line_rev` from the inner `CALCULATE`.
8.  `SUM(...)`: The `SUM` function aggregates all the `line_rev` values for the filtered lines belonging to each customer.
9.  `.ORDER_BY(total_revenue_1994.DESC())`: Finally, we sort the resulting collection of customers based on their `total_revenue_1994` in descending order.","# CALCULATE total revenue per customer for orders placed in 1994
customer_revenue_1994 = customers.CALCULATE(
    # Select customer key
    cust_key=key,
    # Select customer name
    cust_name=name,
    # CALCULATE total revenue by summing line revenues for 1994 orders
    total_revenue_1994=SUM(
        # Filter orders placed in 1994
        orders.WHERE(YEAR(order_date) == 1994)
        # Access lines for these orders
        .lines
        # CALCULATE revenue for each line item
        .CALCULATE(line_rev=extended_price * (1 - discount))
        # Access the calculated line revenue for summation
        .line_rev
    )
# Sort the results by total revenue in descending order
).ORDER_BY(total_revenue_1994.DESC())",Match,
"Find all customers whose name ends with a zero and are in the 30-lowest account balances. Show the customer key, name and account balance","SELECT c_custkey, c_name, c_acctbal FROM customer WHERE c_name LIKE '%0' ORDER BY c_acctbal ASC LIMIT 30;",,"Okay, let's break this down.

1.  **Goal:** Find customers whose name ends with '0' AND are among the 30 lowest account balances globally.
2.  **Collections:** We need the `customers` collection.
3.  **Filtering:**
    *   We need to filter by name using `ENDSWITH(name, '0')`.
    *   We need to identify the 30 lowest account balances. `RANKING(by=acctbal.ASC())` will rank customers globally, with the lowest balance getting rank 1. We need ranks less than or equal to 30 (`<= 30`).
    *   Both conditions must be true, so we'll use the `&` operator within a `WHERE` clause.
4.  **Selection:** We need to output the `key`, `name`, and `acctbal` using `CALCULATE`.

```python
# Find customers whose name ends with '0' and are within the 30 lowest account balances globally.
low_balance_customers_ending_zero = customers.WHERE(
    ENDSWITH(name, '0') & (RANKING(by=acctbal.ASC()) <= 30)
).CALCULATE(
    customer_key=key,          # Select the customer key
    customer_name=name,        # Select the customer name
    customer_acctbal=acctbal   # Select the customer account balance
)
```

**Explanation:**

1.  `customers`: Accesses the base collection of customers.
2.  `.WHERE(...)`: Filters the customers based on the combined conditions inside the parentheses.
3.  `ENDSWITH(name, '0')`: Checks if the `name` field ends with the character '0'.
4.  `RANKING(by=acctbal.ASC())`: Calculates a rank for each customer based on their `acctbal` in ascending order (lowest balance gets rank 1). This ranking is performed across all customers *before* the name filter is considered in the final selection.
5.  `RANKING(...) <= 30`: Filters for customers whose rank is 30 or lower (i.e., the 30 customers with the lowest account balances).
6.  `&`: Combines the name condition and the rank condition, requiring both to be true for a customer to be included.
7.  `.CALCULATE(...)`: Selects and potentially renames the final fields for the output.
8.  `customer_key=key, customer_name=name, customer_acctbal=acctbal`: Specifies the fields to be included in the result, renaming them for clarity.","# Find customers whose name ends with '0' and are within the 30 lowest account balances globally.
low_balance_customers_ending_zero = customers.WHERE(
    ENDSWITH(name, '0') & (RANKING(by=acctbal.ASC()) <= 30)
).CALCULATE(
    customer_key=key,          # Select the customer key
    customer_name=name,        # Select the customer name
    customer_acctbal=acctbal   # Select the customer account balance
)",No Match,
"For each of the 5 largest part sizes, find the part of that size with the largest retail price","WITH top_sizes AS (SELECT DISTINCT p_size FROM part ORDER BY p_size DESC LIMIT 5), ranked_parts AS (SELECT p.p_partkey, p.p_name, p.p_size, p.p_retailprice, RANK() OVER (PARTITION BY p.p_size ORDER BY p.p_retailprice DESC) AS price_rank FROM part p WHERE p.p_size IN (SELECT p_size FROM top_sizes)) SELECT p_partkey, p_name, p_size, p_retailprice FROM ranked_parts WHERE price_rank = 1 ORDER BY p_size DESC, p_retailprice DESC;",,"Okay, let's break this down.

1.  **Analyze the Input**: The request asks to group the `parts` collection by `size`, identify the 5 largest sizes, and for each of these 5 sizes, find the part with the highest `retail_price`.

2.  **Function Selection & Justification**:
    *   `PARTITION(parts, name='size_group', by=size)`: We need to group the parts based on their `size`. `PARTITION` is the correct function for this grouping operation.
    *   `ORDER_BY(size.DESC())`: To find the ""largest part sizes"", we need to sort the partitions based on the `size` value in descending order.
    *   `TOP_K(5, by=size.DESC())`: After sorting, we need to select the top 5 partitions, which correspond to the 5 largest sizes.
    *   `.size_group`: This syntax is used to access the collection of parts within each selected partition (each of the top 5 sizes).
    *   `CALCULATE(...)`: This will be used on the `size_group` collection to compute the rank and select the desired output fields.
    *   `RANKING(by=retail_price.DESC(), levels=1)`: This function is required to rank the parts *within* each size group based on their `retail_price`. `levels=1` ensures the ranking is performed independently for each partition (size group).
    *   `WHERE(price_rank == 1)`: This filter is needed to select only the top-ranked part (the one with the largest `retail_price`) from each size group.

3.  **Partitioning Strategy**: Partitioning by `size` is explicitly requested and is the correct key for grouping parts of the same size together.

4.  **Ranking Considerations**: The ranking needs to happen *after* partitioning and selecting the top size groups. `RANKING` with `levels=1` will correctly rank parts relative to others *within the same size group*.

5.  **Code Generation**: Based on the above, the PyDough code can be constructed.

```python
# Partition parts by size, sort partitions by size descending, and take the top 5
top_size_partitions = PARTITION(parts, name='size_group', by=size).ORDER_BY(size.DESC()).TOP_K(5, by=size.DESC())

# Access the parts within these top 5 size partitions
# Calculate the rank based on retail price within each partition
# Filter for the top-ranked part (rank == 1) in each partition
result = top_size_partitions.size_group.CALCULATE(
    part_key=key,
    part_size=size,
    part_retail_price=retail_price,
    price_rank=RANKING(by=retail_price.DESC(), levels=1)
).WHERE(price_rank == 1).CALCULATE(
    part_key=part_key,
    part_size=part_size,
    part_retail_price=part_retail_price
)

```

6.  **Step-by-Step Explanation**:
    1.  `PARTITION(parts, name='size_group', by=size)`: Groups all records from the `parts` collection based on the value in their `size` field. Each group is accessible via the name `size_group`.
    2.  `.ORDER_BY(size.DESC())`: Sorts these groups based on the `size` value (the partition key) in descending order.
    3.  `.TOP_K(5, by=size.DESC())`: Selects the top 5 groups from the sorted list, effectively giving us the partitions corresponding to the 5 largest sizes.
    4.  `.size_group`: Accesses the actual `parts` records within each of the selected top 5 size partitions.
    5.  `.CALCULATE(..., price_rank=RANKING(by=retail_price.DESC(), levels=1))`: For each part within these groups, it calculates a rank (`price_rank`) based on `retail_price` descending. `levels=1` ensures ranking restarts for each `size` group. It also selects `key`, `size`, and `retail_price` temporarily renaming them for clarity.
    6.  `.WHERE(price_rank == 1)`: Filters the results to keep only the parts that have a `price_rank` of 1, meaning they have the highest `retail_price` within their respective size group.
    7.  `.CALCULATE(part_key=part_key, part_size=part_size, part_retail_price=part_retail_price)`: Selects only the final requested fields for the top part from each of the 5 largest size groups.","# PARTITION parts by size, sort partitions by size descending, and take the top 5
top_size_partitions = PARTITION(parts, name='size_group', by=size).ORDER_BY(size.DESC()).TOP_K(5, by=size.DESC())

# Access the parts within these top 5 size partitions
# CALCULATE the rank based on retail price within each PARTITION
# Filter for the top-ranked part (rank == 1) in each PARTITION
result = top_size_partitions.size_group.CALCULATE(
    part_key=key,
    part_size=size,
    part_retail_price=retail_price,
    price_rank=RANKING(by=retail_price.DESC(), levels=1)
).WHERE(price_rank == 1).CALCULATE(
    part_key=part_key,
    part_size=part_size,
    part_retail_price=part_retail_price
)",No Match,
"For each region, calculate the average percentage of purchases made from suppliers in that region belonging to the most common part type shipped from the supplier region to the customer region, averaging across all customer region. Only considers lineitems from June of 1992 where the container is small. To know if a container is small the container should start with SM","WITH part_counts AS (
  SELECT 
    rs.R_NAME AS supp_region,
    rc.R_NAME AS cust_region,
    p.P_TYPE AS p_type,
    COUNT(*) AS type_count
  FROM lineitem l
  JOIN part p ON l.L_PARTKEY = p.P_PARTKEY
  JOIN supplier s ON l.L_SUPPKEY = s.S_SUPPKEY
  JOIN nation ns ON s.S_NATIONKEY = ns.N_NATIONKEY
  JOIN region rs ON ns.N_REGIONKEY = rs.R_REGIONKEY
  JOIN orders o ON l.L_ORDERKEY = o.O_ORDERKEY
  JOIN customer c ON o.O_CUSTKEY = c.C_CUSTKEY
  JOIN nation nc ON c.C_NATIONKEY = nc.N_NATIONKEY
  JOIN region rc ON nc.N_REGIONKEY = rc.R_REGIONKEY
  WHERE l.L_SHIPDATE BETWEEN '1992-06-01' AND '1992-06-30'
    AND  p.P_CONTAINER LIKE 'SM%'
  GROUP BY rs.R_NAME, rc.R_NAME, p.P_TYPE
),
region_customer AS (
  SELECT 
    supp_region,
    cust_region,
    SUM(type_count) AS total_count,
    MAX(type_count) AS max_type_count
  FROM part_counts
  GROUP BY supp_region, cust_region
),
region_avg AS (
  SELECT 
    supp_region,
    AVG(100.0 * max_type_count / total_count) AS avg_percentage
  FROM region_customer
  GROUP BY supp_region
)
SELECT 
  supp_region AS region,
  avg_percentage
FROM region_avg
ORDER BY region;
",,"Okay, let's break this down.

1.  **Filter `lines`**: We need line items shipped in June 1992 (`YEAR(ship_date) == 1992 & MONTH(ship_date) == 6`) where the part container starts with ""SM"" (`STARTSWITH(part.container, ""SM"")`).
2.  **Extract Information**: For each filtered line, we need the supplier's region name (`supplier.nation.region.name`), the customer's region name (`order.customer.nation.region.name`), the part type (`part.part_type`), and the quantity (`quantity`).
3.  **Group by Supplier Region, Customer Region, and Part Type**: To find the most common part type for each supplier-customer region pair, we first need to count how many times each part type appears and sum its quantity within each pair. We use `PARTITION` by `supp_region_name`, `cust_region_name`, and `p_type`, then `CALCULATE` with `SUM` and `COUNT`.
4.  **Rank Part Types within Each Pair**: We need to rank the part types within each (supplier region, customer region) pair based on their count (`type_count`). We use another `PARTITION` by `supp_region_name` and `cust_region_name`. Inside this partition's context (`pair_group`), we use `CALCULATE` with the `RANKING` function (`RANKING(by=type_count.DESC(), allow_ties=True)`). We also need the total quantity for the entire pair, which we can calculate using `RELSUM(type_quantity)` within the same `CALCULATE`.
5.  **Filter Most Common Types**: We filter the results from the previous step to keep only the rows where `rank_in_pair == 1`.
6.  **Calculate Percentage per Pair**: For each pair, we sum the quantities of the rank=1 part types (`most_common_total_quantity`) and divide by the total quantity for that pair (`total_pair_quantity`). This requires another `PARTITION` by `supp_region_name` and `cust_region_name` on the rank=1 data, using `SUM` for the numerator and `MAX` (or `MIN` or `AVG`) to get the constant `total_pair_quantity` for the denominator. Then calculate the percentage.
7.  **Average Percentages per Supplier Region**: Finally, we partition the results by `supp_region_name` and calculate the `AVG` of the `pair_percentage`.

```python
# 1. Filter lines and calculate necessary fields
lines_info = lines.WHERE(
    (YEAR(ship_date) == 1992) &
    (MONTH(ship_date) == 6) &
    STARTSWITH(part.container, ""SM"")
).CALCULATE(
    supp_region_name=supplier.nation.region.name,
    cust_region_name=order.customer.nation.region.name,
    p_type=part.part_type,
    line_quantity=quantity
)

# 2. Partition by (supp_region, cust_region, p_type) to get counts and quantities per type within each pair
part_type_stats = PARTITION(
    lines_info,
    name='type_group',
    by=(supp_region_name, cust_region_name, p_type)
).CALCULATE(
    supp_region_name=supp_region_name,
    cust_region_name=cust_region_name,
    p_type=p_type,
    type_quantity=SUM(type_group.line_quantity),
    type_count=COUNT(type_group) # Count of lines for this specific part type in this pair
)

# 3. Partition by pair, rank types within the pair, and calculate total pair quantity
pair_level_stats = PARTITION(
    part_type_stats, # Input is aggregated stats per type
    name='pair_group',
    by=(supp_region_name, cust_region_name)
).pair_group.CALCULATE( # Operate on each row within the pair group
    supp_region_name=supp_region_name, # Carry over partition keys
    cust_region_name=cust_region_name,
    p_type=p_type,
    type_quantity=type_quantity,
    type_count=type_count,
    # Rank this type within its pair based on count (allow ties)
    rank_in_pair=RANKING(by=type_count.DESC(), allow_ties=True),
    # Get the total quantity for the entire pair using RELSUM
    total_pair_quantity=RELSUM(type_quantity) # Sums type_quantity across all rows in the pair_group
)

# 4. Filter for the most common types (rank=1)
most_common_in_pair = pair_level_stats.WHERE(rank_in_pair == 1)

# 5 & 6. Aggregate rank 1 quantities and calculate percentage per pair
pair_percentages = PARTITION(
    most_common_in_pair,
    name='pair_rank1_group',
    by=(supp_region_name, cust_region_name)
).CALCULATE(
    supp_region_name=supp_region_name,
    # Sum quantities of all rank=1 types for this pair
    most_common_total_quantity=SUM(pair_rank1_group.type_quantity),
    # Get the total pair quantity (should be constant within the group, use MAX to select one value)
    total_pair_quantity=MAX(pair_rank1_group.total_pair_quantity)
).CALCULATE( # Calculate percentage in a subsequent step
    supp_region_name=supp_region_name,
    pair_percentage=IFF(
        total_pair_quantity > 0,
        (most_common_total_quantity / total_pair_quantity) * 100.0,
        0.0 # Handle division by zero if a pair had zero total quantity
    )
)

# 7. Final aggregation: Average percentage per supplier region
final_avg_percentages = PARTITION(
    pair_percentages,
    name='supp_region_group',
    by=(supp_region_name,) # Partition only by supplier region
).CALCULATE(
    supplier_region=supp_region_name,
    average_percentage=AVG(supp_region_group.pair_percentage)
)
```

**Explanation:**

1.  `lines_info`: Filters the `lines` collection for shipments in June 1992 with small containers (starting with ""SM"") and calculates the supplier region, customer region, part type, and quantity for each relevant line item.
2.  `part_type_stats`: Groups the `lines_info` data by supplier region, customer region, and part type. For each unique combination, it calculates the total quantity (`type_quantity`) and the count of line items (`type_count`) for that specific part type within that specific region pair.
3.  `pair_level_stats`: Takes the `part_type_stats` and processes it within groups defined by supplier region and customer region (`PARTITION(...).pair_group.CALCULATE`). For each part type within a pair, it calculates its rank (`rank_in_pair`) based on `type_count` (most frequent gets rank 1, ties allowed) and the total quantity of all parts shipped between that supplier-customer region pair (`total_pair_quantity`) using `RELSUM`.
4.  `most_common_in_pair`: Filters `pair_level_stats` to keep only the part types that ranked first (rank=1) within their respective region pairs. This includes all types if there was a tie for the most common.
5.  `pair_percentages`: Groups the `most_common_in_pair` data by supplier region and customer region. It sums the quantities of all the rank-1 types (`most_common_total_quantity`) and retrieves the total quantity for the pair (`total_pair_quantity`). It then calculates the percentage that the most common type(s) represent out of the total quantity for that pair.
6.  `final_avg_percentages`: Groups the `pair_percentages` by supplier region (`supp_region_name`) and calculates the average (`AVG`) of the `pair_percentage` values across all customer regions associated with that supplier region. The final result contains the supplier region name and the calculated average percentage.","# 1. Filter lines and CALCULATE necessary fields
lines_info = lines.WHERE(
    (YEAR(ship_date) == 1992) &
    (MONTH(ship_date) == 6) &
    STARTSWITH(part.container, ""SM"")
).CALCULATE(
    supp_region_name=supplier.nation.region.name,
    cust_region_name=order.customer.nation.region.name,
    p_type=part.part_type,
    line_quantity=quantity
)

# 2. PARTITION by (supp_region, cust_region, p_type) to get counts and quantities per type within each pair
part_type_stats = PARTITION(
    lines_info,
    name='type_group',
    by=(supp_region_name, cust_region_name, p_type)
).CALCULATE(
    supp_region_name=supp_region_name,
    cust_region_name=cust_region_name,
    p_type=p_type,
    type_quantity=SUM(type_group.line_quantity),
    type_count=COUNT(type_group) # Count of lines for this specific part type in this pair
)

# 3. PARTITION by pair, rank types within the pair, and CALCULATE total pair quantity
pair_level_stats = PARTITION(
    part_type_stats, # Input is aggregated stats per type
    name='pair_group',
    by=(supp_region_name, cust_region_name)
).pair_group.CALCULATE( # Operate on each row within the pair group
    supp_region_name=supp_region_name, # Carry over PARTITION keys
    cust_region_name=cust_region_name,
    p_type=p_type,
    type_quantity=type_quantity,
    type_count=type_count,
    # Rank this type within its pair based on count (allow ties)
    rank_in_pair=RANKING(by=type_count.DESC(), allow_ties=True),
    # Get the total quantity for the entire pair using RELSUM
    total_pair_quantity=RELSUM(type_quantity) # Sums type_quantity across all rows in the pair_group
)

# 4. Filter for the most common types (rank=1)
most_common_in_pair = pair_level_stats.WHERE(rank_in_pair == 1)

# 5 & 6. Aggregate rank 1 quantities and CALCULATE percentage per pair
pair_percentages = PARTITION(
    most_common_in_pair,
    name='pair_rank1_group',
    by=(supp_region_name, cust_region_name)
).CALCULATE(
    supp_region_name=supp_region_name,
    # SUM quantities of all rank=1 types for this pair
    most_common_total_quantity=SUM(pair_rank1_group.type_quantity),
    # Get the total pair quantity (should be constant within the group, use MAX to select one value)
    total_pair_quantity=MAX(pair_rank1_group.total_pair_quantity)
).CALCULATE( # CALCULATE percentage in a subsequent step
    supp_region_name=supp_region_name,
    pair_percentage=IFF(
        total_pair_quantity > 0,
        (most_common_total_quantity / total_pair_quantity) * 100.0,
        0.0 # Handle division by zero if a pair had zero total quantity
    )
)

# 7. Final aggregation: Average percentage per supplier region
final_avg_percentages = PARTITION(
    pair_percentages,
    name='supp_region_group',
    by=(supp_region_name,) # PARTITION only by supplier region
).CALCULATE(
    supplier_region=supp_region_name,
    average_percentage=AVG(supp_region_group.pair_percentage)
)",No Match,
"Break down how many customers, by country code of their phone number (only including customers from certain country codes), have not placed an order but have an account balance that is above the average for all positive account balances of such customers. Also include the total balance for all such customers for each country code. The country codes to include are 13, 23, 29, 30, 18 and 17.","WITH CountryAvg AS (
    SELECT 
        SUBSTR(C_PHONE, 1, INSTR(C_PHONE, '-') - 1) AS country_code,
        AVG(C_ACCTBAL) AS avg_balance
    FROM Customer
    WHERE C_ACCTBAL > 0
        AND CAST(SUBSTR(C_PHONE, 1, INSTR(C_PHONE, '-') - 1) AS INTEGER) IN (13, 23, 29, 30, 18, 17)
    GROUP BY country_code
)
SELECT 
    c.country_code,
    COUNT(*) AS customer_count,
    SUM(c.C_ACCTBAL) AS total_balance
FROM (
    SELECT 
        SUBSTR(C_PHONE, 1, INSTR(C_PHONE, '-') - 1) AS country_code,
        C_CUSTKEY,
        C_ACCTBAL
    FROM Customer
) c
LEFT JOIN Orders o ON c.C_CUSTKEY = o.O_CUSTKEY
INNER JOIN CountryAvg ca ON c.country_code = ca.country_code
WHERE o.O_CUSTKEY IS NULL
    AND c.C_ACCTBAL > ca.avg_balance
GROUP BY c.country_code;",,"Okay, let's break down the steps and generate the PyDough code.

**1. Analyze the Input & Function Selection**

*   **Goal**: Group customers by phone country code, filter them based on order history and account balance relative to an average, and then count them and sum their balances per group.
*   **Collections**: `customers` is the primary collection.
*   **Functions Needed**:
    *   `CALCULATE`: To extract the country code (`phone[:3]`) and potentially rename `acctbal` for clarity. Also needed later to calculate the average and finally within the partition.
    *   `WHERE`: To filter by country code (`ISIN`), lack of orders (`HASNOT`), and account balance comparison.
    *   `ISIN`: To check if the extracted country code is in the specified list.
    *   `HASNOT`: To check if the `orders` sub-collection is empty.
    *   `RELAVG`: To calculate the average positive account balance across the relevant subset of customers (those matching the country code and no-order criteria). This is a window function suitable for calculating an average over a dynamic set of rows.
    *   `KEEP_IF`: Used within `RELAVG` to only consider positive account balances for the average calculation.
    *   `PARTITION`: To group the final filtered customers by their country code.
    *   `COUNT`: To count customers within each partition group.
    *   `SUM`: To sum the account balances within each partition group.

**2. Partitioning Strategy**

*   `PARTITION` is necessary because the final output requires aggregation (count of customers, sum of balance) *per country code*.
*   We will partition by the calculated `country_code` field after all filtering is complete.

**3. Code Generation**

```python
# Define the target country codes as strings
target_codes = ('13', '23', '29', '30', '18', '17')

# 1. Filter customers by country code and no orders.
#    Calculate the average positive balance for this filtered group globally.
filtered_customers_with_avg = customers.CALCULATE(
    c_code=phone[:3],
    c_acctbal=acctbal
).WHERE(
    ISIN(c_code, target_codes) & (HASNOT(orders) == 1)
).CALCULATE(
    c_code, # Pass through the country code
    c_acctbal, # Pass through the account balance
    # Calculate the average of positive balances across all rows matching the WHERE clause above
    global_avg_pos_bal=RELAVG(KEEP_IF(c_acctbal, c_acctbal > 0))
)

# 2. Filter customers whose balance is above the calculated average positive balance.
final_filtered_customers = filtered_customers_with_avg.WHERE(
    c_acctbal > global_avg_pos_bal
)

# 3. Partition the remaining customers by country code and calculate final aggregates.
customer_analysis_by_code = PARTITION(
    final_filtered_customers,
    name='cust_group', # Name for the partition group
    by=c_code         # Group by the calculated country code
).CALCULATE(
    country_code=c_code, # Select the country code (partition key)
    customer_count=COUNT(cust_group), # Count customers in this group
    total_balance=SUM(cust_group.c_acctbal) # Sum balances for customers in this group
)
```

**4. Step-by-Step Explanation**

1.  **`target_codes = ('13', '23', '29', '30', '18', '17')`**: Defines the list of country codes (as strings, since phone numbers are typically strings) to filter by.
2.  **`filtered_customers_with_avg = customers.CALCULATE(...)`**:
    *   Starts with the `customers` collection.
    *   `CALCULATE(c_code=phone[:3], c_acctbal=acctbal)`: Extracts the first 3 characters of the `phone` number as `c_code` and selects the `acctbal` as `c_acctbal`.
    *   `.WHERE(ISIN(c_code, target_codes) & (HASNOT(orders) == 1))`: Filters this initial set to include only customers whose `c_code` is in `target_codes` AND who have no orders (`HASNOT(orders)` is true, compared explicitly to `1`).
    *   `.CALCULATE(c_code, c_acctbal, global_avg_pos_bal=RELAVG(KEEP_IF(c_acctbal, c_acctbal > 0)))`: Takes the result of the `WHERE` clause. It keeps `c_code` and `c_acctbal`. Crucially, it calculates `global_avg_pos_bal` using `RELAVG`. `RELAVG` computes the average of its argument (`KEEP_IF(...)`) across *all rows* passed into this `CALCULATE` step (i.e., all customers matching the country code and no-order criteria). `KEEP_IF(c_acctbal, c_acctbal > 0)` ensures only positive account balances are considered for this average.
3.  **`final_filtered_customers = filtered_customers_with_avg.WHERE(...)`**:
    *   Takes the `filtered_customers_with_avg` collection.
    *   `.WHERE(c_acctbal > global_avg_pos_bal)`: Filters further, keeping only those customers whose individual account balance (`c_acctbal`) is strictly greater than the calculated average positive balance (`global_avg_pos_bal`).
4.  **`customer_analysis_by_code = PARTITION(...)`**:
    *   `PARTITION(final_filtered_customers, name='cust_group', by=c_code)`: Takes the `final_filtered_customers` and groups them into partitions based on their `c_code`. Each group is accessible via the name `cust_group`.
    *   `.CALCULATE(country_code=c_code, customer_count=COUNT(cust_group), total_balance=SUM(cust_group.c_acctbal))`: For each partition (i.e., for each unique `c_code`):
        *   Selects the `c_code` itself as `country_code`.
        *   Counts the number of customers in that group using `COUNT(cust_group)` and assigns it to `customer_count`.
        *   Sums the `c_acctbal` of all customers in that group using `SUM(cust_group.c_acctbal)` and assigns it to `total_balance`.
5.  The final result is stored in the `customer_analysis_by_code` variable, containing rows for each relevant country code with the count of qualifying customers and their total balance.","# Define the target country codes as strings
target_codes = ('13', '23', '29', '30', '18', '17')

# 1. Filter customers by country code and no orders.
#    CALCULATE the average positive balance for this filtered group globally.
filtered_customers_with_avg = customers.CALCULATE(
    c_code=phone[:3],
    c_acctbal=acctbal
).WHERE(
    ISIN(c_code, target_codes) & (HASNOT(orders) == 1)
).CALCULATE(
    c_code, # Pass through the country code
    c_acctbal, # Pass through the account balance
    # CALCULATE the average of positive balances across all rows matching the WHERE clause above
    global_avg_pos_bal=RELAVG(KEEP_IF(c_acctbal, c_acctbal > 0))
)

# 2. Filter customers whose balance is above the calculated average positive balance.
final_filtered_customers = filtered_customers_with_avg.WHERE(
    c_acctbal > global_avg_pos_bal
)

# 3. PARTITION the remaining customers by country code and CALCULATE final aggregates.
customer_analysis_by_code = PARTITION(
    final_filtered_customers,
    name='cust_group', # Name for the PARTITION group
    by=c_code         # Group by the calculated country code
).CALCULATE(
    country_code=c_code, # Select the country code (PARTITION key)
    customer_count=COUNT(cust_group), # Count customers in this group
    total_balance=SUM(cust_group.c_acctbal) # SUM balances for customers in this group
)",No Match,
Find the names of all customers and the number of orders placed in 1995 in Europe that placed a least one order in that same year. Sorted in descending order by the number of orders.,"SELECT
    c.c_name AS customer_name,
    COUNT(o.o_orderkey) AS order_count
FROM
    customer c
JOIN
    orders o ON c.c_custkey = o.o_custkey
JOIN
    nation n ON c.c_nationkey = n.n_nationkey
WHERE
    strftime('%Y', o.o_orderdate) = '1995'
    AND n.n_regionkey = (
        SELECT r_regionkey
        FROM region
        WHERE r_name = 'EUROPE'
    )
GROUP BY
    c.c_custkey, c.c_name
ORDER BY
    order_count DESC;",,"Okay, let's break this down.

1.  **Goal**: Find European customers who ordered in 1995, list their names and 1995 order count, sorted by count descending.
2.  **Collections**: We need `customers` to get customer names and link to `nations` and `orders`. We need `nations` to link to `regions`. We need `regions` to filter by ""EUROPE"". We need `orders` to filter by year and count.
3.  **Filtering**:
    *   Filter customers by region: `customers.WHERE(nation.region.name == ""EUROPE"")`.
    *   Filter orders by year: `orders.WHERE(YEAR(order_date) == 1995)`.
    *   Filter customers by having at least one order in 1995: We'll calculate the count first and then filter.
4.  **Calculation**:
    *   For each customer, calculate their name: `name`.
    *   For each customer, count their orders from 1995: `COUNT(orders.WHERE(YEAR(order_date) == 1995))`.
5.  **Sorting**: Use `ORDER_BY` on the calculated order count in descending order.
6.  **Function Selection**:
    *   `customers`: Base collection.
    *   `.WHERE()`: To filter customers by region (`nation.region.name == ""EUROPE""`) and later by order count (`num_orders_1995 >= 1`).
    *   `.CALCULATE()`: To select the customer name (`customer_name=name`) and compute the number of orders in 1995 (`num_orders_1995=COUNT(...)`).
    *   `COUNT()`: Aggregation function to count orders within the `CALCULATE`.
    *   `YEAR()`: Datetime function to extract the year from `order_date`.
    *   `.ORDER_BY()`: To sort the final result.
    *   `.DESC()`: To specify descending order for sorting.
7.  **Partitioning**: No `PARTITION` is needed because the aggregation (`COUNT`) is performed directly per customer, which is the level of the main collection being processed.
8.  **Ranking**: No `RANKING` or `TOP_K` is needed as we need all customers meeting the criteria, just sorted.

```python
# Filter customers located in Europe
european_customers = customers.WHERE(nation.region.name == ""EUROPE"")

# Calculate the name and the number of orders placed in 1995 for each European customer
customer_orders_1995 = european_customers.CALCULATE(
    customer_name=name,
    num_orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))
)

# Filter out customers who placed zero orders in 1995
active_customers_1995 = customer_orders_1995.WHERE(num_orders_1995 >= 1)

# Sort the results by the number of orders in descending order
sorted_customers = active_customers_1995.ORDER_BY(num_orders_1995.DESC())

# Assign the final result to a variable
european_customer_order_summary_1995 = sorted_customers
```

**Explanation:**

1.  `european_customers = customers.WHERE(nation.region.name == ""EUROPE"")`: This line filters the `customers` collection to include only those whose associated nation belongs to the ""EUROPE"" region.
2.  `customer_orders_1995 = european_customers.CALCULATE(...)`: This takes the filtered European customers and calculates two fields for each:
    *   `customer_name=name`: Selects the customer's name.
    *   `num_orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))`: Counts the orders associated with each customer, but only includes orders where the `order_date` year is 1995.
3.  `active_customers_1995 = customer_orders_1995.WHERE(num_orders_1995 >= 1)`: This filters the results further, keeping only those customers who have one or more orders in 1995 (i.e., `num_orders_1995` is greater than or equal to 1).
4.  `sorted_customers = active_customers_1995.ORDER_BY(num_orders_1995.DESC())`: This sorts the remaining customers based on their `num_orders_1995` count in descending order (highest count first).
5.  `european_customer_order_summary_1995 = sorted_customers`: Assigns the final, sorted result to the specified variable name. The result contains the `customer_name` and `num_orders_1995` for each qualifying customer.","# Filter customers located in Europe
european_customers = customers.WHERE(nation.region.name == ""EUROPE"")

# CALCULATE the name and the number of orders placed in 1995 for each European customer
customer_orders_1995 = european_customers.CALCULATE(
    customer_name=name,
    num_orders_1995=COUNT(orders.WHERE(YEAR(order_date) == 1995))
)

# Filter out customers who placed zero orders in 1995
active_customers_1995 = customer_orders_1995.WHERE(num_orders_1995 >= 1)

# Sort the results by the number of orders in descending order
sorted_customers = active_customers_1995.ORDER_BY(num_orders_1995.DESC())

# Assign the final result to a variable
european_customer_order_summary_1995 = sorted_customers",Match,
"List customers who ordered in 1996 but not in 1997 with a total spent of over 1000$. Include the number of months since the last order (relative to the current date) and sort by total spent, highest first.","SELECT
  customer_name,
  total_spent,
  months_since_last_order
FROM (
  SELECT
    total_spent AS ordering_4,
    customer_name,
    months_since_last_order,
    total_spent
  FROM (
    SELECT
      agg_2,
      agg_3,
      customer_name,
      months_since_last_order,
      total_spent
    FROM (
      SELECT
        agg_2,
        customer_name,
        key,
        months_since_last_order,
        total_spent
      FROM (
        SELECT
          COALESCE(agg_1, 0) AS total_spent,
          name AS customer_name,
          (
            CAST(STRFTIME('%Y', DATETIME('now')) AS INTEGER) - CAST(STRFTIME('%Y', agg_0) AS INTEGER)
          ) * 12 + CAST(STRFTIME('%m', DATETIME('now')) AS INTEGER) - CAST(STRFTIME('%m', agg_0) AS INTEGER) AS months_since_last_order,
          key
        FROM (
          SELECT
            agg_0,
            agg_1,
            key,
            name
          FROM (
            SELECT
              c_custkey AS key,
              c_name AS name
            FROM main.CUSTOMER
          )
          LEFT JOIN (
            SELECT
              MAX(order_date) AS agg_0,
              SUM(total_price) AS agg_1,
              customer_key
            FROM (
              SELECT
                o_custkey AS customer_key,
                o_orderdate AS order_date,
                o_totalprice AS total_price
              FROM main.ORDERS
            )
            GROUP BY
              customer_key
          )
            ON key = customer_key
        )
      )
      LEFT JOIN (
        SELECT
          COUNT() AS agg_2,
          customer_key
        FROM (
          SELECT
            customer_key
          FROM (
            SELECT
              o_custkey AS customer_key,
              o_orderdate AS order_date
            FROM main.ORDERS
          )
          WHERE
            CAST(STRFTIME('%Y', order_date) AS INTEGER) = 1996
        )
        GROUP BY
          customer_key
      )
        ON key = customer_key
    )
    LEFT JOIN (
      SELECT
        COUNT() AS agg_3,
        customer_key
      FROM (
        SELECT
          customer_key
        FROM (
          SELECT
            o_custkey AS customer_key,
            o_orderdate AS order_date
          FROM main.ORDERS
        )
        WHERE
          CAST(STRFTIME('%Y', order_date) AS INTEGER) = 1997
      )
      GROUP BY
        customer_key
    )
      ON key = customer_key
  )
  WHERE
    (
      (
        COALESCE(agg_2, 0) > 0
      ) = 1
    )
    AND (
      (
        COALESCE(agg_3, 0) = 0
      ) = 1
    )
    AND (
      total_spent > 1000
    )
)
ORDER BY
  ordering_4 DESC",,"Okay, let's break this down.

1.  **Identify Customers & Calculate Metrics**: We need to start with the `customers` collection. For each customer, we need to determine:
    *   If they placed an order in 1996 (`HAS(orders.WHERE(YEAR(order_date) == 1996))`).
    *   If they placed an order in 1997 (`HAS(orders.WHERE(YEAR(order_date) == 1997))`).
    *   Their total spending (`SUM(orders.total_price)`).
    *   Their last order date (`MAX(orders.order_date)`).
    We'll use `CALCULATE` for this.

2.  **Filter Customers**: Apply the conditions:
    *   Ordered in 1996 (`has_ordered_1996 == 1`).
    *   Did *not* order in 1997 (`has_ordered_1997 == 0`).
    *   Total spent > $1000 (`total_spent_calc > 1000`).
    We'll use `WHERE` for this.

3.  **Calculate Months Since Last Order**: For the filtered customers, calculate the difference in months between their last order date and the current date using `DATEDIFF(""months"", last_order_dt, DATETIME('now'))`. We'll use `CALCULATE` again.

4.  **Sort**: Order the results by the calculated total spending in descending order using `ORDER_BY(total_spent_calc.DESC())`.

5.  **Select Final Output**: Select only the customer information (key, name) and the calculated months since the last order. Use a final `CALCULATE`.

```python
# 1. Calculate initial metrics for each customer
customer_metrics = customers.CALCULATE(
    cust_key=key,
    cust_name=name,
    has_ordered_1996=HAS(orders.WHERE(YEAR(order_date) == 1996)),
    has_ordered_1997=HAS(orders.WHERE(YEAR(order_date) == 1997)),
    total_spent_calc=SUM(orders.total_price),
    last_order_dt=MAX(orders.order_date)
)

# 2. Filter customers based on the criteria
filtered_customers = customer_metrics.WHERE(
    (has_ordered_1996 == 1) &
    (has_ordered_1997 == 0) &
    (total_spent_calc > 1000)
)

# 3. Calculate months since last order for filtered customers
customers_with_months = filtered_customers.CALCULATE(
    cust_key=cust_key,
    cust_name=cust_name,
    total_spent_calc=total_spent_calc, # Keep for sorting
    months_since_last=DATEDIFF(""months"", last_order_dt, DATETIME('now'))
)

# 4. Sort by total spent (descending)
sorted_customers = customers_with_months.ORDER_BY(total_spent_calc.DESC())

# 5. Select final output fields
final_result = sorted_customers.CALCULATE(
    cust_key=cust_key,
    cust_name=cust_name,
    months_since_last=months_since_last
)
```

### Explanation:

1.  **`customer_metrics`**: This step calculates necessary intermediate values for each customer: their key and name, flags indicating if they ordered in 1996 and 1997, their total spending across all orders, and the date of their most recent order.
2.  **`filtered_customers`**: This step applies the core logic filters: selects customers who ordered in 1996 (`has_ordered_1996 == 1`), did not order in 1997 (`has_ordered_1997 == 0`), and whose total spending exceeds $1000 (`total_spent_calc > 1000`).
3.  **`customers_with_months`**: For the customers who passed the filters, this calculates the number of months elapsed between their last order date (`last_order_dt`) and the current date (`DATETIME('now')`). It retains `cust_key`, `cust_name`, and `total_spent_calc` for subsequent steps.
4.  **`sorted_customers`**: This step sorts the resulting customers based on their total spending (`total_spent_calc`) in descending order (highest spending first).
5.  **`final_result`**: This final step selects only the required output fields: the customer's key, name, and the calculated `months_since_last`.","# 1. CALCULATE initial metrics for each customer
customer_metrics = customers.CALCULATE(
    cust_key=key,
    cust_name=name,
    has_ordered_1996=HAS(orders.WHERE(YEAR(order_date) == 1996)),
    has_ordered_1997=HAS(orders.WHERE(YEAR(order_date) == 1997)),
    total_spent_calc=SUM(orders.total_price),
    last_order_dt=MAX(orders.order_date)
)

# 2. Filter customers based on the criteria
filtered_customers = customer_metrics.WHERE(
    (has_ordered_1996 == 1) &
    (has_ordered_1997 == 0) &
    (total_spent_calc > 1000)
)

# 3. CALCULATE months since last order for filtered customers
customers_with_months = filtered_customers.CALCULATE(
    cust_key=cust_key,
    cust_name=cust_name,
    total_spent_calc=total_spent_calc, # Keep for sorting
    months_since_last=DATEDIFF(""months"", last_order_dt, DATETIME('now'))
)

# 4. Sort by total spent (descending)
sorted_customers = customers_with_months.ORDER_BY(total_spent_calc.DESC())

# 5. Select final output fields
final_result = sorted_customers.CALCULATE(
    cust_key=cust_key,
    cust_name=cust_name,
    months_since_last=months_since_last
)",No Match,
What is the february 1996 SPM for the almond antique blue royal burnished part in China? SPM (Selling Profit Margin) = (Total Amount from Sells - (Tax + Commission)) / Total Amount from Sells * 100,"SELECT
  ROUND(
    (
      (
        -- Total Sales (Revenue after discount)
        SUM(l.l_extendedprice) 
        - 
        (
          -- Total Tax (on discounted sales)
          SUM(l.l_extendedprice  * l.l_tax) 
          + 
          -- Total Commission (discount amount)
          SUM(l.l_extendedprice * l.l_discount)
        )
      ) 
      / 
      SUM(l.l_extendedprice) 
    ) * 100, 2
  ) AS spm
FROM part p
JOIN lineitem l ON p.p_partkey = l.l_partkey
JOIN orders o ON l.l_orderkey = o.o_orderkey
JOIN customer c ON o.o_custkey = c.c_custkey
JOIN nation n ON c.c_nationkey = n.n_nationkey
WHERE
  -- Match the part name (case-sensitive wildcards)
  p.p_name LIKE '%rosy%black%navajo%cream%sky%'
  -- Filter for February 1996 orders
  AND strftime('%Y-%m', o.o_orderdate) = '1996-02'
  -- Optional: Filter for a specific nation (e.g., China)
  -- AND n.n_name = 'CHINA';",,"*   **Function Selection & Justification**:
    *   `parts.WHERE`: To filter the `parts` collection and find the specific part named 'almond antique blue royal burnished' (corrected from the previous code based on the original question).
    *   `CALCULATE`: Used multiple times. First, to compute aggregate values (`SUM`) for `extended_price` and `tax` directly from the filtered line items associated with the target part, supplier nation ('CHINA'), and order date (February 1996). Second, to calculate the Selling Profit Margin (SPM) using the aggregated values and add the supplier country context. Finally, to select the specific output fields requested.
    *   `SUM`: To aggregate `extended_price` (Total Sales Amount) and `tax` (Total Tax) from the filtered line items. This aggregation happens within the `CALCULATE` clause, operating on a filtered sub-collection, which is a valid pattern.
    *   `lines.WHERE`: To filter the line items associated with the target part based on the supplier's nation ('CHINA') and the order date (February 1996). This filtering happens *within* the `SUM` aggregation function's scope.
    *   `YEAR`, `MONTH`: To extract the year and month from the `order.order_date` for filtering.
    *   `DEFAULT_TO`: To handle potential null results from `SUM` if no matching lines are found, defaulting to 0.0.
    *   `IFF`: To handle potential division by zero when calculating the SPM, returning 0.0 if `total_sales` is zero.
*   **Partitioning Strategy**:
    *   `PARTITION` is not required here. The calculation is specific to a single part under specific conditions. Aggregation using `SUM` within a `CALCULATE` clause after filtering is sufficient.
*   **Ranking Considerations**:
    *   `RANKING` is not needed for this query as no ranking is requested.
*   **Handling Ambiguity**:
    *   The prompt mentions ""Commission"" in the SPM formula, but there is no direct 'commission' field in the schema. The calculation proceeds using only 'Tax' as specified in the formula `(Total Sales Amount - Tax) / Total Sales Amount * 100`.
    *   The prompt mentions ""total number of orders placed in 1996"". This seems like extra context and doesn't directly fit into the provided SPM formula based on sales amount and tax. The calculation focuses on the monetary values (`extended_price`, `tax`) from February 1996 for the specific part and supplier location.

```python
# Filter for the specific part mentioned in the original question
target_part = parts.WHERE(name == 'almond antique blue royal burnished')

# Calculate SPM directly within CALCULATE by filtering lines and aggregating
part_spm_calculation = target_part.CALCULATE(
    part_name = name,
    # Calculate total sales from relevant lines by filtering within SUM
    total_sales = DEFAULT_TO(SUM(
        lines.WHERE(
            (supplier.nation.name == 'CHINA') &
            (YEAR(order.order_date) == 1996) &
            (MONTH(order.order_date) == 2)
        ).extended_price # Access extended_price after filtering
    ), 0.0),
    # Calculate total tax from relevant lines by filtering within SUM
    total_tax = DEFAULT_TO(SUM(
        lines.WHERE(
            (supplier.nation.name == 'CHINA') &
            (YEAR(order.order_date) == 1996) &
            (MONTH(order.order_date) == 2)
        ).tax # Access tax after filtering
    ), 0.0)
).CALCULATE(
    # Carry over necessary fields
    part_name = part_name,
    total_sales = total_sales, # Carry over total_sales for SPM calculation
    total_tax = total_tax,     # Carry over total_tax for SPM calculation
    # Add supplier country context
    supplier_country = 'CHINA',
    # Calculate Selling Profit Margin (SPM)
    selling_profit_margin = IFF(
        total_sales == 0,
        0.0, # Define SPM as 0 if there are no sales
        (total_sales - total_tax) / total_sales * 100.0 # Multiply by 100.0 for percentage
    )
)

# Select only the requested fields for the final output
final_result = part_spm_calculation.CALCULATE(
    part_name=part_name,
    supplier_country=supplier_country,
    selling_profit_margin=selling_profit_margin
)
```

*   **Step-by-Step Explanation**:
    1.  `target_part = parts.WHERE(name == 'almond antique blue royal burnished')`: Filters the `parts` collection to select the part named 'almond antique blue royal burnished'.
    2.  `part_spm_calculation = target_part.CALCULATE(...)`: Initiates the first calculation step on the selected part.
    3.  `part_name = name`: Selects the name of the part.
    4.  `total_sales = DEFAULT_TO(SUM(lines.WHERE(...).extended_price), 0.0)`: Calculates the total sales amount. It accesses the `lines` sub-collection of the `target_part`, filters these lines based on the supplier's nation ('CHINA') and the order date (February 1996), accesses the `extended_price` of the filtered lines, and computes their `SUM`. `DEFAULT_TO` ensures the result is 0.0 if no lines match the criteria.
    5.  `total_tax = DEFAULT_TO(SUM(lines.WHERE(...).tax), 0.0)`: Similarly calculates the total tax amount from the same set of filtered lines, defaulting to 0.0 if necessary.
    6.  `.CALCULATE(...)`: This second `CALCULATE` operates on the result of the first, carrying over `part_name`, `total_sales`, and `total_tax`.
    7.  `supplier_country = 'CHINA'`: Adds the supplier country context ('CHINA') to the result.
    8.  `selling_profit_margin = IFF(...)`: Calculates the SPM using the formula `(total_sales - total_tax) / total_sales * 100.0`. The `IFF` function handles the case where `total_sales` is zero to avoid division by zero, setting the SPM to 0.0 in that scenario. Multiplying by `100.0` ensures the result is a percentage.
    9.  `final_result = part_spm_calculation.CALCULATE(...)`: This final `CALCULATE` selects only the required output fields: `part_name`, `supplier_country`, and the calculated `selling_profit_margin`.

*   **Correction Summary**: The error `'Expected an expression, but received a collection'` was resolved by moving the `lines.WHERE(...)` filter inside the `SUM` aggregation function within the `CALCULATE` clause, rather than trying to assign the filtered collection to an intermediate variable. The part name was also corrected to match the original question.","# Filter for the specific part mentioned in the original question
target_part = parts.WHERE(name == 'almond antique blue royal burnished')

# CALCULATE SPM directly within CALCULATE by filtering lines and aggregating
part_spm_calculation = target_part.CALCULATE(
    part_name = name,
    # CALCULATE total sales from relevant lines by filtering within SUM
    total_sales = DEFAULT_TO(SUM(
        lines.WHERE(
            (supplier.nation.name == 'CHINA') &
            (YEAR(order.order_date) == 1996) &
            (MONTH(order.order_date) == 2)
        ).extended_price # Access extended_price after filtering
    ), 0.0),
    # CALCULATE total tax from relevant lines by filtering within SUM
    total_tax = DEFAULT_TO(SUM(
        lines.WHERE(
            (supplier.nation.name == 'CHINA') &
            (YEAR(order.order_date) == 1996) &
            (MONTH(order.order_date) == 2)
        ).tax # Access tax after filtering
    ), 0.0)
).CALCULATE(
    # Carry over necessary fields
    part_name = part_name,
    total_sales = total_sales, # Carry over total_sales for SPM calculation
    total_tax = total_tax,     # Carry over total_tax for SPM calculation
    # Add supplier country context
    supplier_country = 'CHINA',
    # CALCULATE Selling Profit Margin (SPM)
    selling_profit_margin = IFF(
        total_sales == 0,
        0.0, # Define SPM as 0 if there are no sales
        (total_sales - total_tax) / total_sales * 100.0 # Multiply by 100.0 for percentage
    )
)

# Select only the requested fields for the final output
final_result = part_spm_calculation.CALCULATE(
    part_name=part_name,
    supplier_country=supplier_country,
    selling_profit_margin=selling_profit_margin
)",No Match,
