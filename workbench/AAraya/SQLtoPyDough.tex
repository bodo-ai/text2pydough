\documentclass{article}
\usepackage{geometry}
\usepackage{hyperref}
\setlength{\parskip}{0.5em} % Adjust the space as needed
\usepackage{listings}
\usepackage{xcolor}

% Define SQL style for listings
\lstdefinelanguage{SQL}{
    keywords={SELECT, FROM, WHERE, INSERT, INTO, VALUES, UPDATE, DELETE, JOIN, INNER, LEFT, RIGHT, OUTER, ON, CREATE, TABLE, PRIMARY, KEY, FOREIGN, REFERENCES, INT, VARCHAR, TEXT, CHECK, NOT, NULL},
    keywordstyle=\color{blue}\bfseries,
    morekeywords={INT, PRIMARY, KEY, FOREIGN, REFERENCES, CHECK, NOT, NULL, TEXT, VARCHAR},
    keywordstyle=[2]\color{teal}\bfseries,
    morecomment=[l]{--},   
    commentstyle=\color{gray},
    morestring=[b]',
    morestring=[b]"
}

\lstset{
    language=SQL,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    frame=single,
    showstringspaces=false,
    tabsize=4,
    captionpos=b
}

% Define JSON formatting for listings
\lstdefinelanguage{json}{
    basicstyle=\ttfamily\small,
    stepnumber=1,
    numbersep=5pt,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    literate=
     *{0}{{{\color{blue}0}}}{1}
      {1}{{{\color{blue}1}}}{1}
      {2}{{{\color{blue}2}}}{1}
      {3}{{{\color{blue}3}}}{1}
      {4}{{{\color{blue}4}}}{1}
      {5}{{{\color{blue}5}}}{1}
      {6}{{{\color{blue}6}}}{1}
      {7}{{{\color{blue}7}}}{1}
      {8}{{{\color{blue}8}}}{1}
      {9}{{{\color{blue}9}}}{1}
      {:}{{{\color{red}:}}}{1},
}



\title{PyDough Knowledge Graph Creation: From Relational Data to Graph-Based Metadata}
\author{Adriel Araya Vargas}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

This document serves as a comprehensive tutorial on constructing a knowledge graph in PyDough, based on relational data. The tutorial is designed for converting relational database schemas into PyDough metadata, ensuring a structured and efficient approach to representing data. For this example, we will be working with a schema written in SQLite. 

This tutorial takes a hands-on approach, walking you through the entire workflow of creating a PyDough knowledge graph. Along the way, we will integrate key concepts from the PyDough metadata documentation to ensure a thorough understanding of how different components interact. 

The guide is structured as follows:
\begin{itemize}
    \item Understanding the Data Schema
    \item Defining Collections and Properties
    \item Establishing Simple Relationships (Joins)
    \item Implementing Compound Relationships
    \item Validating the Graph Structure
\end{itemize}

\section{Understanding the Data Schema}

To construct our knowledge graph in PyDough, we first need to define the underlying relational database schema. In this tutorial, we will use a university database that models departments, professors, students, courses, and study partnerships. This schema contains a variety of relationships, including one-to-one, one-to-many, many-to-many, and self-referencing relationships to showcase how the graphs convert all this kind of relationships.

\subsection{Relational Database Schema}

Below is the SQL schema that we will use as the foundation for our PyDough knowledge graph:

\begin{lstlisting}[language=SQL, caption={University Database Schema}]
-- One-to-Many (Department → Professors)
CREATE TABLE Departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(100) NOT NULL,
    founded DATE
);

CREATE TABLE Professors (
    professor_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INT,
    is_active BOOLEAN,
    FOREIGN KEY (department_id) REFERENCES Departments(department_id)
);

-- One-to-One (Professor ↔ Office)
CREATE TABLE ProfessorOffices (
    professor_id INT PRIMARY KEY,
    office_number INT NOT NULL,
    building VARCHAR(100) NOT NULL,
    FOREIGN KEY (professor_id) REFERENCES Professors(professor_id)
);

-- Many-to-Many (Students ↔ Courses, Through Enrollments)
CREATE TABLE Students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE Courses (
    course_id INT PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL
);

CREATE TABLE Enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (course_id) REFERENCES Courses(course_id)
);

-- Self-referencing Many-to-Many (Student study partnerships)
CREATE TABLE StudentStudyPartner (
    student_id INT,
    partner_id INT,
    PRIMARY KEY (student_id, partner_id),
    FOREIGN KEY (student_id) REFERENCES Students(student_id),
    FOREIGN KEY (partner_id) REFERENCES Students(student_id)
);
\end{lstlisting}

\subsection{Schema Overview and Explanation}

This schema models the university system with the following entities and relationships:

\begin{itemize}
    \item \textbf{One-to-Many:} Each department can have multiple professors. The \texttt{Professors} table contains a foreign key \texttt{department\_id} referencing the \texttt{Departments} table.
    \item \textbf{One-to-One:} Each professor has exactly one office. The \texttt{ProfessorOffices} table uses \texttt{professor\_id} as both the primary key and foreign key, ensuring a one-to-one relationship.
    \item \textbf{Many-to-Many:} Students enroll in multiple courses, and courses have multiple students. The \texttt{Enrollments} table serves as a bridge table to connect \texttt{Students} and \texttt{Courses}.
    \item \textbf{Self-referencing Many-to-Many:} Students can form study partnerships with other students. The \texttt{StudentStudyPartner} table creates self-referencing relationships, ensuring students can be partners but not with themselves.
\end{itemize}

This structured schema will serve as the basis for transforming relational data into a PyDough knowledge graph, which we will cover in the next sections.

\section{Defining Collections and Properties}

\subsection{Understanding the Metadata Structure}
In PyDough, knowledge graphs are defined using JSON metadata files. These files store structured data representing the entities, attributes, and relationships of a dataset. A metadata file consists of:
\begin{itemize}
    \item \textbf{Graphs}: Logical groupings of related collections.
    \item \textbf{Collections}: Corresponding to SQL tables, collections represent entities.
    \item \textbf{Properties}: Attributes of the tables and their relationships between other tables.
\end{itemize}

The main most simple structure for our example is shown below:

\begin{verbatim}
{
    "UniversityGraph": {
        "Students": {...},
        "Professors": {...},
        "Courses": {...},
        "Departments": {...}
    }
}
\end{verbatim}

As you can see this part represents the Graph and it's collections. This structure allows defining multiple logical datasets within the same metadata file.

\subsection{Defining Collections}
Each SQL table corresponds to a collection in PyDough. Initially, we define empty collections with:
\begin{itemize}
    \item \textbf{type}: Always set to \texttt{"simple\_table"} for standard SQL tables.
    \item \textbf{table\_path}: The SQL table name and location.
    \item \textbf{unique\_properties}: The primary key(s) of the table. This can be one unique atribute, "unique properties:["attribute"] or a mix of atributes that create a unique key "unique properties: ["attribute1","attribute2"].
    \item \textbf{properties}: Initially left empty. Solved on next step.
\end{itemize}

Here is how the metadata graph would look after defining the collections: 

\begin{verbatim}
{
    "University": {
        "Students": {
            "type": "simple_table",
            "table_path": "main.students",
            "unique_properties": ["student_id"],
            "properties": {}
        },
        "Professors": {
            "type": "simple_table",
            "table_path": "main.professors",
            "unique_properties": ["professor_id"],
            "properties": {}
        },
        "Departments": {
            "type": "simple_table",
            "table_path": "main.departments",
            "unique_properties": ["department_id"],
            "properties": {}
        },
        "Courses": {
            "type": "simple_table",
            "table_path": "main.courses",
            "unique_properties": ["course_id"],
            "properties": {}
        },
        "Enrollments": {
            "type": "simple_table",
            "table_path": "main.enrollments",
            "unique_properties": [["student_id", "course_id"]],
            "properties": {}
        },
        "ProfessorOffices": {
            "type": "simple_table",
            "table_path": "main.professor_offices",
            "unique_properties": ["professor_id"],
            "properties": {}
        },
        "StudentStudyPartner": {
            "type": "simple_table",
            "table_path": "main.student_study_partner",
            "unique_properties": [["student_id", "partner_id"]],
            "properties": {}
        }
    }
}
\end{verbatim}

At this stage, collections exist but lack properties.

\subsection{Defining Properties}
Each property in a collection corresponds to a specific characteristic of an entity. In PyDough, properties can be categorized into:
\begin{itemize}
    \item \textbf{Attributes}: These represent SQL table columns, storing direct data about an entity.
    \item \textbf{Relationships}: These define connections between collections, linking entities through joins or compound relationships.
\end{itemize}

\subsubsection{Atributes}

At this stage, we focus on defining \textbf{attributes}, which map directly to SQL table columns. Each attribute includes:
\begin{itemize}
    \item \textbf{type}: Always \texttt{"table\_column"} for a SQL table column.
    \item \textbf{column\_name}: The SQL column name.
    \item \textbf{data\_type}: The data type.
\end{itemize}

Now, we add properties to collections:


\begin{verbatim}
{
    "University": {
        "Students": {
            "type": "simple_table",
            "table_path": "main.students",
            "unique_properties": ["student_id"],
            "properties": {
                "student_id": {"type": "table_column", "column_name": "student_id", "data_type": "int32"},
                "name": {"type": "table_column", "column_name": "name", "data_type": "string"}
            }
        },
        "Professors": {
            "type": "simple_table",
            "table_path": "main.professors",
            "unique_properties": ["professor_id"],
            "properties": {
                "professor_id": {"type": "table_column", "column_name": "professor_id", "data_type": "int32"},
                "name": {"type": "table_column", "column_name": "name", "data_type": "string"},
                "department_id": {"type": "table_column", "column_name": "department_id", "data_type": "int32"},
                "is_active": {"type": "table_column", "column_name": "is_active", "data_type": "boolean"}
            }
        },
        "Departments": {
            "type": "simple_table",
            "table_path": "main.departments",
            "unique_properties": ["department_id"],
            "properties": {
                "department_id": {"type": "table_column", "column_name": "department_id", "data_type": "int32"},
                "department_name": {"type": "table_column", "column_name": "department_name", "data_type": "string"},
                "founded": {"type": "table_column", "column_name": "founded", "data_type": "date"}
            }
        },
        "Courses": {
            "type": "simple_table",
            "table_path": "main.courses",
            "unique_properties": ["course_id"],
            "properties": {
                "course_id": {"type": "table_column", "column_name": "course_id", "data_type": "int32"},
                "course_name": {"type": "table_column", "column_name": "course_name", "data_type": "string"}
            }
        },
        "Enrollments": {
            "type": "simple_table",
            "table_path": "main.enrollments",
            "unique_properties": [["student_id", "course_id"]],
            "properties": {
                "student_id": {"type": "table_column", "column_name": "student_id", "data_type": "int32"},
                "course_id": {"type": "table_column", "column_name": "course_id", "data_type": "int32"}
            }
        },
        "ProfessorOffices": {
            "type": "simple_table",
            "table_path": "main.professor_offices",
            "unique_properties": ["professor_id"],
            "properties": {
                "professor_id": {"type": "table_column", "column_name": "professor_id", "data_type": "int32"},
                "office_number": {"type": "table_column", "column_name": "office_number", "data_type": "int32"},
                "building": {"type": "table_column", "column_name": "building", "data_type": "string"}
            }
        },
        "StudentStudyPartner": {
            "type": "simple_table",
            "table_path": "main.student_study_partner",
            "unique_properties": [["student_id", "partner_id"]],
            "properties": {
                "student_id": {"type": "table_column", "column_name": "student_id", "data_type": "int32"},
                "partner_id": {"type": "table_column", "column_name": "partner_id", "data_type": "int32"}
            }
        }
    }
}
\end{verbatim}

\subsubsection{Simple Relationships}
In PyDough, simple relationships are direct mappings between tables that reflect the foreign key constraints in relational databases. These relationships are used to define one-to-many and many-to-one connections between collections.

Each simple relationship is a  property \textbf{property} defined using:
\begin{itemize}
    \item \textbf{other\_collection\_name}: The name of the related collection.
    \item \textbf{singular}: A boolean indicating whether the relationship is one-to-one (true) or one-to-many (false).
    \item \textbf{no\_collisions}: A boolean ensuring uniqueness of the relationship. It is **true** when the reverse relationship is singular.
    \item \textbf{keys}: A mapping of columns between the two collections.
    \item \textbf{reverse\_relationship\_name}: The name given to the reverse relationship.
\end{itemize}

\paragraph{One-to-One Relationship:}

A \textbf{one-to-one relationship} means that each record in a table corresponds to exactly one record in another table. In our schema, each professor has a unique office.


\begin{lstlisting}[language=SQL]
CREATE TABLE Professors (
    professor_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INT,
    is_active BOOLEAN,
    FOREIGN KEY (department_id) REFERENCES Departments(department_id)
);

CREATE TABLE ProfessorOffices (
    professor_id INT PRIMARY KEY,
    office_number INT NOT NULL,
    building VARCHAR(100) NOT NULL,
    FOREIGN KEY (professor_id) REFERENCES Professors(professor_id)
);
\end{lstlisting}

 
In PyDough, we represent this as a \textbf{simple relationship}, but the relationship is defined \textbf{in ProfessorOffices}, since each professor can have only one office.

\begin{lstlisting}[language=json]
{
  "Professors": {
    "type": "simple_table",
    "table_path": "main.professors",
    "unique_properties": ["professor_id"],
    "properties": {
      "professor_id": {"type": "table_column", "column_name": "professor_id", "data_type": "int32"},
      "name": {"type": "table_column", "column_name": "name", "data_type": "string"},
      "department_id": {"type": "table_column", "column_name": "department_id", "data_type": "int32"},
      "is_active": {"type": "table_column", "column_name": "is_active", "data_type": "boolean"}
    }
  },
  "ProfessorOffices": {
    "type": "simple_table",
    "table_path": "main.professor_offices",
    "unique_properties": ["professor_id"],
    "properties": {
      "professor_id": {"type": "table_column", "column_name": "professor_id", "data_type": "int32"},
      "office_number": {"type": "table_column", "column_name": "office_number", "data_type": "int32"},
      "building": {"type": "table_column", "column_name": "building", "data_type": "string"},
      "professor": {
        "type": "simple_join",
        "other_collection_name": "Professors",
        "singular": true,
        "no_collisions": true,
        "keys": { "professor_id": ["professor_id"] },
        "reverse_relationship_name": "office"
      }
    }
  }
}
\end{lstlisting}

\paragraph{Explanation:}
\begin{itemize}
    \item The \texttt{ProfessorOffices} collection includes the \texttt{professor} relationship, linking each office to a single professor.
    \item The \texttt{Professors} collection does not contain an explicit relationship, as PyDough automatically infers it from \texttt{ProfessorOffices}.
    \item \textbf{singular: true} ensures that each office is associated with only one professor.
    \item \textbf{no\_collisions: true} enforces uniqueness, meaning one office cannot belong to multiple professors.
\end{itemize}


\paragraph{One-to-Many Relationship:}

A \textbf{one-to-many} relationship occurs when a single record in one table relates to multiple records in another. In SQL, this is commonly represented by a foreign key.

For example, in our SQL schema, each department has multiple professors, but each professor belongs to only one department:

.

\begin{lstlisting}[language=SQL]
CREATE TABLE Departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(100) NOT NULL,
    founded DATE
);

CREATE TABLE Professors (
    professor_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INT,
    is_active BOOLEAN,
    FOREIGN KEY (department_id) REFERENCES Departments(department_id)
);

\end{lstlisting}

In PyDough, this is represented using simple relationships:

\begin{lstlisting}[language=json]
"Departments": {
    "type": "simple_table",
    "table_path": "main.departments",
    "unique_properties": ["department_id"],
    "properties": {
        "department_id": {"type": "table_column", "column_name": "department_id", "data_type": "int32"},
        "department_name": {"type": "table_column", "column_name": "department_name", "data_type": "string"},
        "founded": {"type": "table_column", "column_name": "founded", "data_type": "date"},
    }
}
"Professors": {
    "type": "simple_table",
    "table_path": "main.professors",
    "unique_properties": ["professor_id"],
    "properties": {
        "professor_id": {"type": "table_column", "column_name": "professor_id", "data_type": "int32"},
        "name": {"type": "table_column", "column_name": "name", "data_type": "string"},
        "department_id": {"type": "table_column", "column_name": "department_id", "data_type": "int32"},
        "is_active": {"type": "table_column", "column_name": "is_active", "data_type": "boolean"},
        "department": {
            "type": "simple_join",
            "other_collection_name": "Departments",
            "singular": true,
            "no_collisions": false,
            "keys": { "department_id": ["department_id"] },
            "reverse_relationship_name": "professors"
        }
    }
},
\end{lstlisting}

\textbf{Explanation:}
\begin{itemize}
    \item The \texttt{Professors} collection defines a \texttt{department} relationship, which connects each professor to a single \texttt{Departments} record.
    \item The relationship is not explicitly defined in \texttt{Departments} because it is automatically inferred from \texttt{Professors}.
    \item \textbf{singular: true} in \texttt{Professors} ensures that each professor belongs to only one department.
    \item \textbf{no\_collisions: false} allows multiple professors to reference the same department.
\end{itemize}

\end{document}