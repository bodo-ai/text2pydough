[{"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH cust_tx_stats AS (SELECT c.sbCustId, c.sbCustName, COUNT(t.sbTxId) AS total_tx, SUM(CASE WHEN t.sbTxStatus = 'success' THEN 1 ELSE 0 END) AS success_tx FROM sbCustomer AS c JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId GROUP BY c.sbCustId, c.sbCustName) SELECT sbCustName, CAST(success_tx AS FLOAT) / total_tx * 100 AS success_rate FROM cust_tx_stats WHERE total_tx >= 5 ORDER BY CASE WHEN success_rate IS NULL THEN 1 ELSE 0 END, success_rate;", "question": "For customers with at least 5 total transactions, what is their transaction success rate? Return the customer name and success rate, ordered from lowest to highest success rate.", "instructions": "\nFollow the instructions below to generate the query:\nTo get the success rate of transactions per customer, join customer and transaction tables, group by customer, and calculate the percentage of successful transactions.\n", "full_instructions": "CR = customer rank by total transaction amount, with different rankings based on transaction amounts MoMC = month-over-month change in average closing price based on previous month's averages for each ticker each month To get the success rate of transactions per customer, join customer and transaction tables, group by customer, and calculate the percentage of successful transactions. Always join transactions with customers before using the transactions table. TAC = Total Active Customers who joined after a certain date", "generated_query": "SELECT c.sbCustName,\n       (SUM(CASE\n                WHEN t.sbTxStatus = 'success' THEN 1\n                ELSE 0\n            END) * 100.0 / COUNT(t.sbTxId)) AS success_rate\nFROM sbCustomer c\nJOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nGROUP BY c.sbCustId,\n         c.sbCustName\nHAVING COUNT(t.sbTxId) >= 5\nORDER BY success_rate ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.068173885345459, "tokens_used": 1095, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.26136000000000004}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH popular_stocks AS (SELECT t.sbTickerSymbol, COUNT(*) AS tx_count FROM sbTransaction AS tx JOIN sbTicker AS t ON tx.sbTxTickerId = t.sbTickerId WHERE tx.sbTxType = 'buy' AND tx.sbTxDateTime >= DATE('now', '-10 days') GROUP BY t.sbTickerSymbol) SELECT sbTickerSymbol, tx_count FROM popular_stocks ORDER BY tx_count DESC LIMIT 2;", "question": "What are the 2 most frequently bought stock ticker symbols in the past 10 days? Return the ticker symbol and number of buy transactions.", "instructions": "\nFollow the instructions below to generate the query:\nTo find the most popular stocks in the past 10 days, join the transaction and ticker tables, filter for buy transactions in the last 10 days, group by ticker and count transactions.\n", "full_instructions": "MoMC = month-over-month change in average closing price Weekend days refer to Saturday and Sunday; adjust dates to weeks for aggregation. To find the most popular stocks in the past 10 days, join the transaction and ticker tables, filter for buy transactions in the last 10 days, group by ticker and count transactions. CR = customer rank by total transaction volume, where rank 1 belongs to the customer with the highest volume", "generated_query": "SELECT t.sbTickerSymbol,\n       COUNT(*) AS buy_count\nFROM sbTransaction tx\nJOIN sbTicker t ON tx.sbTxTickerId = t.sbTickerId\nWHERE tx.sbTxType = 'buy'\n  AND tx.sbTxDateTime >= date('now', '-10 days')\nGROUP BY t.sbTickerSymbol\nORDER BY buy_count DESC\nLIMIT 2;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.4906370639801025, "tokens_used": 1014, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22407000000000005}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH stock_stats AS (SELECT t.sbTickerSymbol, MIN(d.sbDpLow) AS min_price, MAX(d.sbDpHigh) AS max_price FROM sbDailyPrice AS d JOIN sbTicker AS t ON d.sbDpTickerId = t.sbTickerId WHERE d.sbDpDate BETWEEN '2023-04-01' AND '2023-04-04' GROUP BY t.sbTickerSymbol) SELECT sbTickerSymbol, max_price - min_price AS price_change FROM stock_stats ORDER BY CASE WHEN price_change IS NULL THEN 1 ELSE 0 END DESC, price_change DESC LIMIT 3;", "question": "Which 3 distinct stocks had the highest price change between the low and high from April 1 2023 to April 4 2023? I want the different in the low and high throughout this timerange, not just the intraday price changes. Return the ticker symbol and price change.", "instructions": "\nFollow the instructions below to generate the query:\nTo analyze stock performance, join the daily price and ticker tables, filter for a specific date range, and calculate price change.\n", "full_instructions": "PMCS = per month customer signups\nTAC = Total Active Customers who joined after a certain date\nPMAT = per month average transaction amount, using date truncation for aggregation.\nTo analyze stock performance, join the daily price and ticker tables, filter for a specific date range, and calculate price change.\nCR = customer rank by total transaction amount, with the highest transaction amount getting the top rank", "generated_query": "SELECT t.sbTickerSymbol,\n       (MAX(d.sbDpHigh) - MIN(d.sbDpLow)) AS price_change\nFROM sbDailyPrice d\nJOIN sbTicker t ON d.sbDpTickerId = t.sbTickerId\nWHERE d.sbDpDate BETWEEN '2023-04-01' AND '2023-04-04'\nGROUP BY t.sbTickerSymbol\nORDER BY price_change DESC\nLIMIT 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.544935941696167, "tokens_used": 1236, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.31548000000000004}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH cust_tx AS (SELECT c.sbCustId, c.sbCustName, SUM(t.sbTxAmount) AS total_amount FROM sbCustomer AS c JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId GROUP BY c.sbCustId, c.sbCustName) SELECT sbCustName, total_amount FROM cust_tx ORDER BY CASE WHEN total_amount IS NULL THEN 1 ELSE 0 END DESC, total_amount DESC LIMIT 5;", "question": "Who are the top 5 customers by total transaction amount? Return their name and total amount.", "instructions": "\nFollow the instructions below to generate the query:\nTo get the total transaction amount per customer, join the customer and transaction tables, group by customer, and sum the transaction amounts.\n", "full_instructions": "To get the total transaction amount per customer, join the customer and transaction tables, group by customer, and sum the transaction amounts.\nTAC = Total Active Customers who have recently joined\nMoMC = Month-over-month change in average closing price for each ticker.\nACP = Average Closing Price of tickers over a recent period", "generated_query": "SELECT c.sbCustName,\n       SUM(t.sbTxAmount) AS total_amount\nFROM sbCustomer c\nJOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nGROUP BY c.sbCustId,\n         c.sbCustName\nORDER BY total_amount DESC\nLIMIT 5;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.239605665206909, "tokens_used": 917, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18832000000000002}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH cust_tx_counts AS (SELECT sbTxCustId, COUNT(*) AS num_tx, SUM(sbTxAmount) AS total_amount FROM sbTransaction GROUP BY sbTxCustId) SELECT c.sbCustName, ct.num_tx, ct.total_amount, RANK() OVER (ORDER BY CASE WHEN ct.total_amount IS NULL THEN 1 ELSE 0 END DESC, ct.total_amount DESC) AS cust_rank FROM cust_tx_counts AS ct JOIN sbCustomer AS c ON ct.sbTxCustId = c.sbCustId;", "question": "Return the customer name, number of transactions, total transaction amount, and CR for all customers", "instructions": "\nFollow the instructions below to generate the query:\nCR = customer rank by total transaction amount, with rank 1 being the customer with the highest total transaction amount\n", "full_instructions": "ACP = Average Closing Price of tickers over a select period of days\nTAC = Total Active Customers who have recently joined\nNPM (Net Profit Margin) = Net income divided by net sales for a specific time frame, expressed as a percentage for transactions in a recent period.\nCR = customer rank by total transaction amount, with rank 1 being the customer with the highest total transaction amount", "generated_query": "WITH customer_totals AS\n  (SELECT c.sbCustName,\n          COUNT(t.sbTxId) AS num_transactions,\n          COALESCE(SUM(t.sbTxAmount), 0) AS total_transaction_amount\n   FROM sbCustomer c\n   LEFT JOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\n   GROUP BY c.sbCustId,\n            c.sbCustName)\nSELECT sbCustName,\n       num_transactions,\n       total_transaction_amount,\n       RANK() OVER (\n                    ORDER BY total_transaction_amount DESC) AS CR\nFROM customer_totals;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.17841911315918, "tokens_used": 1162, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.29744000000000004}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH monthly_price_stats AS (SELECT strftime('%Y-%m', sbDpDate) AS month, sbDpTickerId, AVG(sbDpClose) AS avg_close, MAX(sbDpHigh) AS max_high, MIN(sbDpLow) AS min_low FROM sbDailyPrice GROUP BY month, sbDpTickerId) SELECT t.sbTickerSymbol, mps.month, mps.avg_close, mps.max_high, mps.min_low, (mps.avg_close - LAG(mps.avg_close) OVER (PARTITION BY mps.sbDpTickerId ORDER BY mps.month)) / LAG(mps.avg_close) OVER (PARTITION BY mps.sbDpTickerId ORDER BY mps.month) AS mom_change FROM monthly_price_stats AS mps JOIN sbTicker AS t ON mps.sbDpTickerId = t.sbTickerId;WITH monthly_price_stats AS (SELECT strftime('%Y-%m-01', sbDpDate) AS month, sbDpTickerId, AVG(sbDpClose) AS avg_close, MAX(sbDpHigh) AS max_high, MIN(sbDpLow) AS min_low FROM sbDailyPrice GROUP BY month, sbDpTickerId) SELECT t.sbTickerSymbol, mps.month, mps.avg_close, mps.max_high, mps.min_low, (mps.avg_close - LAG(mps.avg_close) OVER (PARTITION BY mps.sbDpTickerId ORDER BY mps.month)) / LAG(mps.avg_close) OVER (PARTITION BY mps.sbDpTickerId ORDER BY mps.month) AS mom_change FROM monthly_price_stats AS mps JOIN sbTicker AS t ON mps.sbDpTickerId = t.sbTickerId;WITH monthly_price_stats AS (SELECT strftime('%Y-%m-01 %H:%M:%S', sbDpDate) AS month, sbDpTickerId, AVG(sbDpClose) AS avg_close, MAX(sbDpHigh) AS max_high, MIN(sbDpLow) AS min_low FROM sbDailyPrice GROUP BY month, sbDpTickerId) SELECT t.sbTickerSymbol, mps.month, mps.avg_close, mps.max_high, mps.min_low, (mps.avg_close - LAG(mps.avg_close) OVER (PARTITION BY mps.sbDpTickerId ORDER BY mps.month)) / LAG(mps.avg_close) OVER (PARTITION BY mps.sbDpTickerId ORDER BY mps.month) AS mom_change FROM monthly_price_stats AS mps JOIN sbTicker AS t ON mps.sbDpTickerId = t.sbTickerId;", "question": "What is the ticker symbol, month, average closing price, highest price, lowest price, and MoMC for each ticker by month?", "instructions": "\nFollow the instructions below to generate the query:\nMoMC = month-over-month change in average closing price = (avg_close_given_month - avg_close_previous_month) / avg_close_previous_month for each ticker symbol each month.\nRecall that we want the symbol, and not just the ticker id.\n", "full_instructions": "NPM (Net Profit Margin) = (Total Income from Sales - (Tax + Commission Expenses)) / Total Income from Sales * 100, for recent transactions. TAC = Total Active Customers who have recently joined ACP = Average Closing Price of tickers over a recent period MoMC = month-over-month change in average closing price = (avg_close_given_month - avg_close_previous_month) / avg_close_previous_month for each ticker each month", "generated_query": "WITH monthly_stats AS\n  (SELECT dp.sbDpTickerId,\n          strftime('%Y-%m', dp.sbDpDate) AS MONTH,\n          AVG(dp.sbDpClose) AS avg_close,\n          MAX(dp.sbDpHigh) AS highest_price,\n          MIN(dp.sbDpLow) AS lowest_price\n   FROM sbDailyPrice dp\n   GROUP BY dp.sbDpTickerId,\n            MONTH)\nSELECT t.sbTickerSymbol,\n       m.month,\n       m.avg_close,\n       m.highest_price,\n       m.lowest_price,\n       ((m.avg_close - LAG(m.avg_close) OVER (PARTITION BY m.sbDpTickerId\n                                              ORDER BY m.month)) / LAG(m.avg_close) OVER (PARTITION BY m.sbDpTickerId\n                                                                                          ORDER BY m.month)) AS MoMC\nFROM monthly_stats m\nJOIN sbTicker t ON t.sbTickerId = m.sbDpTickerId\nORDER BY t.sbTickerSymbol,\n         m.month;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.797902822494507, "tokens_used": 1530, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44781000000000004}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT strftime('%Y-%W', t.sbTxDateTime) AS WEEK, COUNT(t.sbTxId) AS num_transactions, COUNT(CASE WHEN strftime('%w', t.sbTxDateTime) IN ('0', '6') THEN 1 END) AS weekend_transactions FROM sbTransaction AS t JOIN sbTicker AS tk ON t.sbTxTickerId = tk.sbTickerId WHERE tk.sbTickerType = 'stock' AND t.sbTxDateTime >= DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-56 days') AND t.sbTxDateTime < DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days') GROUP BY WEEK;SELECT DATE(t.sbTxDateTime,  '-' || ((strftime('%w', t.sbTxDateTime) + 6) % 7) || ' days') AS WEEK, COUNT(t.sbTxId) AS num_transactions, COUNT(CASE WHEN strftime('%w', t.sbTxDateTime) IN ('0', '6') THEN 1 END) AS weekend_transactions FROM sbTransaction AS t JOIN sbTicker AS tk ON t.sbTxTickerId = tk.sbTickerId WHERE tk.sbTickerType = 'stock' AND t.sbTxDateTime >= DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-56 days') AND t.sbTxDateTime < DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days') GROUP BY WEEK;", "question": "How many transactions for stocks occurred in each of the last 8 weeks excluding the current week? How many of these transactions happened on weekends?", "instructions": "\nFollow the instructions below to generate the query:\nWeekend days are Saturday and Sunday.\nTruncate date to week for aggregation.\n", "full_instructions": "For an analysis of stock performance, link daily price data with ticker information, select a relevant time period, and calculate the change in price\nTo determine the success rate of transactions for each customer, merge customer and transaction records, group by customer ID, and compute the ratio of successful transactions.\nWeekend days are Saturday and Sunday. Truncate date to week for aggregation.\nTo get the total amount of transactions per customer, perform a join between customer and transaction datasets, then group by customer ID and sum up the transaction amounts", "generated_query": "SELECT strftime('%Y-%W', t.sbTxDateTime) AS WEEK,\n       COUNT(*) AS total_transactions,\n       SUM(CASE\n               WHEN strftime('%w', t.sbTxDateTime) IN ('0', '6') THEN 1\n               ELSE 0\n           END) AS weekend_transactions\nFROM sbTransaction t\nJOIN sbTicker tk ON t.sbTxTickerId = tk.sbTickerId\nWHERE tk.sbTickerType = 'stock' -- Exclude the current week and include only the last 8 complete weeks:\n\n  AND strftime('%Y-%W', t.sbTxDateTime) < strftime('%Y-%W', 'now')\n  AND strftime('%Y-%W', t.sbTxDateTime) >= strftime('%Y-%W', date('now', '-8 weeks'))\nGROUP BY WEEK\nORDER BY WEEK;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 9.650267601013184, "tokens_used": 2504, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.8872600000000002}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT COUNT(DISTINCT sb.sbTxId) AS num_transactions, SUM(sb.sbTxAmount) AS total_transaction_amount FROM sbTransaction AS sb JOIN sbCustomer AS sc ON sb.sbTxCustId = sc.sbCustId WHERE LOWER(sc.sbCustCountry) = 'usa' AND sb.sbTxDateTime >= DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-7 days') AND sb.sbTxDateTime < DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days');", "question": "How many transactions were made by customers from the USA last week (exclusive of the current week)? Return the number of transactions and total transaction amount.", "instructions": "\nFollow the instructions below to generate the query:\nLast week = DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-7 days') to before DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days').\nAlways join transactions with customers before using the transactions table.\n", "full_instructions": "To analyze stock performance, join the daily price and ticker tables and calculate price change To get the total transaction amount per customer, join the customer and transaction tables, group by customer, and sum the transaction amounts. Last week = DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-7 days') to before DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days'). Always join transactions with customers before using the transactions table. To get the success rate of transactions per customer, join customer and transaction tables, group by customer, and calculate the percentage of successful transactions", "generated_query": "SELECT COUNT(t.sbTxId) AS num_transactions,\n       SUM(t.sbTxAmount) AS total_transaction_amount\nFROM sbTransaction t\nJOIN sbCustomer c ON c.sbCustId = t.sbTxCustId\nWHERE c.sbCustCountry = 'USA'\n  AND t.sbTxDateTime >= DATE('now', '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-7 days')\n  AND t.sbTxDateTime < DATE('now', '-' || ((strftime('%w', 'now') + 6) % 7) || ' days');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.070141553878784, "tokens_used": 1551, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44814}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT strftime('%Y-%m', sbCustJoinDate) AS MONTH, COUNT(sbCustId) AS customer_signups, AVG(t.sbTxAmount) AS avg_tx_amount FROM sbCustomer AS c LEFT JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId AND strftime('%Y-%m', t.sbTxDateTime) = strftime('%Y-%m', c.sbCustJoinDate) WHERE sbCustJoinDate >= date('now', '-6 months', 'start of month') AND sbCustJoinDate < date('now', 'start of month') GROUP BY MONTH;SELECT strftime('%Y-%m-01', sbCustJoinDate) AS MONTH, COUNT(sbCustId) AS customer_signups, AVG(t.sbTxAmount) AS avg_tx_amount FROM sbCustomer AS c LEFT JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId AND strftime('%Y-%m', t.sbTxDateTime) = strftime('%Y-%m', c.sbCustJoinDate) WHERE sbCustJoinDate >= date('now', '-6 months', 'start of month') AND sbCustJoinDate < date('now', 'start of month') GROUP BY MONTH;SELECT strftime('%Y-%m-01 %H:%M:%S', sbCustJoinDate) AS MONTH, COUNT(sbCustId) AS customer_signups, AVG(t.sbTxAmount) AS avg_tx_amount FROM sbCustomer AS c LEFT JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId AND strftime('%Y-%m', t.sbTxDateTime) = strftime('%Y-%m', c.sbCustJoinDate) WHERE sbCustJoinDate >= date('now', '-6 months', 'start of month') AND sbCustJoinDate < date('now', 'start of month') GROUP BY MONTH;", "question": "What are the PMCS and PMAT for customers who signed up in the last 6 months excluding the current month?", "instructions": "\nFollow the instructions below to generate the query:\nPMCS = per month customer signups.\nPMAT = per month average transaction amount.\nTruncate date to month for aggregation.\n", "full_instructions": "ACP = Average Closing Price of tickers over a selected period, including the end day\nCR = customer rank by total transaction amount, where the top customer has the highest amount.\nPMCS = per month customer signups. PMAT = per month average transaction amount. Truncate date to month for aggregation.\nTAC = Total Active Customers who joined after a specified date", "generated_query": "SELECT strftime('%Y-%m', c.sbCustJoinDate) AS SignupMonth,\n       COUNT(c.sbCustId) AS PMCS,\n       AVG(t.sbTxAmount) AS PMAT\nFROM sbCustomer c\nLEFT JOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nWHERE c.sbCustJoinDate >= date('now', '-6 months', 'start of month')\n  AND c.sbCustJoinDate < date('now', 'start of month')\nGROUP BY strftime('%Y-%m', c.sbCustJoinDate);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 10.30931830406189, "tokens_used": 2193, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.74811}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "WITH active_customers AS (SELECT c.sbCustId, COUNT(t.sbTxId) AS num_transactions FROM sbCustomer AS c JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId AND strftime('%Y-%m', c.sbCustJoinDate) = strftime('%Y-%m', t.sbTxDateTime) GROUP BY c.sbCustId) SELECT ac.sbCustId, c.sbCustName, ac.num_transactions FROM active_customers AS ac JOIN sbCustomer AS c ON ac.sbCustId = c.sbCustId ORDER BY ac.num_transactions DESC LIMIT 1;", "question": "Which customer made the highest number of transactions in the same month as they signed up? Return the customer's id, name and number of transactions.", "instructions": "\nFollow the instructions below to generate the query:\nIf transactions from 2 different tables from the same interval are to be joined, join on the respective truncated date fields eg `FROM t1 JOIN t2 ON DATE(t1.date, '<interval>') = DATE(t2.date, '<interval>').\n", "full_instructions": "To analyze the performance of stocks, join the tables for daily prices and tickers, filter for a designated time frame, and calculate the change in price To get the total transaction amount by each customer, you should join the customer and transaction tables, group by the customer, and sum up the amounts of the transactions If transactions from 2 different tables from the same interval are to be joined, join on the respective truncated date fields eg `FROM t1 JOIN t2 ON DATE(t1.date, '<interval>') = DATE(t2.date, '<interval>'). To identify the most popular stocks within a recent period, join the transaction table with the ticker table, filter for buy transactions during the last several days, group by the ticker symbol, and count the number of transactions.", "generated_query": "SELECT c.sbCustId AS id,\n       c.sbCustName AS name,\n       COUNT(t.sbTxId) AS num_transactions\nFROM sbCustomer c\nJOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nAND DATE(t.sbTxDateTime, 'start of month') = DATE(c.sbCustJoinDate, 'start of month')\nGROUP BY c.sbCustId,\n         c.sbCustName\nORDER BY num_transactions DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.5177106857299805, "tokens_used": 1502, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43416999999999994}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT COUNT(DISTINCT t.sbTxCustId) FROM sbTransaction AS t JOIN sbCustomer AS c ON t.sbTxCustId = c.sbCustId JOIN sbTicker AS tk ON t.sbTxTickerId = tk.sbTickerId WHERE c.sbCustEmail LIKE '%.com' AND (tk.sbTickerSymbol LIKE 'AMZN' OR tk.sbTickerSymbol LIKE 'AAPL' OR tk.sbTickerSymbol LIKE 'GOOGL' OR tk.sbTickerSymbol LIKE 'META' OR tk.sbTickerSymbol LIKE 'NFLX');", "question": "How many distinct customers with a .com email address bought stocks of FAANG companies (Amazon, Apple, Google, Meta or Netflix)?", "instructions": "\nFollow the instructions below to generate the query:\nCustomers with a '.com' email address who bought FAANG stocks (ticker symbol contains 'AMZN', 'AAPL', 'GOOGL', 'META' or 'NFLX')\n", "full_instructions": "MoMC = month-over-month change in average closing price = (average closing price of given month - average closing price of previous month) / average closing price of previous month for each ticker. ACP = Average Closing Price of tickers within a defined time frame TAC = Total Active Customers who have joined since a specific starting date Customers with a '.com' email address who bought FAANG stocks (ticker symbol contains 'AMZN', 'AAPL', 'GOOGL', 'META' or 'NFLX')", "generated_query": "SELECT COUNT(DISTINCT c.sbCustId)\nFROM sbCustomer c\nJOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nJOIN sbTicker tk ON t.sbTxTickerId = tk.sbTickerId\nWHERE c.sbCustEmail LIKE '%.com'\n  AND t.sbTxType = 'buy'\n  AND (tk.sbTickerSymbol LIKE '%AMZN%'\n       OR tk.sbTickerSymbol LIKE '%AAPL%'\n       OR tk.sbTickerSymbol LIKE '%GOOGL%'\n       OR tk.sbTickerSymbol LIKE '%META%'\n       OR tk.sbTickerSymbol LIKE '%NFLX%');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.435920476913452, "tokens_used": 1192, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.30272000000000004}, {"db_name": "broker", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT COUNT(sbCustId) FROM sbCustomer WHERE (LOWER(sbCustName) LIKE 'j%' OR LOWER(sbCustName) LIKE '%ez') AND LOWER(sbCustState) LIKE '%a';", "question": "What is the number of customers whose name starts with J or ends with 'ez', and who live in a state ending with the letter 'a'?", "instructions": "\nFollow the instructions below to generate the query:\nall customer attributes should be matched case insensitively\n", "full_instructions": "To get the total transaction amount per customer, join the customer and transaction tables, group by customer, and sum the transaction amounts To find the most popular stocks over a recent period, join the transaction and ticker tables, filter for buy transactions within that period, group by ticker, and count transactions. To analyze stock performance, join the daily price and ticker tables, filter for a specific date range, and calculate price change all customer attributes should be matched case insensitively", "generated_query": "SELECT COUNT(*)\nFROM sbCustomer\nWHERE (LOWER(sbCustName) LIKE 'j%'\n       OR LOWER(sbCustName) LIKE '%ez')\n  AND LOWER(sbCustState) LIKE '%a';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6608633995056152, "tokens_used": 831, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.15147000000000002}, {"db_name": "broker", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT sbCustCountry, COUNT(sbCustId) AS TAC FROM sbCustomer WHERE sbCustJoinDate >= '2023-01-01' GROUP BY sbCustCountry;", "question": "How many TAC are there from each country, for customers who joined on or after January 1, 2023? Return the country and the count.", "instructions": "\nFollow the instructions below to generate the query:\nTAC = Total Active Customers who joined on or after January 1, 2023\n", "full_instructions": "To analyze stock performance, join the daily price and stock symbol tables, filter for a designated date range, and compute the variation in price\nTo calculate the success rate of transactions for each customer, merge the customer and transaction records, aggregate by customer, and assess the rate of successful transactions\nTAC = Total Active Customers who joined on or after January 1, 2023\nTo ascertain the most sought-after stocks within a recent timeframe, combine the transaction and stock symbol datasets, focus on purchase actions during the specified period, group by stock symbol, and tally the transactions.", "generated_query": "SELECT sbCustCountry,\n       COUNT(*) AS COUNT\nFROM sbCustomer\nWHERE sbCustJoinDate >= '2023-01-01'\n  AND sbCustStatus = 'active'\nGROUP BY sbCustCountry;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.57922625541687, "tokens_used": 902, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18007}, {"db_name": "broker", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT sbTicker.sbTickerType, AVG(sbDailyPrice.sbDpClose) AS ACP FROM sbDailyPrice JOIN sbTicker ON sbDailyPrice.sbDpTickerId = sbTicker.sbTickerId WHERE sbDpDate >= DATE('now', '-7 days') GROUP BY sbTicker.sbTickerType;", "question": "What is the ACP for each ticker type in the past 7 days, inclusive of today? Return the ticker type and the average closing price.", "instructions": "\nFollow the instructions below to generate the query:\nACP = Average Closing Price of tickers in the last 7 days, inclusive of today\n", "full_instructions": "To determine the Activity Ratio (AR), divide the number of active customers by the total customer count and then multiply by 100, focusing on customers who joined within a particular year\nCustomer Rank (CR) is determined by ranking customers based on their total transaction amount, with rank 1 assigned to the customer with the highest amount.\nTo calculate Net Profit Margin (NPM), subtract the sum of tax and commission from the total amount obtained from sales, then divide by the total sales amount and multiply by 100, assessing transactions within a specific period\nACP = Average Closing Price of tickers in the last 7 days, inclusive of today", "generated_query": "SELECT t.sbTickerType,\n       AVG(dp.sbDpClose) AS ACP\nFROM sbDailyPrice dp\nJOIN sbTicker t ON dp.sbDpTickerId = t.sbTickerId\nWHERE dp.sbDpDate BETWEEN date('now', '-6 days') AND date('now')\nGROUP BY t.sbTickerType;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.1461613178253174, "tokens_used": 921, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18909}, {"db_name": "broker", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT c.sbCustCountry, COALESCE(100.0 * COUNT(DISTINCT CASE WHEN c.sbCustStatus = 'active' THEN c.sbCustId END) / NULLIF(COUNT(DISTINCT t.sbTxCustId), 0), 0) AS AR FROM sbCustomer AS c JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId WHERE c.sbCustJoinDate BETWEEN '2022-01-01' AND '2022-12-31' GROUP BY c.sbCustCountry;", "question": "What is the AR for each country for customers who joined in 2022? Return the country and AR.", "instructions": "\nFollow the instructions below to generate the query:\nAR (Activity Ratio) = (Number of Active Customers with Transactions / Total Number of Customers with Transactions) * 100.\n", "full_instructions": "To get the total transaction amount per customer, join the customer and transaction tables, group by customer, and sum the transaction amounts If transactions from 2 different tables from the same interval are to be joined, join on the respective truncated date fields. AR (Activity Ratio) = (Number of Active Customers with Transactions / Total Number of Customers with Transactions) * 100. To analyze stock performance, join the daily price and ticker tables, filter for a specific date range, and calculate the price change", "generated_query": "SELECT c.sbCustCountry AS country,\n       100.0 * COUNT(DISTINCT CASE\n                                  WHEN c.sbCustStatus = 'active' THEN c.sbCustId\n                              END) / COUNT(DISTINCT c.sbCustId) AS AR\nFROM sbCustomer c\nJOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nWHERE strftime('%Y', c.sbCustJoinDate) = '2022'\nGROUP BY c.sbCustCountry;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.743769407272339, "tokens_used": 1399, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.39974}, {"db_name": "broker", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT sbTickerSymbol, CASE WHEN SUM(sbTxAmount) = 0 THEN NULL ELSE (SUM(sbTxAmount) - SUM(sbTxTax + sbTxCommission)) / SUM(sbTxAmount) * 100 END AS SPM FROM sbTransaction JOIN sbTicker ON sbTransaction.sbTxTickerId = sbTicker.sbTickerId WHERE sbTxType = 'sell' AND sbTxDateTime >= DATE('now', '-1 month') GROUP BY sbTickerSymbol;", "question": "What is the SPM for each ticker symbol from sell transactions in the past month, inclusive of 1 month ago? Return the ticker symbol and SPM.", "instructions": "\nFollow the instructions below to generate the query:\nSPM (Selling Profit Margin) = (Total Amount from Sells - (Tax + Commission)) / Total Amount from Sells * 100\n", "full_instructions": "To calculate the Total Active Customers who have recently joined, the Average Closing Price of tickers within a recent period, and the Customer Rank by their total transaction volume, you would need different queries and calculations that are not directly related to calculating the Net Profit Margin (NPM) for sell transactions of ticker symbols in the past month. ACP = Calculate the Average Closing Price of tickers over a chosen recent time span Analyze customer signups over a certain period.\nSPM (Selling Profit Margin) = (Total Amount from Sells - (Tax + Commission)) / Total Amount from Sells * 100\nTAC = Total Active Customers who joined within a specified timeframe\nCR = Rank customers by their total transaction volume, identifying the customer with the highest transaction volume as rank 1. This involves joining price data with ticker identifiers and filtering for a specified date range.", "generated_query": "SELECT t.sbTickerSymbol,\n       100 * (SUM(tx.sbTxAmount) - SUM(tx.sbTxTax + tx.sbTxCommission)) / SUM(tx.sbTxAmount) AS SPM\nFROM sbTransaction tx\nJOIN sbTicker t ON tx.sbTxTickerId = t.sbTickerId\nWHERE tx.sbTxType = 'sell'\n  AND tx.sbTxDateTime >= date('now', '-1 month')\nGROUP BY t.sbTickerSymbol;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.720242738723755, "tokens_used": 1094, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.26059000000000004}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH recent_sales AS (SELECT sp.id, sp.first_name, sp.last_name, COUNT(s.id) AS num_sales FROM salespersons AS sp LEFT JOIN sales AS s ON sp.id = s.salesperson_id WHERE s.sale_date >= DATE('now', '-30 days') GROUP BY sp.id) SELECT id, first_name, last_name, num_sales FROM recent_sales ORDER BY num_sales DESC;WITH recent_sales AS (SELECT sp.id, sp.first_name, sp.last_name, COUNT(s.id) AS num_sales FROM salespersons AS sp LEFT JOIN sales AS s ON sp.id = s.salesperson_id AND s.sale_date >= DATE('now', '-30 days') GROUP BY sp.id, sp.first_name, sp.last_name) SELECT id, first_name, last_name, num_sales FROM recent_sales ORDER BY num_sales DESC;", "question": "How many sales did each salesperson make in the past 30 days, inclusive of today's date? Return their ID, first name, last name and number of sales made, ordered from most to least sales.", "instructions": "\nFollow the instructions below to generate the query:\nTo get the number of sales made by each salesperson in the past 30 days, join the salespersons and sales tables and filter for sales in the last 30 days.\n", "full_instructions": "When using car makes, model names, engine_type, and vin_number, ensure matching is case-insensitive and allows for partial matches using LIKE with wildcards.\nTo get the number of sales made by each salesperson in the past 30 days, join the salespersons and sales tables and filter for sales in the last 30 days.\nASP = Calculate the average sale price without specifying the period\nGPM = Define gross profit margin as a ratio without specifying how to calculate total revenue or total cost", "generated_query": "SELECT sp.id,\n       sp.first_name,\n       sp.last_name,\n       COUNT(s.id) AS number_of_sales\nFROM salespersons sp\nLEFT JOIN sales s ON sp.id = s.salesperson_id\nAND s.sale_date BETWEEN DATE('now', '-29 days') AND DATE('now')\nGROUP BY sp.id,\n         sp.first_name,\n         sp.last_name\nORDER BY number_of_sales DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.104989051818848, "tokens_used": 1657, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.40370000000000006}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH latest_inventory_status AS (SELECT car_id, is_in_inventory, ROW_NUMBER() OVER (PARTITION BY car_id ORDER BY CASE WHEN snapshot_date IS NULL THEN 1 ELSE 0 END DESC, snapshot_date DESC) AS rn FROM inventory_snapshots) SELECT c.make, c.model, MAX(s.sale_price) AS highest_sale_price FROM cars AS c JOIN sales AS s ON c.id = s.car_id JOIN latest_inventory_status AS lis ON c.id = lis.car_id WHERE lis.is_in_inventory = FALSE AND lis.rn = 1 GROUP BY c.make, c.model ORDER BY CASE WHEN highest_sale_price IS NULL THEN 1 ELSE 0 END DESC, highest_sale_price DESC;", "question": "Return the highest sale price for each make and model of cars that have been sold and are no longer in inventory, ordered by the sale price from highest to lowest. Use the most recent date in the inventory_snapshots table to determine that car's inventory status.", "instructions": "\nFollow the instructions below to generate the query:\nWhen getting a car's inventory status, always take the latest status from the inventory_snapshots table\n", "full_instructions": "Recall that a car can have multiple entries in the inventory_snapshot table. \nTSC = Count of sales within a specified period\nMoM = Change in total receivable amounts from one month to the next, comparing with the immediately preceding month.\nASP = Mean sale price for a designated start period\nWhen getting a car's inventory status, always take the latest status from the inventory_snapshots table", "generated_query": "SELECT c.make,\n       c.model,\n       MAX(s.sale_price) AS highest_sale_price\nFROM sales s\nJOIN cars c ON s.car_id = c.id\nJOIN\n  (SELECT i.car_id\n   FROM inventory_snapshots i\n   JOIN\n     (SELECT car_id,\n             MAX(snapshot_date) AS latest_snapshot_date\n      FROM inventory_snapshots\n      GROUP BY car_id) AS latest ON i.car_id = latest.car_id\n   AND i.snapshot_date = latest.latest_snapshot_date\n   WHERE i.is_in_inventory = 0) AS inv ON c.id = inv.car_id\nGROUP BY c.make,\n         c.model\nORDER BY highest_sale_price DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 9.87416672706604, "tokens_used": 1898, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5110600000000001}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH sale_payments AS (SELECT s.id AS sale_id, s.sale_date, MAX(p.payment_date) AS latest_payment_date FROM sales AS s JOIN payments_received AS p ON s.id = p.sale_id GROUP BY s.id, s.sale_date) SELECT ROUND(AVG(julianday(latest_payment_date) - julianday(sale_date)), 2) AS avg_days_to_paymen FROM sale_payments;", "question": "What is the average number of days between the sale date and payment received date, rounded to 2 decimal places?", "instructions": "\nFollow the instructions below to generate the query:\nWhen getting duration between sale and payment date for each sale, get the latest payment for sale by aggregating over the payments_received table first.\n", "full_instructions": "When getting duration between sale and payment date for each sale, get the latest payment for sale by aggregating over the payments_received table first. ASP = Calculate the average price of sales within a specific timeframe Last 30 days = Use a range from the current date minus a certain interval to the current date, always ensure to make the necessary joins before utilizing the sales data. TSC = Count of sales within a specified period", "generated_query": "SELECT ROUND(AVG(julianday(latest_payment.payment_date) - julianday(s.sale_date)), 2) AS average_days\nFROM sales s\nJOIN\n  (SELECT sale_id,\n          MAX(payment_date) AS payment_date\n   FROM payments_received\n   GROUP BY sale_id) latest_payment ON s.id = latest_payment.sale_id;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.248105049133301, "tokens_used": 1296, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25311000000000006}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH salesperson_sales AS (SELECT s.id, s.first_name, s.last_name, SUM(sa.sale_price) AS total_sales FROM salespersons AS s LEFT JOIN sales AS sa ON s.id = sa.salesperson_id GROUP BY s.id) SELECT id, first_name, last_name, total_sales FROM salesperson_sales ORDER BY total_sales DESC LIMIT 5;", "question": "Who are the top 5 salespersons by total sales amount? Return their ID, first name, last name and total sales amount.", "instructions": "\nFollow the instructions below to generate the query:\nTo get the total sales amount per salesperson, join the salespersons and sales tables, group by salesperson, and sum the sale_price.\nAlways order results with NULLS last.\n", "full_instructions": "PMSR = per month sales revenue\nAlways join sales with cars before using the sales table\nWeekend days are Saturday and Sunday\nTruncate date to month for aggregation\nLast 30 days = DATE('now', '-30 days') to DATE('now')\nPMSPS = per month salesperson signups\nTo get the total sales amount per salesperson, join the salespersons and sales tables, group by salesperson, and sum the sale_price. Always order results with NULLS last.\nTruncate date to week for aggregation.", "generated_query": "SELECT sp.id,\n       sp.first_name,\n       sp.last_name,\n       SUM(s.sale_price) AS total_sales_amount\nFROM salespersons sp\nJOIN sales s ON sp.id = s.salesperson_id\nGROUP BY sp.id,\n         sp.first_name,\n         sp.last_name\nORDER BY total_sales_amount DESC NULLS LAST\nLIMIT 5;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6020712852478027, "tokens_used": 1243, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22616}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH salesperson_sales AS (SELECT salesperson_id, SUM(sale_price) AS total_sales, COUNT(*) AS num_sales FROM sales GROUP BY salesperson_id) SELECT s.first_name, s.last_name, ss.total_sales, ss.num_sales, RANK() OVER (ORDER BY CASE WHEN ss.total_sales IS NULL THEN 1 ELSE 0 END DESC, ss.total_sales DESC) AS sales_rank FROM salesperson_sales AS ss JOIN salespersons AS s ON ss.salesperson_id = s.id;", "question": "Return the first name, last name, total sales amount, number of sales, and SR for each salesperson", "instructions": "\nFollow the instructions below to generate the query:\nSR = sales rank of each salesperson ordered by their total sales amount descending\n", "full_instructions": "SR = sales rank of each salesperson ordered by their total sales amount descending To determine the sales performance per territory, sum the sales amount and count the sales, grouping by territory To calculate the average sale price, join the sales table with itself on the salesperson_id and find the ratio of total sales amount to number of sales To assess inventory turnover, compare inventory snapshots with sales on matching days, focusing on the quantity of items sold.", "generated_query": "WITH sp_sales AS\n  (SELECT sp.first_name,\n          sp.last_name,\n          COALESCE(SUM(s.sale_price), 0) AS total_sales_amount,\n          COUNT(s.id) AS number_of_sales\n   FROM salespersons sp\n   LEFT JOIN sales s ON sp.id = s.salesperson_id\n   GROUP BY sp.id)\nSELECT first_name,\n       last_name,\n       total_sales_amount,\n       number_of_sales,\n       RANK() OVER (\n                    ORDER BY total_sales_amount DESC) AS SR\nFROM sp_sales;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.500212669372559, "tokens_used": 1577, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.3817}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH monthly_totals AS (SELECT strftime('%Y-%m', payment_date) AS dt, SUM(payment_amount) AS total_payments FROM payments_received GROUP BY dt), monthly_totals_with_zero AS (SELECT dt, total_payments FROM monthly_totals UNION ALL SELECT strftime('%Y-%m', date(payment_date, 'start of month', '+' || (n || ' month'))) AS dt, 0 AS total_payments FROM payments_received, (SELECT 0 AS n UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11) WHERE strftime('%Y-%m', date(payment_date, 'start of month', '+' || (n || ' month'))) <= strftime('%Y-%m', 'now') GROUP BY dt) SELECT dt AS MONTH, SUM(total_payments) AS total_payments, SUM(total_payments) - LAG(SUM(total_payments), 1) OVER (ORDER BY dt) AS mom_change FROM monthly_totals_with_zero GROUP BY dt ORDER BY dt;WITH monthly_totals AS (SELECT strftime('%Y-%m-01', payment_date) AS dt, SUM(payment_amount) AS total_payments FROM payments_received GROUP BY dt), monthly_totals_with_zero AS (SELECT dt, total_payments FROM monthly_totals UNION ALL SELECT strftime('%Y-%m-01', date(payment_date, 'start of month', '+' || (n || ' month'))) AS dt, 0 AS total_payments FROM payments_received, (SELECT 0 AS n UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11) WHERE strftime('%Y-%m-01', date(payment_date, 'start of month', '+' || (n || ' month'))) <= strftime('%Y-%m-01', 'now') GROUP BY dt) SELECT dt AS MONTH, SUM(total_payments) AS total_payments, SUM(total_payments) - LAG(SUM(total_payments), 1) OVER (ORDER BY dt) AS mom_change FROM monthly_totals_with_zero GROUP BY dt ORDER BY dt;WITH monthly_totals AS (SELECT strftime('%Y-%m-01 00:00:00', payment_date) AS dt, SUM(payment_amount) AS total_payments FROM payments_received GROUP BY dt), monthly_totals_with_zero AS (SELECT dt, total_payments FROM monthly_totals UNION ALL SELECT strftime('%Y-%m-01 00:00:00', date(payment_date, 'start of month', '+' || (n || ' month'))) AS dt, 0 AS total_payments FROM payments_received, (SELECT 0 AS n UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10 UNION ALL SELECT 11) WHERE strftime('%Y-%m-01 00:00:00', date(payment_date, 'start of month', '+' || (n || ' month'))) <= strftime('%Y-%m-01 00:00:00', 'now') GROUP BY dt) SELECT dt AS MONTH, SUM(total_payments) AS total_payments, SUM(total_payments) - LAG(SUM(total_payments), 1) OVER (ORDER BY dt) AS mom_change FROM monthly_totals_with_zero GROUP BY dt ORDER BY dt;", "question": "What is the total payments received per month? Also calculate the MoM change for each month.", "instructions": "\nFollow the instructions below to generate the query:\nMoM change = (current month value - prev month value).\nReturn all months in your answer, including those where there were no payments.\n", "full_instructions": "To ascertain the volume of sales conducted by each salesperson over a recent period, merge the salespersons and sales tables, applying a filter for recent sales transactions.\nTo determine the average duration from sale date to payment date, perform a join between the sales and payments tables\nTo calculate the average selling price, join the sales and products tables, group by product name, and compute the ratio of total sales amount to the number of sales\nMoM change = (current month value - prev month value). Return all months in your answer, including those where there were no payments.", "generated_query": "WITH bounds AS\n  (SELECT date(min(payment_date), 'start of month') AS min_month,\n          date(max(payment_date), 'start of month') AS max_month\n   FROM payments_received),\n     month_series(MONTH) AS\n  (SELECT min_month\n   FROM bounds\n   UNION ALL SELECT date(MONTH, '+1 month')\n   FROM month_series,\n        bounds\n   WHERE MONTH < max_month),\n     payments_per_month AS\n  (SELECT date(payment_date, 'start of month') AS MONTH,\n          SUM(payment_amount) AS total_payment\n   FROM payments_received\n   GROUP BY date(payment_date, 'start of month'))\nSELECT ms.month,\n       COALESCE(ppm.total_payment, 0) AS total_payments,\n       COALESCE(COALESCE(ppm.total_payment, 0) - LAG(COALESCE(ppm.total_payment, 0)) OVER (\n                                                                                           ORDER BY ms.month), 0) AS MoM_change\nFROM month_series ms\nLEFT JOIN payments_per_month ppm ON ms.month = ppm.month\nORDER BY ms.month;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.772522687911987, "tokens_used": 1897, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.51887}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT date(p.payment_date,  '-' || ((strftime('%w', p.payment_date) + 6) % 7) || ' days') AS week, COUNT(p.id) AS total_payments, COUNT(CASE WHEN strftime('%w', p.payment_date) IN ('0', '6') THEN 1 END) AS weekend_payments FROM payments_received AS p JOIN sales AS s ON p.sale_id = s.id WHERE s.sale_price > 30000 AND p.payment_date >= date('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-56 days') AND p.payment_date < date('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days') GROUP BY week ORDER BY week ASC;", "question": "For sales with sale price over $30,000, how many payments were received in total and on weekends in each of the last 8 calendar weeks (excluding the current week)? Return the week (as a date), total payments received, and weekend payments received in ascending order.", "instructions": "\nFollow the instructions below to generate the query:\nWeekend days are Saturday (6) and Sunday (0).\nTruncate date to week for aggregation.\nA week begins on 'weekday 1'\n", "full_instructions": "To calculate the average days between sale date and payment received date, join the sales and payments received tables. Weekend days are Saturday (6) and Sunday (0). Truncate date to week for aggregation. When using car makes, model names, engine_type and vin_number, match case-insensitively and allow partial matches using LIKE with wildcards. To get the total sales amount per salesperson, join the salespersons and sales tables, group by salesperson, and sum the sale_price", "generated_query": "SELECT date(pr.payment_date, 'weekday 1') AS week_start,\n       COUNT(*) AS total_payments,\n       SUM(CASE\n               WHEN strftime('%w', pr.payment_date) IN ('0', '6') THEN 1\n               ELSE 0\n           END) AS weekend_payments\nFROM payments_received pr\nJOIN sales s ON pr.sale_id = s.id\nWHERE s.sale_price > 30000\n  AND pr.payment_date >= date('now', 'weekday 1', '-8 weeks')\n  AND pr.payment_date < date('now', 'weekday 1')\nGROUP BY week_start\nORDER BY week_start ASC;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 7.628136396408081, "tokens_used": 2029, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.56441}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT COUNT(s.id) AS num_sales, SUM(s.sale_price) AS total_revenue FROM sales AS s JOIN cars AS c ON s.car_id = c.id WHERE c.make = 'Toyota' AND s.sale_date BETWEEN DATE('now', '-30 days') AND DATE('now');", "question": "How many Toyota cars were sold in the last 30 days inclusive of today? Return the number of sales and total revenue.", "instructions": "\nFollow the instructions below to generate the query:\nLast 30 days = DATE('now', -'30 days') to DATE('now').\nAlways join sales with cars before using the sales table.\n", "full_instructions": "To calculate the average days between sale date and payment received date, join the sales and payments_received tables\nTo get the list of cars that were sold and their sale price, join the cars and sales tables\nLast 30 days = DATE('now', -'30 days') to DATE('now'). Always join sales with cars before using the sales table.\nWhen using car makes, model names, engine_type, and vin_number, match case-insensitively and allow partial matches using LIKE with wildcards.", "generated_query": "SELECT COUNT(sales.id) AS number_of_sales,\n       SUM(sales.sale_price) AS total_revenue\nFROM cars\nJOIN sales ON cars.id = sales.car_id\nWHERE cars.make = 'Toyota'\n  AND sales.sale_date BETWEEN DATE('now', '-30 days') AND DATE('now');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.807264566421509, "tokens_used": 1166, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19458999999999999}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "WITH RECURSIVE date_range(month_start) AS (SELECT DATE('now', '-6 months', 'start of month') AS month_start UNION ALL SELECT DATE(month_start, '+1 month') FROM date_range WHERE month_start < DATE('now', '-1 month', 'start of month')), sales_metrics AS (SELECT strftime('%Y-%m', s.sale_date) AS sale_month, COUNT(s.id) AS PMSPS, SUM(s.sale_price) AS PMSR FROM sales AS s JOIN salespersons AS sp ON s.salesperson_id = sp.id WHERE strftime('%Y', sp.hire_date) BETWEEN '2022' AND '2023' AND s.sale_date >= DATE('now', '-6 months', 'start of month') AND s.sale_date < DATE('now', 'start of month') GROUP BY sale_month) SELECT dr.month_start, COALESCE(sm.PMSPS, 0) AS PMSPS, COALESCE(sm.PMSR, 0) AS PMSR FROM date_range AS dr LEFT JOIN sales_metrics AS sm ON strftime('%Y-%m', dr.month_start) = sm.sale_month ORDER BY dr.month_start ASC;", "question": "What are the PMSPS and PMSR in the last 6 months excluding the current month, for salespersons hired between 2022 and 2023 (both inclusive)? Return all months in your answer, including those where metrics are 0. Order by month ascending.", "instructions": "\nFollow the instructions below to generate the query:\nPMSPS = per month salesperson sales count.\nPMSR = per month sales revenue in dollars.\nTruncate date to month for aggregation.\n", "full_instructions": "PMSPS = per month salesperson sales count. PMSR = per month sales revenue in dollars. Truncate date to month for aggregation.\nASP = Average Sale Price during a specific timeframe\nTo calculate the average days between a sale date and when the payment was received, join the relevant tables.\nTSC = Total Sales Count for a given period", "generated_query": "WITH RECURSIVE months(MONTH) AS\n  (SELECT date('now', 'start of month', '-6 months')\n   UNION ALL SELECT date(MONTH, '+1 month')\n   FROM months\n   WHERE MONTH < date('now', 'start of month', '-1 month'))\nSELECT m.month,\n       COALESCE(sales_summary.PMSPS, 0) AS PMSPS,\n       COALESCE(sales_summary.PMSR, 0) AS PMSR\nFROM months m\nLEFT JOIN\n  (SELECT date(s.sale_date, 'start of month') AS MONTH,\n          COUNT(*) AS PMSPS,\n          SUM(s.sale_price) AS PMSR\n   FROM sales s\n   JOIN salespersons sp ON sp.id = s.salesperson_id\n   WHERE sp.hire_date BETWEEN '2022-01-01' AND '2023-12-31'\n     AND s.sale_date >= date('now', 'start of month', '-6 months')\n     AND s.sale_date < date('now', 'start of month')\n   GROUP BY date(s.sale_date, 'start of month')) sales_summary ON m.month = sales_summary.month\nORDER BY m.month ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 8.95833134651184, "tokens_used": 2278, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.6743000000000001}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT c.make, c.model, s.sale_price FROM cars AS c JOIN sales AS s ON c.id = s.car_id JOIN inventory_snapshots AS i ON c.id = i.car_id AND DATE(s.sale_date) = DATE(i.snapshot_date) WHERE i.is_in_inventory = 0 ORDER BY s.sale_price DESC LIMIT 1;", "question": "What is the make, model and sale price of the car with the highest sale price that was sold on the same day it went out of inventory?", "instructions": "\nFollow the instructions below to generate the query:\nIf inventory snapshots and sales from the same day are to be joined, join on the truncated date fields eg FROM inventory_snapshots i JOIN sales s ON DATETIME(DATE(i.snapshot_date)) = DATETIME(DATE(s.sale_date)).\n", "full_instructions": "ASP (average selling price) = total sales amount / number of sales\nTo calculate the gross profit margin, join the appropriate tables and calculate the margin\nIf inventory snapshots and sales from the same day are to be joined, join on the truncated date fields eg FROM inventory_snapshots i JOIN sales s ON DATETIME(DATE(i.snapshot_date)) = DATETIME(DATE(s.sale_date)).\nTo rank salespersons by their sales volume, join the salespersons and sales data, order by sales volume.\n\nSo, the rephrased instructions would be: \"GPM (gross profit margin) = (total revenue - total cost) / total cost * 100\nTo determine the average sale price, join the sales data and calculate the average\nSR = sales rank of each salesperson ordered by their total sales amount descending.\"", "generated_query": "SELECT c.make,\n       c.model,\n       s.sale_price\nFROM sales s\nJOIN cars c ON s.car_id = c.id\nJOIN inventory_snapshots i ON i.car_id = s.car_id\nAND DATETIME(DATE(i.snapshot_date)) = DATETIME(DATE(s.sale_date))\nWHERE i.is_in_inventory = 0\nORDER BY s.sale_price DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 7.852455377578735, "tokens_used": 2053, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.57728}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT c.make, c.model, COUNT(s.id) AS num_sales FROM cars AS c LEFT JOIN sales AS s ON c.id = s.car_id WHERE LOWER(c.vin_number) LIKE '%m5%' GROUP BY c.make, c.model;", "question": "How many sales were made for each car model that has 'M5' in its VIN number? Return the make, model and number of sales.", "instructions": "\nFollow the instructions below to generate the query:\nWhen using car makes, model names, engine_type and vin_number, match case-insensitively and allow partial matches using LIKE with wildcards.\n", "full_instructions": "To determine the total sales amount for each salesperson, combine data from the salespersons and sales tables, grouping by salesperson and summing the sale_price\nWhen using car makes, model names, engine_type and vin_number, match case-insensitively and allow partial matches using LIKE with wildcards.\nTo calculate the average selling price, join the sales and cars tables, and divide the total sales amount by the number of sales\nFor understanding the number of sales achieved by each salesperson within a specified period, merge the salespersons and sales tables and apply a filter based on the given time frame.", "generated_query": "SELECT cars.make,\n       cars.model,\n       COUNT(sales.id) AS number_of_sales\nFROM sales\nJOIN cars ON cars.id = sales.car_id\nWHERE cars.vin_number LIKE '%M5%' COLLATE NOCASE\nGROUP BY cars.make,\n         cars.model;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.827082872390747, "tokens_used": 1353, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27522}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT c.make, c.model, c.year, c.color, c.vin_number, AVG(s.sale_price) AS avg_sale_price FROM cars AS c JOIN sales AS s ON c.id = s.car_id WHERE LOWER(c.make) LIKE '%ford%' OR LOWER(c.model) LIKE '%mustang%' GROUP BY c.make, c.model, c.year, c.color, c.vin_number;", "question": "What are the details and average sale price for cars that have 'Ford' in their make name or 'Mustang' in the model name? Return make, model, year, color, vin_number and avg_sale_price.", "instructions": "\nFollow the instructions below to generate the query:\nWhen using car makes, model names, engine_type and vin_number, match case-insensitively and allow partial matches using LIKE with wildcards.\n", "full_instructions": "To calculate the gross profit margin, use the formula where GPM is the quotient of total revenue minus total cost over total cost, multiplied by 100 When using car makes, model names, engine_type and vin_number, match case-insensitively and allow partial matches using LIKE with wildcards. To compute the average sales price, divide the total sales amount by the number of sales To determine the sales rank of each salesperson, order by their total sales amount in descending order.", "generated_query": "SELECT cars.make,\n       cars.model,\n       cars.year,\n       cars.color,\n       cars.vin_number,\n       AVG(sales.sale_price) AS avg_sale_price\nFROM cars\nLEFT JOIN sales ON cars.id = sales.car_id\nWHERE cars.make LIKE '%Ford%'\n  OR cars.model LIKE '%Mustang%'\nGROUP BY cars.id,\n         cars.make,\n         cars.model,\n         cars.year,\n         cars.color,\n         cars.vin_number;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.242041110992432, "tokens_used": 1723, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43306999999999995}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT AVG(sale_price) AS ASP FROM sales WHERE sale_date >= '2023-01-01' AND sale_date <= '2023-03-31';", "question": "What is the ASP for sales made in the first quarter of 2023?", "instructions": "\nFollow the instructions below to generate the query:\nASP = Average Sale Price in the first quarter of 2023.\n", "full_instructions": "Always join sales with cars before using the sales table. ASP = Average Sale Price in the first quarter of 2023. To calculate the average days between sale date and payment received date, join the sales and payments tables To get the list of cars that were sold along with their sale prices, join the cars and sales tables Last 30 days = DATE('now', -'30 days') to DATE('now')", "generated_query": "SELECT AVG(sale_price) AS ASP\nFROM sales\nWHERE sale_date BETWEEN '2023-01-01' AND '2023-03-31';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3775439262390137, "tokens_used": 1111, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17864}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT COUNT(id) AS TSC FROM sales WHERE sale_date >= DATE('now', '-7 days');", "question": "What is the TSC in the past 7 days, inclusive of today?", "instructions": "\nFollow the instructions below to generate the query:\nTSC = Total Sales Count.\n", "full_instructions": "To determine the average selling price, divide the total sales amount by the number of sales\nTo calculate the gross profit margin, subtract the total cost from the total revenue, then divide by the total cost and multiply by 100\nTo ascertain the sales rank of each salesperson, order them by their total sales amount in descending order.\nTSC = Total Sales Count.", "generated_query": "SELECT COUNT(*) AS TSC\nFROM sales\nWHERE sale_date BETWEEN date('now', '-6 days') AND date('now');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.8773787021636963, "tokens_used": 1162, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20339000000000004}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT (SUM(sale_price) - SUM(cars.cost)) / SUM(cars.cost) * 100 AS gpm FROM sales JOIN cars ON sales.car_id = cars.id WHERE strftime('%Y', sale_date) = '2023';", "question": "What is the GPM for all car sales in 2023?", "instructions": "\nFollow the instructions below to generate the query:\nGPM (gross profit margin) = (total revenue - total cost) / total cost * 100\n", "full_instructions": "Analyze salesperson activity over a selected period by connecting salespersons with sales records\nGPM (gross profit margin) = (total revenue - total cost) / total cost * 100\nFor weekly trends, consider the start of the week\nTo calculate the TSC = Total Sales Count within a given period\nIdentify sold vehicles and pricing by linking car and sales data\nMoM = assess the month-over-month change in total financial transactions\nSR = sales rank of each salesperson based on their total sales without specifying the order\nUtilize LIKE for flexible matching in vehicle information queries.\nUse inventory and sales data for concurrent analysis, ensuring date alignment\nTo summarize sales performance, combine sales and salesperson data, focusing on total sales\nPMSPS and PMSR aim to measure salesperson engagement and monthly revenue, respectively\nFor insights on sale to payment duration, correlate sales with payment dates\nTo find the ASP = Average Sale Price for a specific time frame\nFor timing analysis, apply specific date intervals", "generated_query": "SELECT ((SUM(s.sale_price) - SUM(c.cost)) / SUM(c.cost)) * 100 AS GPM\nFROM sales s\nJOIN cars c ON s.car_id = c.id\nWHERE s.sale_date BETWEEN '2023-01-01' AND '2023-12-31';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.968309164047241, "tokens_used": 1467, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.33330000000000004}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT salespersons.first_name, salespersons.last_name, AVG(sales.sale_price) AS ASP FROM sales JOIN salespersons ON sales.salesperson_id = salespersons.id GROUP BY salespersons.first_name, salespersons.last_name ORDER BY ASP DESC LIMIT 3;", "question": "Who are the top 3 salespersons by ASP? Return their first name, last name and ASP.", "instructions": "\nFollow the instructions below to generate the query:\nASP (average selling price) = total sales amount / number of sales\n", "full_instructions": "To get the total sales amount per salesperson, join the salespersons and sales tables, group by salesperson, and sum the sale_amount. To calculate the average days between the sale date and payment received date, join the sales and payments_received tables. ASP (average selling price) = total sales amount / number of sales. To get the list of cars that were sold and their sale price, join the cars and sales tables.", "generated_query": "SELECT sp.first_name,\n       sp.last_name,\n       SUM(s.sale_price) * 1.0 / COUNT(s.id) AS ASP\nFROM sales s\nJOIN salespersons sp ON s.salesperson_id = sp.id\nGROUP BY sp.id\nORDER BY ASP DESC\nLIMIT 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.763713836669922, "tokens_used": 1142, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19030000000000002}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH patient_diagnosis_treatment AS (SELECT p.patient_id FROM patients AS p JOIN treatments AS t ON p.patient_id = t.patient_id JOIN diagnoses AS d ON t.diag_id = d.diag_id JOIN drugs AS dr ON t.drug_id = dr.drug_id WHERE d.diag_name = 'Psoriasis vulgaris' AND dr.drug_type = 'biologic') SELECT COUNT(DISTINCT patient_id) FROM patient_diagnosis_treatment;", "question": "How many patients have been diagnosed with 'Psoriasis vulgaris' and treated with a biologic drug? Return the distinct count of patients.", "instructions": "\nFollow the instructions below to generate the query:\nTo find the number of patients who have been diagnosed with a specific type of psoriasis and treated with a biologic drug, first join patients with treatments on patient_id, then join with diagnoses on diag_id, filtering by diagnosis and drug type.\n", "full_instructions": "TPC: Determine the total count of female patients To find the number of patients who have been diagnosed with a specific type of psoriasis and treated with a biologic drug, first join patients with treatments on patient_id, then join with diagnoses on diag_id, filtering by diagnosis and drug type. D7D100PIR: Compute the improvement rate of the PASI score from day 7 to day 100, considering only patients with available PASI scores for both days. AWF: Calculate the mean weight for male patients in kilograms", "generated_query": "SELECT COUNT(DISTINCT patients.patient_id)\nFROM patients\nJOIN treatments ON patients.patient_id = treatments.patient_id\nJOIN diagnoses ON treatments.diag_id = diagnoses.diag_id\nJOIN drugs ON treatments.drug_id = drugs.drug_id\nWHERE diagnoses.diag_name = 'Psoriasis vulgaris'\n  AND drugs.drug_type = 'biologic';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.5044784545898438, "tokens_used": 1443, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27027}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "SELECT a.description, a.treatment_id, d.drug_id, d.drug_name FROM adverse_events AS a JOIN treatments AS t ON a.treatment_id = t.treatment_id JOIN drugs AS d ON t.drug_id = d.drug_id WHERE d.drug_type = 'topical';", "question": "I want the adverse events that have been reported for treatments involving topical drugs. Give me the description, treatment id, drug id and name.", "instructions": "\nFollow the instructions below to generate the query:\nTo get adverse events reported for treatments involving certain drugs, first join treatments with adverse_events on treatment_id, then join with drugs on drug_id to filter on the specific drug(s).\n", "full_instructions": "AWF = Average weight of female patients (kg)\nPASI improvement rate is calculated as ((average PASI score on day 100 - average PASI score on day 7) / average PASI score on day 7) * 100, including only patients with non-null PASI scores at both timepoints.\nTo calculate the total number of adverse events reported for treatments involving topical drugs, first join treatments with adverse_events on treatment_id, then filter by the drug type.\nTPC = total patient count", "generated_query": "SELECT ae.description,\n       t.treatment_id,\n       d.drug_id,\n       d.drug_name\nFROM treatments t\nJOIN adverse_events ae ON t.treatment_id = ae.treatment_id\nJOIN drugs d ON t.drug_id = d.drug_id\nWHERE d.drug_type = 'topical';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.393484354019165, "tokens_used": 1488, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.29403}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH patient_treatment AS (SELECT p.patient_id, p.weight_kg FROM patients AS p JOIN treatments AS t ON p.patient_id = t.patient_id WHERE t.drug_id = (SELECT drug_id FROM drugs WHERE drug_name = 'Drugalin')) SELECT AVG(weight_kg) FROM patient_treatment;", "question": "What is the average weight in kg of patients treated with the drug named 'Drugalin'? Return the average weight.", "instructions": "\nFollow the instructions below to generate the query:\nTo find the average weight of patients treated with a specific drug, first join patients with treatments on patient_id, then filter by the drug name.\n", "full_instructions": "To find the average weight of patients treated with a specific drug, first join patients with treatments on patient_id, then filter by the drug name.\nPMPD = Determine the number of diagnoses made for patients each month.\nDDD = Compute the overall consumed medication amount divided by the total number of treatment days\nAWF = Calculate the average weight in kilograms for patients identified as male", "generated_query": "SELECT AVG(p.weight_kg) AS average_weight\nFROM patients AS p\nJOIN treatments AS t ON p.patient_id = t.patient_id\nJOIN drugs AS d ON t.drug_id = d.drug_id\nWHERE d.drug_name = 'Drugalin';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.335846424102783, "tokens_used": 1339, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23210000000000003}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH doctor_treatment AS (SELECT d.doc_id, d.loc_state FROM doctors AS d JOIN treatments AS t ON d.doc_id = t.doc_id JOIN drugs AS dr ON t.drug_id = dr.drug_id WHERE dr.drug_type = 'biologic') SELECT DISTINCT loc_state FROM doctor_treatment;", "question": "Which states do doctors who have prescribed biologic drugs reside in? Return the distinct states.", "instructions": "\nFollow the instructions below to generate the query:\nTo identify doctors who have prescribed a certain drug type and their respective states, first join doctors with treatments on doc_id, then filter by the drug type.\n", "full_instructions": "AWF = average weight for male patients TPC = total count of female patients Each of these metrics, while providing valuable insights for other analyses, would not alter the scope or outcome of the provided SQL query aimed at identifying states with doctors who have prescribed biologic drugs. PMPD = counts of patient diagnoses per month To identify doctors who have prescribed a certain drug type and their respective states, first join doctors with treatments on doc_id, then filter by the drug type.", "generated_query": "SELECT DISTINCT doctors.loc_state\nFROM doctors\nJOIN treatments ON doctors.doc_id = treatments.doc_id\nJOIN drugs ON treatments.drug_id = drugs.drug_id\nWHERE drugs.drug_type = 'biologic';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.066478252410889, "tokens_used": 1323, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22637999999999997}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH doc_drug_counts AS (SELECT d.doc_id, d.specialty, COUNT(DISTINCT t.drug_id) AS num_drugs_prescribed FROM doctors AS d JOIN treatments AS t ON d.doc_id = t.doc_id GROUP BY d.doc_id) SELECT doc_id, specialty, num_drugs_prescribed, DENSE_RANK() OVER (PARTITION BY specialty ORDER BY CASE WHEN num_drugs_prescribed IS NULL THEN 1 ELSE 0 END DESC, num_drugs_prescribed DESC) AS specialty_drug_rank FROM doc_drug_counts;", "question": "Return each doctor's doc_id, specialty, number of distinct drugs prescribed, and SDR", "instructions": "\nFollow the instructions below to generate the query:\nSDR = a doctor's rank within their specialty by number of distinct drugs prescribed.\nDoctors prescribing more drugs will have a higher rank\n", "full_instructions": "To calculate the average weight of all patients who have been given a certain medication, join the patients and treatments tables on the patient's ID, then apply a filter for the specific medication To discover physicians who have prescribed a particular type of medication and identify their locations, link the doctors and treatments tables via the doctor's ID, then use a condition to filter by the medication type To ascertain the total count of adverse reactions recorded for treatments that involve topical medications, merge the treatments and adverse_events tables using the treatment ID, and apply a filter for the medication type. SDR = a doctor's rank within their specialty by number of distinct drugs prescribed, with doctors prescribing the most distinct drugs having rank 1", "generated_query": "WITH doctor_drug_counts AS\n  (SELECT d.doc_id,\n          d.specialty,\n          COUNT(DISTINCT t.drug_id) AS num_distinct_drugs\n   FROM doctors d\n   LEFT JOIN treatments t ON d.doc_id = t.doc_id\n   GROUP BY d.doc_id,\n            d.specialty)\nSELECT doc_id,\n       specialty,\n       num_distinct_drugs,\n       RANK() OVER (PARTITION BY specialty\n                    ORDER BY num_distinct_drugs DESC) AS SDR\nFROM doctor_drug_counts\nORDER BY specialty,\n         SDR;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.304288387298584, "tokens_used": 1583, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34309}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH FirstTreatment AS (SELECT p.patient_id, MIN(t.start_dt) AS first_treatment_date FROM patients AS p JOIN treatments AS t ON p.patient_id = t.patient_id GROUP BY p.patient_id), NewPatientsPerYear AS (SELECT strftime('%Y', first_treatment_date) AS year, COUNT(patient_id) AS new_patients FROM FirstTreatment GROUP BY strftime('%Y', first_treatment_date)), NPI AS (SELECT year, new_patients, new_patients - LAG(new_patients, 1) OVER (ORDER BY year) AS npi FROM NewPatientsPerYear) SELECT year, new_patients, npi FROM NPI ORDER BY year;", "question": "What is the NPI for each year? Return the year, number of new patients, and NPI", "instructions": "\nFollow the instructions below to generate the query:\nNPI (new patients increase) = the increase in number of new patients compared to the previous year.\nNew patients are defined as patients starting their first treatment and require joining the patients table with the earliest record of each patient from the treatment table on patient_id\n", "full_instructions": "NPI (new patients increase) = the increase in number of new patients compared to the previous year. New patients are defined as patients starting their first treatment and require joining the patients table with the earliest record of each patient from the treatment table on patient_id\nIf events from two different sources need to be linked based on time, it's advised to align them by truncating both dates to the same interval for the join condition.\nTo find the average weight of patients treated with any drug, join the patients and treatments tables using patient_id, then filter as needed by the drug\nTo identify doctors who have prescribed any drug type along with their states, join the doctors with treatments on doc_id, then apply the necessary filter for the drug type", "generated_query": "WITH first_treatment AS\n  (SELECT patient_id,\n          MIN(start_dt) AS first_treatment_date\n   FROM treatments\n   GROUP BY patient_id),\n     yearly_new_patients AS\n  (SELECT CAST(strftime('%Y', first_treatment_date) AS INTEGER) AS YEAR,\n          COUNT(*) AS new_patients\n   FROM first_treatment\n   GROUP BY YEAR)\nSELECT YEAR,\n       new_patients,\n       new_patients - LAG(new_patients) OVER (\n                                              ORDER BY YEAR) AS NPI\nFROM yearly_new_patients\nORDER BY YEAR;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.9497764110565186, "tokens_used": 1813, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43406}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT strftime('%Y-%m', t.start_dt) AS MONTH, COUNT(DISTINCT t.patient_id) AS patient_count, COUNT(DISTINCT CASE WHEN d.drug_type = 'biologic' THEN t.treatment_id END) AS biologic_treatment_count FROM treatments AS t JOIN drugs AS d ON t.drug_id = d.drug_id WHERE t.start_dt >= date('now', '-3 months', 'start of month') AND t.start_dt < date('now', 'start of month') GROUP BY month;SELECT strftime('%Y-%m-01', t.start_dt) AS MONTH, COUNT(DISTINCT t.patient_id) AS patient_count, COUNT(DISTINCT CASE WHEN d.drug_type = 'biologic' THEN t.treatment_id END) AS biologic_treatment_count FROM treatments AS t JOIN drugs AS d ON t.drug_id = d.drug_id WHERE t.start_dt >= date('now', '-3 months', 'start of month') AND t.start_dt < date('now', 'start of month') GROUP BY month;SELECT strftime('%Y-%m-01 %H:%M:%S', t.start_dt) AS MONTH, COUNT(DISTINCT t.patient_id) AS patient_count, COUNT(DISTINCT CASE WHEN d.drug_type = 'biologic' THEN t.treatment_id END) AS biologic_treatment_count FROM treatments AS t JOIN drugs AS d ON t.drug_id = d.drug_id WHERE t.start_dt >= date('now', '-3 months', 'start of month') AND t.start_dt < date('now', 'start of month') GROUP BY month;", "question": "How many distinct patients had treatments in each of the last 3 months, not including the current month? Out of these, how many had treatments with biologic drugs? Return the month, patient count, and biologic treatment count.", "instructions": "\nFollow the instructions below to generate the query:\nBiologic drugs have drug_type = 'biologic'.\nTruncate start_dt to month for aggregation.\n", "full_instructions": "To calculate the DDD (Defined Daily Dose) = the total amount of drug consumed divided by the total number of days of treatment\nTo count the number of adverse events reported for treatments involving any specified drug type, first join the treatments table with the adverse_events table based on treatment_id, then apply a filter by the specified drug type.\nTo determine the SDR (Specialty Doctor Rank) = rank doctors within their specialty by the number of distinct drugs prescribed, with those prescribing more distinct drugs achieving a higher rank\nBiologic drugs have drug_type = 'biologic'. Truncate start_dt to month for aggregation.", "generated_query": "SELECT date(start_dt, 'start of month') AS MONTH,\n       COUNT(DISTINCT patient_id) AS patient_count,\n       COUNT(DISTINCT CASE\n                          WHEN drugs.drug_type = 'biologic' THEN patient_id\n                      END) AS biologic_treatment_count\nFROM treatments\nJOIN drugs ON treatments.drug_id = drugs.drug_id\nWHERE start_dt >= date('now', 'start of month', '-3 months')\n  AND start_dt < date('now', 'start of month')\nGROUP BY date(start_dt, 'start of month');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.019814968109131, "tokens_used": 1859, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.4562800000000001}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT COUNT(t.treatment_id) FROM treatments AS t JOIN patients AS p ON t.patient_id = p.patient_id WHERE p.first_name = 'Alice' AND t.start_dt BETWEEN date('now', 'start of month', '-6 months') AND date('now', 'start of month', '-1 day');", "question": "How many treatments did the patient Alice have in the last 6 months, not including the current month?", "instructions": "\nFollow the instructions below to generate the query:\nLast 6 months = DATE('now', 'start of month', '-6 months') to DATE('now', 'start of month', '-1 day').\nAlways join treatments with patients before using the treatments table.\nIf not mentioned, the patient name provided is the first name.\n", "full_instructions": "Last 6 months = DATE('now', 'start of month', '-6 months') to DATE('now', 'start of month', '-1 day'). Always join treatments with patients before using the treatments table. If not mentioned, the patient name provided is the first name. To identify doctors with certain name characteristics; To calculate the total adverse event counts for specific drug treatments; To examine patient diagnosis and treatment correlations with certain drugs.", "generated_query": "SELECT COUNT(*) AS treatment_count\nFROM patients\nJOIN treatments ON patients.patient_id = treatments.patient_id\nWHERE patients.first_name = 'Alice'\n  AND treatments.start_dt BETWEEN DATE('now', 'start of month', '-6 months') AND DATE('now', 'start of month', '-1 day');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.510238409042358, "tokens_used": 1499, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.29458}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT strftime('%Y-%m', t.start_dt) AS month, COUNT(DISTINCT t.patient_id) AS patient_count, COUNT(DISTINCT t.treatment_id) AS treatment_count FROM treatments AS t JOIN diagnoses AS d ON t.diag_id = d.diag_id WHERE t.start_dt >= date('now', '-12 months', 'start of month') AND t.start_dt < date('now', 'start of month') GROUP BY month;", "question": "What are the PMPD and PMTC for each of the last 12 months, not including the current month", "instructions": "\nFollow the instructions below to generate the query:\nPMPD = per month patient diagnoses.\nPMTC = per month treatment count.\nTruncate start_dt to month for aggregation.\n", "full_instructions": "PMPD = per month patient diagnoses. PMTC = per month treatment count. Truncate start_dt to month for aggregation. TPC = count of female patients; AWF = average weight for male patients; D7D100PIR = (average PASI score at day 100 - average PASI score at day 7) / average PASI score at day 7 * 100 with non-null PASI scores at both timepoints; DDD = total consumed drug amount divided by total treatment days.", "generated_query": "SELECT strftime('%Y-%m', start_dt) AS MONTH,\n       COUNT(DISTINCT patient_id) AS PMPD,\n       COUNT(*) AS PMTC\nFROM treatments\nWHERE start_dt >= date('now', 'start of month', '-12 months')\n  AND start_dt < date('now', 'start of month')\nGROUP BY strftime('%Y-%m', start_dt)\nORDER BY MONTH;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.2129786014556885, "tokens_used": 1876, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.47003}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "WITH adverse_events_per_drug AS (SELECT d.drug_id, COUNT(ae.id) AS num_events FROM adverse_events AS ae JOIN treatments AS t ON ae.treatment_id = t.treatment_id AND strftime('%Y-%m', ae.reported_dt) = strftime('%Y-%m', t.start_dt) JOIN drugs AS d ON t.drug_id = d.drug_id GROUP BY d.drug_id) SELECT ae.drug_id, d.drug_name, ae.num_events FROM adverse_events_per_drug AS ae JOIN drugs AS d USING (drug_id) ORDER BY ae.num_events DESC LIMIT 1;", "question": "Which drug had the highest number of adverse events reported within the same month as the treatment start date (adverse event or treatment can be earlier than the other)? Return the number of adverse events along with the drug's id and name.", "instructions": "\nFollow the instructions below to generate the query:\nIf events from 2 different tables from the same interval are to be joined, join on the respective truncated date fields eg `FROM t1 JOIN t2 ON DATE(t1.date, '<interval>') = DATE(t2.date, '<interval>').\n", "full_instructions": "If events from 2 different tables from the same interval are to be joined, join on the respective truncated date fields eg `FROM t1 JOIN t2 ON DATE(t1.date, '<interval>') = DATE(t2.date, '<interval>'). To determine the total count of adverse reactions reported for treatments that include topical medications, associate treatments with adverse_events through the treatment identifier, applying a filter based on the type of medication. To identify the healthcare providers who have prescribed a specific category of medication along with their state, connect doctors to treatments by doctor identifier, filtering by the type of medication To calculate the average weight of patients who have received a certain medication, link patients to treatments via the patient identifier, then narrow down by the name of the medication", "generated_query": "SELECT d.drug_id,\n       d.drug_name,\n       COUNT(a.id) AS adverse_event_count\nFROM treatments t\nJOIN adverse_events a ON DATE(t.start_dt, 'start of month') = DATE(a.reported_dt, 'start of month')\nJOIN drugs d ON t.drug_id = d.drug_id\nGROUP BY d.drug_id,\n         d.drug_name\nORDER BY adverse_event_count DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.9878339767456055, "tokens_used": 2002, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5086400000000001}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT COUNT(*) FROM patients WHERE email LIKE '%@gmail.com' OR email LIKE '%@yahoo.com';", "question": "How many patients have a Gmail or Yahoo email address?", "instructions": "\nFollow the instructions below to generate the query:\nPatients with gmail or yahoo email addresses\n", "full_instructions": "To calculate the total number of adverse events for treatments involving topical medications, join the treatments and adverse_events tables on treatment_id, and then filter based on the drug's form.\nPatients with gmail or yahoo email addresses\nTo find the average weight of patients treated with a specific drug, join the patients and treatments tables by patient_id, then select the drug of interest\nTo identify doctors who have prescribed a certain type of drug and their practice states, join the doctors and treatments tables on doc_id, filtering by the drug's category", "generated_query": "SELECT COUNT(*) AS COUNT\nFROM patients\nWHERE email LIKE '%gmail%'\n  OR email LIKE '%yahoo%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.7417192459106445, "tokens_used": 1274, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.21472000000000002}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT first_name, last_name, specialty FROM doctors WHERE LOWER(first_name) LIKE 'J%' OR LOWER(last_name) LIKE '%son%';", "question": "Return the first name, last name and specialty of doctors whose first name starts with 'J' or last name contains 'son', case-insensitive.", "instructions": "\nFollow the instructions below to generate the query:\nDoctors whose first name starts with 'J' or last name contains 'son', case-insensitive\n", "full_instructions": "Doctors whose first name starts with 'J' or last name contains 'son', case-insensitive To calculate the total number of adverse events reported for treatments involving topical drugs, first join treatments with adverse_events on treatment_id, then filter by the drug type. To identify doctors who have prescribed a certain drug type and their respective states, first join doctors with treatments on doc_id, then filter by the drug type To find the average weight of patients treated with a specific drug, first join patients with treatments on patient_id, then filter by the drug name", "generated_query": "SELECT first_name,\n       last_name,\n       specialty\nFROM doctors\nWHERE first_name LIKE 'J%' COLLATE NOCASE\n  OR last_name LIKE '%son%' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.814343452453613, "tokens_used": 1446, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.28017}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT AVG(weight_kg) AS caw FROM patients WHERE gender = 'Male';", "question": "What is the CAW for male patients", "instructions": "\nFollow the instructions below to generate the query:\nCAW = cohort average weight in kilograms\n", "full_instructions": "A doctor's Specialty Distinct Drug Rank (SDR) is established by the variety of distinct drugs they've prescribed, with the highest prescribers ranked first.\nCAW = cohort average weight in kilograms\nTo calculate the D7D100PIR, subtract the average PASI score at the beginning of the period from the average at the end, divide by the initial average, and multiply by 100\nThe Defined Daily Dose (DDD) is calculated as the total consumed medication divided by the treatment duration", "generated_query": "SELECT AVG(weight_kg) AS CAW\nFROM patients\nWHERE gender = 'Male';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.7604146003723145, "tokens_used": 1139, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.15598}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT COUNT(patient_id) AS pic FROM patients WHERE gender = 'Female' AND ins_type = 'private';", "question": "What is the PIC for female patients?", "instructions": "\nFollow the instructions below to generate the query:\nPIC = private insured patient count\n", "full_instructions": "PIC = private insured patient count. To calculate the D7D100PIR, subtract the average PASI score at day 100 from the average at day 7, divide by the average at day 7, and multiply by 100. PI calculates the month-over-month growth in new patients. For DDD, divide the total drug quantity used by the total treatment days", "generated_query": "SELECT COUNT(patient_id) AS PIC\nFROM patients\nWHERE gender = 'Female'\n  AND ins_type = 'private';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.720905780792236, "tokens_used": 1206, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18612000000000004}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT d.drug_name, AVG(t.tot_drug_amt / NULLIF((JULIANDAY(t.end_dt) - JULIANDAY(t.start_dt)), 0)) AS ddd FROM treatments AS t JOIN drugs AS d ON t.drug_id = d.drug_id WHERE NOT t.end_dt IS NULL GROUP BY d.drug_name;", "question": "Calculate the average DDD for each drug. Return the drug name and average DDD value.", "instructions": "\nFollow the instructions below to generate the query:\nDDD (defined daily dose) = total drug amount consumed during one treatment / total days of treatment (end - start date in days), where end date is not null\n", "full_instructions": "DDD (defined daily dose) = total drug amount consumed during one treatment / total days of treatment (end - start date in days). To find the average weight of patients treated with a specific drug, first join patients with treatments on patient_id, then filter by the drug name. To identify doctors who have prescribed a certain drug type and their respective locations, first join doctors with treatments on doc_id, then filter by the drug type. To calculate the total number of adverse events reported for treatments involving certain drug types, first join treatments with adverse_events on treatment_id, then filter by the drug type.", "generated_query": "SELECT d.drug_name,\n       AVG(t.tot_drug_amt / (julianday(t.end_dt) - julianday(t.start_dt))) AS avg_DDD\nFROM treatments t\nJOIN drugs d ON t.drug_id = d.drug_id\nWHERE t.end_dt IS NOT NULL\nGROUP BY d.drug_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.174142837524414, "tokens_used": 1355, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23914000000000002}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT (AVG(day100_pasi_score) - AVG(day7_pasi_score)) / AVG(day7_pasi_score) * 100 AS d7d100pir FROM outcomes WHERE NOT day7_pasi_score IS NULL AND NOT day100_pasi_score IS NULL;", "question": "What is the overall D7D100PIR across all treatments? Return the percentage value.", "instructions": "\nFollow the instructions below to generate the query:\nD7D100PIR (day 7 to day 100 PASI improvement rate) = (avg PASI score on day 100 - avg PASI score on day 7) / avg PASI score on day 7 * 100.\nThis should only include patients who have non-null PASI scores for both timepoints.\n", "full_instructions": "To discover the average weight of patients who have been prescribed a specific medication, begin by associating patients with treatments on patient_id, and then apply a filter by the drug name.\nD7D100PIR (day 7 to day 100 PASI improvement rate) = (avg PASI score on day 100 - avg PASI score on day 7) / avg PASI score on day 7 * 100. This should only include patients who have non-null PASI scores for both timepoints.\nTo identify doctors who have prescribed a certain type of drug and their state of practice, initially join doctors with treatments on doc_id, followed by filtering based on the drug type\nTo calculate the total number of adverse events reported for treatments involving topical drugs, first link treatments with adverse_events on treatment_id, then use a filter for the drug type", "generated_query": "SELECT ((AVG(day100_pasi_score) - AVG(day7_pasi_score)) / AVG(day7_pasi_score)) * 100 AS overall_D7D100PIR\nFROM outcomes\nWHERE day7_pasi_score IS NOT NULL\n  AND day100_pasi_score IS NOT NULL;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.332473993301392, "tokens_used": 1444, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.26675000000000004}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH user_latest_setting AS (SELECT u.uid, s.marketing_opt_in, s.created_at, ROW_NUMBER() OVER (PARTITION BY u.uid ORDER BY CASE WHEN s.created_at IS NULL THEN 1 ELSE 0 END DESC, s.created_at DESC) AS rn FROM users AS u JOIN user_setting_snapshot AS s ON u.uid = s.user_id) SELECT UID, marketing_opt_in FROM user_latest_setting WHERE rn = 1;", "question": "What is the marketing opt-in preference for each user? Return the user ID and boolean opt-in value", "instructions": "\nFollow the instructions below to generate the query:\nTo get any user's settings, only select the latest snapshot of user_setting_snapshot for each user\n", "full_instructions": "CPUR (coupon usage rate) = Ratio of distinct coupons used to number of distinct transactions.\nAMB = Average balance of user wallets over a recent period\nSTR (success transaction rate) = Ratio of successful transactions to total transactions\nTo get any user's settings, only select the latest snapshot of user_setting_snapshot for each user", "generated_query": "SELECT u.user_id,\n       CASE\n           WHEN u.marketing_opt_in = 1 THEN TRUE\n           ELSE FALSE\n       END AS opt_in\nFROM user_setting_snapshot u\nJOIN\n  (SELECT user_id,\n          MAX(created_at) AS max_created_at\n   FROM user_setting_snapshot\n   GROUP BY user_id) latest ON u.user_id = latest.user_id\nAND u.created_at = latest.max_created_at;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.719242095947266, "tokens_used": 2067, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.48906}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH user_transactions AS (SELECT u.uid, t.txid FROM users AS u JOIN wallet_transactions_daily AS t ON u.uid = t.sender_id WHERE t.sender_type = 0) SELECT UID, COUNT(txid) AS total_transactions FROM user_transactions GROUP BY UID;", "question": "What is the total number of wallet transactions sent by each user that is not a merchant? Return the user ID and total transaction count.", "instructions": "\nFollow the instructions below to generate the query:\nTo get the total number of transactions per user, join the users and wallet_transactions_daily tables in a CTE, then aggregate by user_id and count the number of transactions\n", "full_instructions": "PMDAU = Aggregate daily active users by truncating the date to the month for aggregation.\nAMB = Average balance of user wallets\nLUB = Most recent balance for each user\nTo get the total number of transactions per user, join the users and wallet_transactions_daily tables in a CTE, then aggregate by user_id and count the number of transactions", "generated_query": "WITH user_transactions AS\n  (SELECT u.uid,\n          wt.txid\n   FROM users u\n   JOIN wallet_transactions_daily wt ON u.uid = wt.sender_id\n   WHERE wt.sender_type = 0)\nSELECT UID AS user_id,\n              COUNT(txid) AS total_transaction_count\nFROM user_transactions\nGROUP BY UID;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.8132896423339844, "tokens_used": 1757, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34507}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH user_session_duration AS (SELECT u.uid, s.session_start_ts, s.session_end_ts FROM users AS u JOIN user_sessions AS s ON u.uid = s.user_id WHERE s.session_start_ts >= '2023-06-01' AND s.session_end_ts < '2023-06-08') SELECT uid, SUM(strftime('%s', session_end_ts) - strftime('%s', session_start_ts)) AS total_duration FROM user_session_duration GROUP BY uid ORDER BY total_duration DESC;", "question": "What is the total session duration in seconds for each user between 2023-06-01 inclusive and 2023-06-08 exclusive? Return the user ID and their total duration as an integer sorted by total duration with the longest duration first", "instructions": "\nFollow the instructions below to generate the query:\nTo analyze user engagement, join the users and user_sessions tables in a CTE, then aggregate to calculate total session duration per user for a given date range.\nRemember to convert your answer into seconds, using EPOCH function\n", "full_instructions": "LUB = Most recent account balance for each user. CPUR (coupon usage rate) = Ratio of distinct coupons used to the number of distinct transactions AMB = Average balance of user wallets over a specified period To analyze user engagement, join the users and user_sessions tables in a CTE, then aggregate to calculate total session duration per user for a given date range", "generated_query": "WITH session_data AS\n  (SELECT u.uid AS user_id,\n          CAST((strftime('%s', s.session_end_ts) - strftime('%s', s.session_start_ts)) AS INTEGER) AS duration\n   FROM users u\n   JOIN user_sessions s ON u.uid = s.user_id\n   WHERE s.session_start_ts >= '2023-06-01'\n     AND s.session_start_ts < '2023-06-08')\nSELECT user_id,\n       SUM(duration) AS total_duration\nFROM session_data\nGROUP BY user_id\nORDER BY total_duration DESC;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 9.735957384109497, "tokens_used": 2295, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5709}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_cte_join", "query": "WITH merchant_coupon_usage AS (SELECT c.cid, t.amount FROM coupons AS c JOIN wallet_transactions_daily AS t ON c.cid = t.coupon_id WHERE c.merchant_id = 1) SELECT cid, SUM(amount) AS total_discount FROM merchant_coupon_usage GROUP BY cid;", "question": "What is the total transaction amount for each coupon offered by merchant with ID 1? Return the coupon ID and total amount transacted with it.", "instructions": "\nFollow the instructions below to generate the query:\nTo get coupon usage, join the coupons and wallet_transactions_daily on coupon_id \n", "full_instructions": "AMB = Average balance of user wallets updated recently\nTo get coupon usage, join the coupons and wallet_transactions_daily on coupon_id \nSTR (success transaction rate) = Number of successful transactions divided by total transactions\nPMDAU = Aggregation based on truncating creation dates to months for active user metrics.", "generated_query": "SELECT c.cid AS coupon_id,\n       SUM(w.amount) AS total_amount\nFROM coupons c\nJOIN wallet_transactions_daily w ON c.cid = w.coupon_id\nWHERE c.merchant_id = 1\nGROUP BY c.cid;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.7551801204681396, "tokens_used": 1532, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25168000000000007}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH user_balances AS (SELECT user_id, balance, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY CASE WHEN updated_at IS NULL THEN 1 ELSE 0 END DESC, updated_at DESC) AS rn FROM wallet_user_balance_daily) SELECT user_id, balance FROM user_balances WHERE rn = 1;", "question": "What is the LUB for each user.", "instructions": "\nFollow the instructions below to generate the query:\nLUB = Latest User Balance, which is the most recent balance for each user\n", "full_instructions": "To get the total number of transactions per user, join the users and wallet_transactions_daily tables in a common table expression (CTE), then group by user_id to count transactions\nLUB = Latest User Balance, which is the most recent balance for each user\nTo determine user notification preferences, use a join between the users and user_setting_snapshot tables in a CTE, focusing on selecting the most recent snapshot for each user.\nFor analyzing coupon usage, start with a join between the coupons and wallet_transactions_daily tables in a CTE, apply filtering as needed, and then perform aggregation for the total discount amount", "generated_query": "SELECT t.user_id,\n       t.balance,\n       t.updated_at\nFROM wallet_user_balance_daily AS t\nJOIN\n  (SELECT user_id,\n          MAX(updated_at) AS max_updated_at\n   FROM wallet_user_balance_daily\n   GROUP BY user_id) AS m ON t.user_id = m.user_id\nAND t.updated_at = m.max_updated_at;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.153055667877197, "tokens_used": 1598, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.28699}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_cte_window", "query": "WITH merchant_revenue AS (SELECT m.mid, m.category AS merchant_category, SUM(w.amount) AS total_revenue FROM merchants AS m INNER JOIN wallet_transactions_daily AS w ON m.mid = w.receiver_id AND w.receiver_type = 1 WHERE w.status = 'success' GROUP BY m.mid, m.category) SELECT *, RANK() OVER (ORDER BY CASE WHEN total_revenue IS NULL THEN 1 ELSE 0 END DESC, total_revenue DESC) AS mrr FROM merchant_revenue;WITH merchant_revenue AS (SELECT m.name, m.category AS merchant_category, SUM(w.amount) AS total_revenue FROM merchants AS m INNER JOIN wallet_transactions_daily AS w ON m.mid = w.receiver_id AND w.receiver_type = 1 WHERE w.status = 'success' GROUP BY m.name, m.category) SELECT *, RANK() OVER (ORDER BY CASE WHEN total_revenue IS NULL THEN 1 ELSE 0 END DESC, total_revenue DESC) AS mrr FROM merchant_revenue;WITH merchant_revenue AS (SELECT m.mid, m.name, m.category AS merchant_category, SUM(w.amount) AS total_revenue FROM merchants AS m INNER JOIN wallet_transactions_daily AS w ON m.mid = w.receiver_id AND w.receiver_type = 1 WHERE w.status = 'success' GROUP BY m.mid, m.name, m.category) SELECT *, RANK() OVER (ORDER BY CASE WHEN total_revenue IS NULL THEN 1 ELSE 0 END DESC, total_revenue DESC) AS mrr FROM merchant_revenue;", "question": "What is the MRR for each merchant? Return the merchant name, category, revenue amount, and revenue rank.", "instructions": "\nFollow the instructions below to generate the query:\nMRR = Merchant Revenue Rank, which ranks merchants based on amounts from successfully received transactions only.\nFilter receiver_type=1 in wallet_transactions_daily for merchants.\nMerchant with rank 1 has the highest revenue.\n", "full_instructions": "To get user notification preferences, join the users and user_setting_snapshot tables in a CTE, then select the latest snapshot for each user\nMerchant category should be matched case-insensitively with wildcards, e.g., using LOWER(merchants.category) LIKE '%...%'.\nMRR = Merchant Revenue Rank, which ranks merchants based on their total successful received transaction amounts. Filter receiver_type=1 in wallet_transactions_daily for merchants. Merchant with rank 1 has the highest revenue.\nTo analyze user engagement, join the users and user_sessions tables in a CTE, then aggregate to calculate total session duration per user", "generated_query": "SELECT m.name,\n       m.category,\n       SUM(wtd.amount) AS revenue_amount,\n       RANK() OVER (\n                    ORDER BY SUM(wtd.amount) DESC) AS revenue_rank\nFROM merchants m\nJOIN wallet_transactions_daily wtd ON m.mid = wtd.receiver_id\nWHERE wtd.receiver_type = 1\n  AND wtd.status = 'success'\nGROUP BY m.mid,\n         m.name,\n         m.category\nORDER BY revenue_rank;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 7.964360952377319, "tokens_used": 2043, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.47025}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT date(n.created_at,  '-' || ((strftime('%w', n.created_at) + 6) % 7) || ' days') AS WEEK, COUNT(*) AS total_notifications, COUNT(CASE WHEN strftime('%w', n.created_at) IN ('0', '6') THEN 1 END) AS weekend_notifications FROM notifications AS n JOIN users AS u ON n.user_id = u.uid WHERE u.country IN ('US', 'CA') AND n.created_at >= date('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-21 days') AND n.created_at < date('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days') GROUP BY WEEK;", "question": "For users in the US and Canada, how many total notifications were sent in each of the last 3 weeks excluding the current week? How many of those were sent on weekends?", "instructions": "\nFollow the instructions below to generate the query:\nWeekends are Saturdays and Sundays.\nTruncate created_at to week for aggregation.\n", "full_instructions": "To gauge user engagement, link users to their sessions without defining a specific date range for total session duration analysis\nTo analyze coupon usage, join the coupons and transactions tables to aggregate total discount amounts without specifying a merchant\nMerchant categories should be matched using a case-insensitive pattern without necessitating wildcards.\nWeekends are Saturdays and Sundays. Truncate created_at to week for aggregation.", "generated_query": "SELECT strftime('%Y-%W', n.created_at) AS WEEK,\n       COUNT(*) AS total_notifications,\n       SUM(CASE\n               WHEN strftime('%w', n.created_at) IN ('0', '6') THEN 1\n               ELSE 0\n           END) AS weekend_notifications\nFROM notifications n\nJOIN users u ON u.uid = n.user_id\nWHERE u.country IN ('US',\n                    'CA')\n  AND n.created_at >= date('now', 'weekday 0', '-7 days', '-21 days')\n  AND n.created_at < date('now', 'weekday 0', '-7 days')\nGROUP BY strftime('%Y-%W', n.created_at)\nORDER BY WEEK;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 18.118885040283203, "tokens_used": 4191, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 1.41933}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT COUNT(*) AS num_transactions, SUM(amount) AS total_amount FROM wallet_transactions_daily AS t JOIN users AS u ON t.sender_id = u.uid WHERE u.country = 'US' AND t.created_at >= DATE('now', '-7 days') AND t.created_at < DATE('now', '+1 day');", "question": "How many wallet transactions were made by users from the US in the last 7 days inclusive of today? Return the number of transactions and total transaction amount.", "instructions": "\nFollow the instructions below to generate the query:\nLast 7 days = DATE('now', -'7 days') to DATE('now').\nAlways join wallet_transactions_daily with users before using the wallet_transactions_daily table.\n", "full_instructions": "To analyze coupon usage, join the coupons and wallet_transactions tables in a CTE, filter for a specific merchant, then aggregate to get the total discount amount\nLast 7 days = DATE('now', -'7 days') to DATE('now'). Always join wallet_transactions_daily with users before using the wallet_transactions_daily table.\nTo get user notification preferences, join the users and user_setting_snapshot tables in a CTE, then select the latest snapshot for each user.\nTo get the total number of transactions per user, join the users and wallet_transactions tables in a CTE, then aggregate by user_uid and count the number of transactions", "generated_query": "SELECT COUNT(*) AS transaction_count,\n       SUM(wallet_transactions_daily.amount) AS total_amount\nFROM wallet_transactions_daily\nJOIN users ON wallet_transactions_daily.sender_id = users.uid\nWHERE users.country = 'US'\n  AND wallet_transactions_daily.created_at BETWEEN DATE('now', '-7 days') AND DATE('now');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.436965227127075, "tokens_used": 2015, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.4576}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "SELECT strftime('%Y-%m', t.created_at) AS month, COUNT(DISTINCT t.sender_id) AS active_users FROM wallet_transactions_daily AS t WHERE t.sender_type = 0 AND t.created_at >= date('now', 'start of month', '-2 months') AND t.created_at < date('now', 'start of month') GROUP BY month;", "question": "What is the PMDAU (Per Month Daily Active Users) for wallet transactions in the last 2 months excluding the current month?", "instructions": "\nFollow the instructions below to generate the query:\nPMDAU (Per Month Daily Active Users) = COUNT(DISTINCT(sender_id) ...\nWHERE t.sender_type = 0.\nTruncate created_at to month for aggregation.\n", "full_instructions": "PMDAU (Per Month Daily Active Users) = COUNT(DISTINCT(sender_id) ... WHERE t.sender_type = 0. Truncate created_at to month for aggregation. To analyze coupon usage, join the coupons and wallet_transactions_daily tables in a CTE, filter for transactions associated with a specific merchant, then aggregate to calculate the total discount amount received To get the total number of transactions per user, join the users and wallet_transactions_daily tables in a common table expression (CTE), then aggregate by user_id and count the transactions To get user notification preferences, join the users and user_setting_snapshot tables in a CTE, then select the most recent snapshot for each user.", "generated_query": "SELECT strftime('%Y-%m', created_at) AS MONTH,\n       COUNT(DISTINCT sender_id) AS PMDAU\nFROM wallet_transactions_daily\nWHERE sender_type = 0\n  AND created_at >= date('now', 'start of month', '-2 months')\n  AND created_at < date('now', 'start of month')\nGROUP BY MONTH;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.720629930496216, "tokens_used": 1963, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43538000000000004}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_date_join", "query": "WITH coupons_per_merchant AS (SELECT m.mid, COUNT(c.cid) AS num_coupons FROM coupons AS c JOIN merchants AS m ON m.mid = c.merchant_id AND strftime('%Y-%m', c.created_at) = strftime('%Y-%m', m.created_at) GROUP BY m.mid) SELECT coupons_per_merchant.mid, m.name, coupons_per_merchant.num_coupons FROM coupons_per_merchant JOIN merchants AS m USING (mid) ORDER BY coupons_per_merchant.num_coupons DESC LIMIT 1;", "question": "Which merchant created the highest number of coupons within the same month that the merchant was created (coupon or merchant can be created earlier than the other)? Return the number of coupons along with the merchant's id and name.", "instructions": "\nFollow the instructions below to generate the query:\nIf events from 2 different tables from the same interval are to be joined, join on the respective truncated date fields eg `FROM t1 JOIN t2 ON DATE(t1.date, '<interval>') = DATE(t2.date, '<interval>').\n", "full_instructions": "To analyze coupon usage, join the coupons and wallet_transactions_daily tables in a CTE, filtering for specific merchants, then aggregate If events from 2 different tables from the same interval are to be joined, join on the respective truncated date fields eg `FROM t1 JOIN t2 ON DATE(t1.date, '<interval>') = DATE(t2.date, '<interval>'). To get the total number of transactions per user, join the users and wallet_transactions_daily tables in a CTE, then aggregate by user_id To get user notification preferences, join the users and user_setting_snapshot tables in a CTE, selecting the most recent snapshot for each user.", "generated_query": "SELECT m.mid,\n       m.name,\n       COUNT(c.cid) AS coupon_count\nFROM merchants m\nJOIN coupons c ON m.mid = c.merchant_id\nAND DATE(m.created_at, 'start of month') = DATE(c.created_at, 'start of month')\nGROUP BY m.mid,\n         m.name\nORDER BY coupon_count DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.898487091064453, "tokens_used": 1996, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43934000000000006}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT m.name, COUNT(c.cid) AS total_coupons FROM merchants AS m JOIN coupons AS c ON m.mid = c.merchant_id WHERE m.status = 'active' AND LOWER(m.category) LIKE '%retail%' GROUP BY m.name;", "question": "How many active retail merchants have issued coupons? Return the merchant name and the total number of coupons issued.", "instructions": "\nFollow the instructions below to generate the query:\nMerchant category should be matched case-insensitively with wildcards, e.g., LOWER(merchants.category) LIKE '%...%'.\n", "full_instructions": "To determine user notification settings, combine the users and user_settings tables in a CTE, selecting the most recent settings for each user.\nMerchant category should be matched case-insensitively with wildcards, e.g., LOWER(merchants.category) LIKE '%...%'.\nTo get the total number of transactions per user, join the users and wallet_transactions tables in a common table expression (CTE), then sum up transactions by user ID\nTo assess coupon utilization, link the coupons and wallet_transactions tables in a CTE, filter for particular merchants, then calculate the total discount amounts", "generated_query": "SELECT m.name AS merchant_name,\n       COUNT(c.cid) AS total_coupons\nFROM merchants m\nJOIN coupons c ON m.mid = c.merchant_id\nWHERE LOWER(m.category) LIKE '%retail%'\n  AND m.status = 'active'\nGROUP BY m.mid,\n         m.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.1779258251190186, "tokens_used": 1613, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.28600000000000003}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "instructions_string_matching", "query": "SELECT u.username, COUNT(n.id) AS total_notifications FROM users AS u JOIN notifications AS n ON u.uid = n.user_id WHERE n.type = 'promotion' AND n.status = 'unread' AND LOWER(u.country) = 'us' GROUP BY u.username;", "question": "Which users from the US have unread promotional notifications? Return the username and the total number of unread promotional notifications.", "instructions": "\nFollow the instructions below to generate the query:\nUser country should be matched case-insensitively, e.g., LOWER(users.country) = 'us'.\nNotification type and status should be matched exactly.\n", "full_instructions": "For merchant revenue analysis, rank merchants by their total successful transaction amounts without specifying any rank number To derive user engagement metrics, aggregate total session durations for users by joining with the user_sessions table over an unspecified date range. To calculate the Average Balance of user wallets, join the users and wallet_transactions_daily tables, then compute the average balance for a specified period User country should be matched case-insensitively, e.g., LOWER(users.country) = 'us'. Notification type and status should be matched exactly.", "generated_query": "SELECT u.username,\n       COUNT(n.id) AS total_unread_promotions\nFROM users u\nJOIN notifications n ON u.uid = n.user_id\nWHERE LOWER(u.country) = 'us'\n  AND n.type = 'promotion'\n  AND n.status = 'unread'\nGROUP BY u.uid,\n         u.username;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.2482709884643555, "tokens_used": 1618, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.28688}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT COUNT(*) AS TUC FROM user_sessions WHERE session_start_ts >= DATE('now', '-1 month') OR session_end_ts >= DATE('now', '-1 month');", "question": "What is the TUC in the past month, inclusive of 1 month ago? Return the total count.", "instructions": "\nFollow the instructions below to generate the query:\nTUC = Total number of user sessions in the past month\n", "full_instructions": "To analyze coupon usage, join the coupons and transactions tables in a CTE, filtering for any required criteria, then aggregate to find the total discount amount TUC = Total number of user sessions in the past month To get user notification preferences, join the users and settings tables in a CTE, selecting the most recent settings snapshot for each user. To get the total number of transactions per user, join the users and transactions tables in a common table expression (CTE), then aggregate by user_id to count transactions", "generated_query": "SELECT COUNT(*) AS total_count\nFROM user_sessions\nWHERE session_start_ts BETWEEN datetime('now', '-1 month') AND datetime('now');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.115751266479492, "tokens_used": 1565, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.2695}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "keywords_aggregate", "query": "SELECT AVG(balance) AS AMB FROM wallet_user_balance_daily WHERE updated_at >= DATE('now', '-7 days');", "question": "What is the average AMB for user wallets updated in the past week, inclusive of 7 days ago? Return the average balance.", "instructions": "\nFollow the instructions below to generate the query:\nAMB = average balance per user (for the given time duration)\n", "full_instructions": "For coupon usage analysis, join the coupons and wallet_transactions_daily tables in a CTE, filtering for merchants of interest, and aggregate to compute the total discount amount utilized\nTo get the total number of transactions per user, join the users and wallet_transactions_daily tables in a Common Table Expression (CTE), then aggregate by user_id to count the transactions\nTo determine user notification preferences, join the users table with the user_setting_snapshot table in a CTE, selecting the most recent settings snapshot for each user.\nAMB = average balance per user (for the given time duration)", "generated_query": "SELECT AVG(balance) AS average_balance\nFROM wallet_user_balance_daily\nWHERE updated_at >= datetime('now', '-7 days');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.200840473175049, "tokens_used": 1695, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.32505}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT m.name, (COUNT(DISTINCT wtd.coupon_id) * 1.0 / NULLIF(COUNT(DISTINCT wtd.txid), 0)) AS CPUR FROM wallet_transactions_daily AS wtd JOIN merchants AS m ON wtd.receiver_id = m.mid WHERE wtd.status = 'success' GROUP BY m.name;", "question": "Calculate the CPUR for each merchant, considering only successful transactions. Return the merchant name and CPUR.", "instructions": "\nFollow the instructions below to generate the query:\nCPUR (coupon usage rate) = number of distinct coupons used / number of distinct transactions\n", "full_instructions": "To get the total number of transactions per user, join the users and wallet_transactions tables, then aggregate by user_id To analyze user engagement, join the users and user_sessions tables, then aggregate to calculate the total session duration per user for a given period. CPUR (coupon usage rate) = number of distinct coupons used / number of distinct transactions To get user notification preferences, join the users and user_settings tables, then select the latest settings for each user", "generated_query": "SELECT m.name,\n       CASE\n           WHEN COUNT(DISTINCT w.txid) = 0 THEN 0\n           ELSE 1.0 * COUNT(DISTINCT CASE\n                                         WHEN w.coupon_id IS NOT NULL THEN w.coupon_id\n                                     END) / COUNT(DISTINCT w.txid)\n       END AS CPUR\nFROM merchants m\nJOIN wallet_transactions_daily w ON m.mid = w.receiver_id\nWHERE w.status = 'success'\nGROUP BY m.mid,\n         m.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 10.915974855422974, "tokens_used": 2924, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.86581}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "keywords_ratio", "query": "SELECT (SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS STR FROM wallet_transactions_daily WHERE strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now', 'start of month', '-1 month');", "question": "What was the STR for wallet transactions in the previous month?", "instructions": "\nFollow the instructions below to generate the query:\nSTR (success transaction rate) = number of successful transactions / total number of transactions\n", "full_instructions": "To analyze user engagement, join the users and sessions tables in a CTE, then aggregate to measure total session length per user for a specified period.\nTo get user notification preferences, join the users and settings tables in a CTE, then filter for the most recent settings per user\nSTR (success transaction rate) = number of successful transactions / total number of transactions\nTo analyze coupon usage, join the coupons and transactions tables in a CTE, filter for a particular merchant, then aggregate to calculate the total discount value", "generated_query": "SELECT CAST(SUM(CASE\n                    WHEN status = 'success' THEN 1\n                    ELSE 0\n                END) AS FLOAT) / COUNT(*) AS STR\nFROM wallet_transactions_daily\nWHERE created_at >= date('now', 'start of month', '-1 month')\n  AND created_at < date('now', 'start of month');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.98371958732605, "tokens_used": 1533, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.2574}]