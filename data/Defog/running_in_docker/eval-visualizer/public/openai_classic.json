[{"db_name": "academic", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT publication.year, AVG(publication.citation_num) AS average_citations FROM publication GROUP BY publication.year ORDER BY publication.year NULLS LAST;", "question": "What is the average number of citations received by publications in each year?", "instructions": "", "generated_query": "SELECT YEAR,\n       AVG(citation_num) AS avg_citations\nFROM publication\nGROUP BY YEAR;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.4295270442962646, "tokens_used": 1009, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14201}, {"db_name": "academic", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT domain.name, AVG(publication.reference_num) AS average_references FROM domain_publication JOIN publication ON domain_publication.pid = publication.pid JOIN domain ON domain.did = domain_publication.did GROUP BY domain.name;SELECT domain.did, AVG(publication.reference_num) AS average_references FROM domain_publication JOIN publication ON domain_publication.pid = publication.pid JOIN domain ON domain.did = domain_publication.did GROUP BY domain.did;SELECT domain.name, domain.did, AVG(publication.reference_num) AS average_references FROM domain_publication JOIN publication ON domain_publication.pid = publication.pid JOIN domain ON domain.did = domain_publication.did GROUP BY domain.name, domain.did;", "question": "What is the average number of references cited by publications in each domain name?", "instructions": "", "generated_query": "SELECT d.name AS domain_name,\n       AVG(p.reference_num) AS avg_references\nFROM DOMAIN AS d\nJOIN domain_publication AS dp ON d.did = dp.did\nJOIN publication AS p ON dp.pid = p.pid\nGROUP BY d.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.1405720710754395, "tokens_used": 1236, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.24156000000000005}, {"db_name": "academic", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT author.name, SUM(publication.citation_num) AS total_citations FROM author JOIN writes ON author.aid = writes.aid JOIN publication ON writes.pid = publication.pid GROUP BY author.name ORDER BY total_citations DESC;SELECT author.aid, SUM(publication.citation_num) AS total_citations FROM author JOIN writes ON author.aid = writes.aid JOIN publication ON writes.pid = publication.pid GROUP BY author.aid ORDER BY total_citations DESC;SELECT author.name, author.aid, SUM(publication.citation_num) AS total_citations FROM author JOIN writes ON author.aid = writes.aid JOIN publication ON writes.pid = publication.pid GROUP BY author.name, author.aid ORDER BY total_citations DESC;SELECT a.aid, COUNT(c.cited) AS total_citations FROM author AS a JOIN writes AS w ON a.aid = w.aid JOIN publication AS p ON w.pid = p.pid JOIN cite AS c ON p.pid = c.cited GROUP BY a.aid ORDER BY total_citations DESC NULLS FIRST;SELECT a.name, COUNT(c.cited) AS total_citations FROM author AS a JOIN writes AS w ON a.aid = w.aid JOIN publication AS p ON w.pid = p.pid JOIN cite AS c ON p.pid = c.cited GROUP BY a.name ORDER BY total_citations DESC NULLS FIRST;SELECT a.aid, a.name, COUNT(c.cited) AS total_citations FROM author AS a JOIN writes AS w ON a.aid = w.aid JOIN publication AS p ON w.pid = p.pid JOIN cite AS c ON p.pid = c.cited GROUP BY a.aid, a.name ORDER BY total_citations DESC NULLS FIRST;", "question": "What is the total number of citations received by each author?", "instructions": "", "generated_query": "SELECT a.name,\n       SUM(p.citation_num) AS total_citations\nFROM author a\nJOIN writes w ON a.aid = w.aid\nJOIN publication p ON w.pid = p.pid\nGROUP BY a.aid;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.9291398525238037, "tokens_used": 1226, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23815}, {"db_name": "academic", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT publication.year, COUNT(DISTINCT publication.pid) AS total_publications FROM publication GROUP BY publication.year ORDER BY publication.year NULLS LAST;", "question": "What is the total number of publications published in each year?", "instructions": "", "generated_query": "SELECT YEAR,\n       COUNT(*) AS total_publications\nFROM publication\nGROUP BY YEAR;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.1669762134552, "tokens_used": 1004, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14047}, {"db_name": "academic", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT author.name FROM author WHERE author.aid IN (SELECT domain_author.aid FROM domain_author WHERE domain_author.did IN (SELECT domain.did FROM DOMAIN WHERE domain.name IN ('Machine Learning', 'Data Science')) GROUP BY 1 HAVING COUNT(DISTINCT domain_author.did) = 2);SELECT author.aid FROM author WHERE author.aid IN (SELECT domain_author.aid FROM domain_author WHERE domain_author.did IN (SELECT domain.did FROM DOMAIN WHERE domain.name IN ('Machine Learning', 'Data Science')) GROUP BY 1 HAVING COUNT(DISTINCT domain_author.did) = 2);SELECT author.name, author.aid FROM author WHERE author.aid IN (SELECT domain_author.aid FROM domain_author WHERE domain_author.did IN (SELECT domain.did FROM DOMAIN WHERE domain.name IN ('Machine Learning', 'Data Science')) GROUP BY 1 HAVING COUNT(DISTINCT domain_author.did) = 2);", "question": "Which authors have written publications in both the domain \"Machine Learning\" and the domain \"Data Science\"?", "instructions": "", "generated_query": "SELECT a.name\nFROM author a\nJOIN writes w ON a.aid = w.aid\nJOIN domain_publication dp ON w.pid = dp.pid\nJOIN DOMAIN d ON dp.did = d.did\nWHERE d.name IN ('Machine Learning',\n                 'Data Science')\nGROUP BY a.aid,\n         a.name\nHAVING COUNT(DISTINCT d.name) = 2;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.5838963985443115, "tokens_used": 1263, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25179}, {"db_name": "academic", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT author.name FROM author JOIN writes ON author.aid = writes.aid JOIN publication ON writes.pid = publication.pid JOIN domain_publication ON publication.pid = domain_publication.pid JOIN domain ON domain_publication.did = domain.did WHERE LOWER(domain.name) LIKE LOWER('%computer%science%');", "question": "What are the names of the authors who have written publications in the domain \"Computer Science\"?", "instructions": "\nFollow the instructions below to generate the query:\nTo get publications written by authors from a given domain, you would need to join domain, domain_author, author to link the domain to the author first, and then join with write to link with the publication id.\nYou must also filter names using LIKE.\n", "generated_query": "SELECT DISTINCT author.name\nFROM DOMAIN\nJOIN domain_author ON domain.did = domain_author.did\nJOIN author ON domain_author.aid = author.aid\nJOIN writes ON author.aid = writes.aid\nWHERE domain.name LIKE '%Computer Science%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.4445762634277344, "tokens_used": 1168, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19085}, {"db_name": "academic", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT publication.title FROM DOMAIN JOIN domain_author ON domain.did = domain_author.did JOIN writes ON domain_author.aid = writes.aid JOIN publication ON writes.pid = publication.pid JOIN domain_conference ON domain.did = domain_conference.did WHERE LOWER(domain.name) LIKE LOWER('%Sociology%') AND publication.year = 2020 AND publication.cid = domain_conference.cid;SELECT DISTINCT publication.pid FROM DOMAIN JOIN domain_author ON domain.did = domain_author.did JOIN writes ON domain_author.aid = writes.aid JOIN publication ON writes.pid = publication.pid JOIN domain_conference ON domain.did = domain_conference.did WHERE LOWER(domain.name) LIKE LOWER('%Sociology%') AND publication.year = 2020 AND publication.cid = domain_conference.cid;SELECT DISTINCT publication.title, publication.pid FROM DOMAIN JOIN domain_author ON domain.did = domain_author.did JOIN writes ON domain_author.aid = writes.aid JOIN publication ON writes.pid = publication.pid JOIN domain_conference ON domain.did = domain_conference.did WHERE LOWER(domain.name) LIKE LOWER('%Sociology%') AND publication.year = 2020 AND publication.cid = domain_conference.cid;", "question": "What are the publications written by authors from the 'Sociology' domain and presented at conferences in the year 2020?", "instructions": "\nFollow the instructions below to generate the query:\nTo get publications written by authors from a given domain, you would need to join domain, domain_author, author to link the domain to the author first, and then join with write to link with the publication id.\nFinally, to see which ones were presented at conferences, you must join the domain table with the domain_conference table.\nYou must also filter names using LIKE.\n", "generated_query": "SELECT DISTINCT p.*\nFROM DOMAIN d\nJOIN domain_author da ON d.did = da.did\nJOIN author a ON da.aid = a.aid\nJOIN writes w ON a.aid = w.aid\nJOIN publication p ON w.pid = p.pid\nJOIN conference c ON p.cid = c.cid\nJOIN domain_conference dc ON d.did = dc.did\nAND c.cid = dc.cid\nWHERE d.name LIKE '%Sociology%'\n  AND p.year = 2020;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 11.711210489273071, "tokens_used": 2848, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.91949}, {"db_name": "academic", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT name FROM author WHERE oid IS NULL;SELECT DISTINCT aid FROM author WHERE oid IS NULL;SELECT DISTINCT name, aid FROM author WHERE oid IS NULL;", "question": "Which authors are not part of any organization?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE\n", "generated_query": "SELECT a.name\nFROM author a\nLEFT JOIN\nORGANIZATION o ON a.oid = o.oid\nWHERE o.oid IS NULL\n  AND a.name LIKE '%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.8290226459503174, "tokens_used": 1418, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.31867}, {"db_name": "academic", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT a2.name FROM author AS a1 JOIN domain_author AS da1 ON a1.aid = da1.aid JOIN domain_author AS da2 ON da1.did = da2.did JOIN author AS a2 ON da2.aid = a2.aid WHERE LOWER(LOWER(a1.name)) LIKE LOWER('%martin%');SELECT DISTINCT a2.aid FROM author AS a1 JOIN domain_author AS da1 ON a1.aid = da1.aid JOIN domain_author AS da2 ON da1.did = da2.did JOIN author AS a2 ON da2.aid = a2.aid WHERE LOWER(LOWER(a1.name)) LIKE LOWER('%martin%');SELECT DISTINCT a2.name, a2.aid FROM author AS a1 JOIN domain_author AS da1 ON a1.aid = da1.aid JOIN domain_author AS da2 ON da1.did = da2.did JOIN author AS a2 ON da2.aid = a2.aid WHERE LOWER(LOWER(a1.name)) LIKE LOWER('%martin%');", "question": "Which authors belong to the same domain as Martin?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE with percent sign wildcards\n", "generated_query": "SELECT DISTINCT a.name\nFROM author a\nJOIN domain_author da ON a.aid = da.aid\nWHERE da.did IN\n    (SELECT da2.did\n     FROM author a2\n     JOIN domain_author da2 ON a2.aid = da2.aid\n     WHERE a2.name LIKE '%Martin%');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.802040100097656, "tokens_used": 1839, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.50193}, {"db_name": "academic", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT organization.name FROM organization JOIN author ON organization.oid = author.oid JOIN writes ON author.aid = writes.aid JOIN domain_publication ON writes.pid = domain_publication.pid JOIN domain ON domain_publication.did = domain.did WHERE domain.name = 'Machine Learning';SELECT DISTINCT organization.oid FROM organization JOIN author ON organization.oid = author.oid JOIN writes ON author.aid = writes.aid JOIN domain_publication ON writes.pid = domain_publication.pid JOIN domain ON domain_publication.did = domain.did WHERE domain.name = 'Machine Learning';SELECT DISTINCT organization.name, organization.oid FROM organization JOIN author ON organization.oid = author.oid JOIN writes ON author.aid = writes.aid JOIN domain_publication ON writes.pid = domain_publication.pid JOIN domain ON domain_publication.did = domain.did WHERE domain.name = 'Machine Learning';", "question": "Which organizations have authors who have written publications in the domain \"Machine Learning\"?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using an exact match\n", "generated_query": "SELECT DISTINCT organization.name\nFROM\nORGANIZATION\nJOIN author ON organization.oid = author.oid\nJOIN writes ON author.aid = writes.aid\nJOIN publication ON writes.pid = publication.pid\nJOIN domain_publication ON publication.pid = domain_publication.pid\nJOIN DOMAIN ON domain_publication.did = domain.did\nWHERE domain.name = 'Machine Learning';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.114717483520508, "tokens_used": 1462, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.3353900000000001}, {"db_name": "academic", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT DISTINCT publication.title FROM publication ORDER BY publication.title ASC NULLS LAST;", "question": "What are the titles of all publications ordered alphabetically?", "instructions": "", "generated_query": "SELECT title\nFROM publication\nORDER BY title ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.1721644401550293, "tokens_used": 1059, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.165}, {"db_name": "academic", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT publication.title, publication.citation_num FROM publication ORDER BY publication.citation_num DESC NULLS FIRST LIMIT 3;SELECT publication.pid, publication.citation_num FROM publication ORDER BY publication.citation_num DESC NULLS FIRST LIMIT 3;SELECT publication.title, publication.pid, publication.citation_num FROM publication ORDER BY publication.citation_num DESC NULLS FIRST LIMIT 3;", "question": "What are the top 3 publications with the highest number of citations?", "instructions": "", "generated_query": "SELECT pid,\n       title,\n       citation_num\nFROM publication\nORDER BY citation_num DESC\nLIMIT 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.0156984329223633, "tokens_used": 1138, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19877000000000003}, {"db_name": "academic", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT publication.title FROM publication ORDER BY publication.reference_num DESC NULLS FIRST LIMIT 3;", "question": "What are the top 3 titles of the publications that have the highest number of references cited, ordered by the number of references cited in descending order?", "instructions": "", "generated_query": "SELECT title\nFROM publication\nORDER BY reference_num DESC\nLIMIT 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.115903377532959, "tokens_used": 1277, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25465000000000004}, {"db_name": "academic", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT d.name, COUNT(DISTINCT a.aid) AS author_count FROM author AS a JOIN domain_author AS da ON a.aid = da.aid JOIN domain AS d ON da.did = d.did GROUP BY d.name ORDER BY author_count DESC NULLS FIRST LIMIT 5;SELECT d.did, COUNT(DISTINCT a.aid) AS author_count FROM author AS a JOIN domain_author AS da ON a.aid = da.aid JOIN domain AS d ON da.did = d.did GROUP BY d.did ORDER BY author_count DESC NULLS FIRST LIMIT 5;SELECT d.name, d.did, COUNT(DISTINCT a.aid) AS author_count FROM author AS a JOIN domain_author AS da ON a.aid = da.aid JOIN domain AS d ON da.did = d.did GROUP BY d.name, d.did ORDER BY author_count DESC NULLS FIRST LIMIT 5;", "question": "What are the top 5 domains with the highest number of authors associated with them?", "instructions": "", "generated_query": "SELECT d.name,\n       COUNT(DISTINCT da.aid) AS author_count\nFROM DOMAIN AS d\nJOIN domain_author AS da ON d.did = da.did\nGROUP BY d.did\nORDER BY author_count DESC\nLIMIT 5;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.826824903488159, "tokens_used": 1168, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.21098000000000003}, {"db_name": "academic", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT publication.title FROM publication ORDER BY publication.citation_num DESC LIMIT 1;", "question": "What is the title of the publication that has received the highest number of citations?", "instructions": "", "generated_query": "SELECT title\nFROM publication\nORDER BY citation_num DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.201042890548706, "tokens_used": 1068, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.16731000000000001}, {"db_name": "academic", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT organization.continent, CAST(COUNT(DISTINCT author.aid) AS REAL) / NULLIF(COUNT(DISTINCT organization.oid), 0) AS ratio FROM organization LEFT JOIN author ON author.oid = organization.oid GROUP BY organization.continent ORDER BY ratio DESC;WITH author_counts AS (SELECT o.continent, COUNT(DISTINCT a.aid) AS author_count FROM author AS a JOIN organization AS o ON a.oid = o.oid GROUP BY o.continent), organization_counts AS (SELECT o.continent, COUNT(DISTINCT o.oid) AS organization_count FROM organization AS o GROUP BY o.continent) SELECT ac.continent, CAST(ac.author_count AS DOUBLE) / NULLIF(oc.organization_count, 0) AS author_to_organization_ratio FROM author_counts AS ac JOIN organization_counts AS oc ON ac.continent = oc.continent ORDER BY author_to_organization_ratio DESC;", "question": "How does the ratio of authors to organizations differ by continent?", "instructions": "", "generated_query": "SELECT o.continent,\n       COUNT(DISTINCT a.aid) * 1.0 / COUNT(DISTINCT o.oid) AS author_org_ratio\nFROM\nORGANIZATION o\nLEFT JOIN author a ON o.oid = a.oid\nGROUP BY o.continent;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.3742311000823975, "tokens_used": 1621, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.41195}, {"db_name": "academic", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT publication.year, COUNT(DISTINCT publication.pid) AS num_publications, COUNT(DISTINCT publication.jid) AS num_journals, CAST(COUNT(DISTINCT publication.pid) AS REAL) / NULLIF(COUNT(DISTINCT publication.jid), 0) AS ratio FROM publication GROUP BY publication.year ORDER BY publication.year NULLS LAST;", "question": "How does the ratio of publications to journals change over the years? Return the annual numbers of publications and journals as well.", "instructions": "", "generated_query": "SELECT YEAR,\n       COUNT(pid) AS publications,\n       COUNT(DISTINCT jid) AS journals,\n       1.0 * COUNT(pid) / COUNT(DISTINCT jid) AS pub_to_journal_ratio\nFROM publication\nGROUP BY YEAR\nORDER BY YEAR;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.440121412277222, "tokens_used": 1375, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.29975}, {"db_name": "academic", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(DISTINCT CASE WHEN NOT cid IS NULL THEN pid END) AS REAL) / NULLIF(COUNT(DISTINCT CASE WHEN NOT jid IS NULL THEN pid END), 0) AS ratio FROM publication;", "question": "What is the ratio of publications presented in conferences to publications published in journals?", "instructions": "", "generated_query": "SELECT\n  (SELECT COUNT(*)\n   FROM publication\n   WHERE cid IS NOT NULL) * 1.0 /\n  (SELECT COUNT(*)\n   FROM publication\n   WHERE jid IS NOT NULL) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.6555676460266113, "tokens_used": 1220, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23452000000000003}, {"db_name": "academic", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(DISTINCT publication.pid) AS REAL) / NULLIF(COUNT(DISTINCT author.aid), 0) AS publication_to_author_ratio FROM publication, author;", "question": "What is the ratio of publications to authors in the database?", "instructions": "", "generated_query": "SELECT\n  (SELECT COUNT(*)\n   FROM publication) * 1.0 /\n  (SELECT COUNT(*)\n   FROM author) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.1089670658111572, "tokens_used": 1203, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22802999999999998}, {"db_name": "academic", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT domain_publication.did, CAST(COUNT(DISTINCT domain_publication.pid) AS REAL) / NULLIF(COUNT(DISTINCT domain_keyword.kid), 0) AS publication_to_keyword_ratio FROM domain_publication LEFT JOIN domain_keyword ON domain_publication.did = domain_keyword.did GROUP BY domain_publication.did ORDER BY publication_to_keyword_ratio DESC;SELECT domain_publication.did, CAST(COUNT(DISTINCT domain_publication.pid) AS REAL) / NULLIF(COUNT(DISTINCT domain_keyword.kid), 0) AS publication_to_keyword_ratio FROM domain_keyword LEFT JOIN domain_publication ON domain_publication.did = domain_keyword.did GROUP BY domain_publication.did ORDER BY publication_to_keyword_ratio DESC;SELECT d.did, COALESCE(CAST(COUNT(DISTINCT dp.pid) AS REAL) / NULLIF(COUNT(DISTINCT dk.kid), 0), 0) AS publication_to_keyword_ratio FROM domain AS d LEFT JOIN domain_publication AS dp ON d.did = dp.did LEFT JOIN domain_keyword AS dk ON d.did = dk.did GROUP BY d.did ORDER BY publication_to_keyword_ratio DESC;", "question": "What is the ratio of the total number of publications to the total number of keywords within each domain ID? Show all domain IDs.", "instructions": "", "generated_query": "SELECT d.did,\n       CASE\n           WHEN COALESCE(kw.total_keywords, 0) = 0 THEN NULL\n           ELSE 1.0 * COALESCE(pub.total_publications, 0) / kw.total_keywords\n       END AS ratio\nFROM DOMAIN d\nLEFT JOIN\n  (SELECT did,\n          COUNT(*) AS total_publications\n   FROM domain_publication\n   GROUP BY did) pub ON d.did = pub.did\nLEFT JOIN\n  (SELECT did,\n          COUNT(*) AS total_keywords\n   FROM domain_keyword\n   GROUP BY did) kw ON d.did = kw.did;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.217117071151733, "tokens_used": 1703, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44340999999999997}, {"db_name": "academic", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT conference.name, COUNT(publication.pid) AS num_publications FROM publication JOIN conference ON publication.cid = conference.cid GROUP BY conference.name, conference.cid ORDER BY num_publications DESC;", "question": "How many publications were presented at each conference, ordered by the number of publications in descending order? Give the names of the conferences and their corresponding number of publications.", "instructions": "", "generated_query": "SELECT conference.name AS conference_name,\n       COUNT(publication.pid) AS publication_count\nFROM publication\nJOIN conference ON publication.cid = conference.cid\nGROUP BY conference.name\nORDER BY publication_count DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.4179461002349854, "tokens_used": 1175, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20911000000000002}, {"db_name": "academic", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT COUNT(DISTINCT publication.pid) FROM publication JOIN journal ON publication.jid = journal.jid WHERE LOWER(journal.name) LIKE LOWER('J%');", "question": "How many publications were published in journals whose names start with the letter \"J\"?", "instructions": "", "generated_query": "SELECT COUNT(*) AS publication_count\nFROM publication\nJOIN journal ON publication.jid = journal.jid\nWHERE journal.name LIKE 'J%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.726334810256958, "tokens_used": 1084, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17435000000000003}, {"db_name": "academic", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT journal.name, COUNT(publication.pid) AS total_publications FROM publication JOIN journal ON publication.jid = journal.jid GROUP BY journal.name ORDER BY total_publications DESC;SELECT journal.jid, COUNT(publication.pid) AS total_publications FROM publication JOIN journal ON publication.jid = journal.jid GROUP BY journal.jid ORDER BY total_publications DESC;SELECT journal.name, journal.jid, COUNT(publication.pid) AS total_publications FROM publication JOIN journal ON publication.jid = journal.jid GROUP BY journal.name, journal.jid ORDER BY total_publications DESC;SELECT journal.name, COUNT(publication.pid) AS total_publications FROM journal LEFT JOIN publication ON journal.jid = publication.jid GROUP BY journal.name ORDER BY total_publications DESC;SELECT journal.jid, COUNT(publication.pid) AS total_publications FROM journal LEFT JOIN publication ON journal.jid = publication.jid GROUP BY journal.jid ORDER BY total_publications DESC;SELECT journal.name, journal.jid, COUNT(publication.pid) AS total_publications FROM journal LEFT JOIN publication ON journal.jid = publication.jid GROUP BY journal.name, journal.jid ORDER BY total_publications DESC;", "question": "What is the total number of publications in each journal, ordered by the number of publications in descending order?", "instructions": "", "generated_query": "SELECT j.name AS journal_name,\n       COUNT(p.pid) AS total_publications\nFROM journal j\nLEFT JOIN publication p ON j.jid = p.jid\nGROUP BY j.jid,\n         j.name\nORDER BY total_publications DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.134521722793579, "tokens_used": 1173, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.21186}, {"db_name": "academic", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT conference.name, COUNT(publication.pid) AS total_publications FROM publication JOIN conference ON publication.cid = conference.cid GROUP BY conference.name ORDER BY total_publications DESC NULLS FIRST;SELECT conference.cid, COUNT(publication.pid) AS total_publications FROM publication JOIN conference ON publication.cid = conference.cid GROUP BY conference.cid ORDER BY total_publications DESC NULLS FIRST;SELECT conference.name, conference.cid, COUNT(publication.pid) AS total_publications FROM publication JOIN conference ON publication.cid = conference.cid GROUP BY conference.name, conference.cid ORDER BY total_publications DESC NULLS FIRST;", "question": "What is the total number of publications presented in each conference?", "instructions": "", "generated_query": "SELECT conference.name,\n       COUNT(publication.pid) AS total_publications\nFROM conference\nJOIN publication ON conference.cid = publication.cid\nGROUP BY conference.cid,\n         conference.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.153212785720825, "tokens_used": 1021, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14795000000000003}, {"db_name": "academic", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT author.name, COUNT(publication.pid) AS publication_count FROM writes JOIN author ON writes.aid = author.aid JOIN publication ON writes.pid = publication.pid WHERE publication.year = 2021 GROUP BY author.name ORDER BY publication_count DESC LIMIT 1;SELECT author.aid, COUNT(publication.pid) AS publication_count FROM writes JOIN author ON writes.aid = author.aid JOIN publication ON writes.pid = publication.pid WHERE publication.year = 2021 GROUP BY author.aid ORDER BY publication_count DESC LIMIT 1;SELECT author.name, author.aid, COUNT(publication.pid) AS publication_count FROM writes JOIN author ON writes.aid = author.aid JOIN publication ON writes.pid = publication.pid WHERE publication.year = 2021 GROUP BY author.name, author.aid ORDER BY publication_count DESC LIMIT 1;", "question": "Which author had the most publications in the year 2021 and how many publications did he/she have that year?", "instructions": "", "generated_query": "SELECT a.name,\n       COUNT(*) AS publication_count\nFROM author a\nJOIN writes w ON a.aid = w.aid\nJOIN publication p ON w.pid = p.pid\nWHERE p.year = 2021\nGROUP BY a.aid,\n         a.name\nORDER BY publication_count DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.6204288005828857, "tokens_used": 1125, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- author AS a\n-- domain AS d\n-- writes AS w\n-- journal AS j\n-- keyword AS k\n-- conference AS co\n-- publication AS p\n-- organization AS o\n-- domain_author AS da\n-- domain_journal AS dj\n-- domain_keyword AS dk\n-- domain_conference AS dc\n-- domain_publication AS dp\n-- publication_keyword AS pk\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19008000000000003}, {"db_name": "advising", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT CAST((julianday('now') - max(julianday(s.admit_term))) AS INTEGER) AS days_since_admit FROM student AS s;", "question": "How long has it been in days since the last admitted student? Give the answer as an integer.", "instructions": "", "generated_query": "SELECT CAST(julianday('now') - julianday(MAX(admit_term)) AS INTEGER) AS days_since_last_admission\nFROM student;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6238555908203125, "tokens_used": 2357, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.3355}, {"db_name": "advising", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(*) AS num_students_graduated FROM student WHERE date(predicted_graduation_semester) >= date('now', '-10 years');", "question": "How many students were predicted to graduate in the last 10 years?", "instructions": "", "generated_query": "SELECT COUNT(*) AS num_students\nFROM student\nWHERE predicted_graduation_semester BETWEEN date('now', '-10 years') AND date('now');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.59675931930542, "tokens_used": 2417, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.36388000000000004}, {"db_name": "advising", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT DISTINCT co.course_id FROM course_offering AS co JOIN offering_instructor AS oi ON co.offering_id = oi.offering_id WHERE (co.semester = 1 OR co.semester = 2) AND co.end_time < '13:00:00' AND NOT co.thursday IS NULL;", "question": "Return the course id's that are offered in either semesters 1 or 2 and ends before 1pm and had an instructor on thursday", "instructions": "", "generated_query": "SELECT DISTINCT course_id\nFROM course_offering\nWHERE semester IN (1,\n                   2)\n  AND end_time < '13:00:00'\n  AND thursday IS NOT NULL\n  AND thursday <> '';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 8.736106157302856, "tokens_used": 3086, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.65329}, {"db_name": "advising", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT strftime('%Y-%m', s.admit_term) AS month, COUNT(*) AS total_students FROM student AS s GROUP BY month ORDER BY total_students DESC LIMIT 1;SELECT strftime('%Y-%m-01', s.admit_term) AS month, COUNT(*) AS total_students FROM student AS s GROUP BY month ORDER BY total_students DESC LIMIT 1;", "question": "What month were most students admitted? Return the no. of students and the month as a date", "instructions": "", "generated_query": "SELECT strftime('%Y-%m-01', admit_term) AS MONTH,\n       COUNT(*) AS num_students\nFROM student\nGROUP BY MONTH\nORDER BY num_students DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.317629337310791, "tokens_used": 2622, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.45243}, {"db_name": "advising", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT AVG(julianday(s.predicted_graduation_semester) - julianday(s.admit_term)) AS average_days_to_graduation FROM student AS s;", "question": "What's the average predicted time to graduation since admission in no. of days?", "instructions": "", "generated_query": "SELECT AVG(julianday(predicted_graduation_semester) - julianday(admit_term)) AS average_predicted_days_to_graduation\nFROM student;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6180036067962646, "tokens_used": 2356, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.33671000000000006}, {"db_name": "advising", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT course_offering.has_final_exam, COUNT(offering_id) AS num_courses FROM course_offering GROUP BY course_offering.has_final_exam;SELECT COUNT(CASE WHEN co.has_final_exam THEN 1 END) AS num_with_final_exam, COUNT(CASE WHEN NOT co.has_final_exam THEN 1 END) AS num_without_final_exam FROM course_offering AS co;", "question": "How many course offerings have a final exam and how many do not?", "instructions": "", "generated_query": "SELECT SUM(CASE\n               WHEN has_final_exam = 1 THEN 1\n               ELSE 0\n           END) AS with_final_exam,\n       SUM(CASE\n               WHEN has_final_exam = 0 THEN 1\n               ELSE 0\n           END) AS without_final_exam\nFROM course_offering;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.128049373626709, "tokens_used": 2441, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.37444}, {"db_name": "advising", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT course_offering.semester, COUNT(DISTINCT course_offering.course_id) AS num_courses FROM course_offering GROUP BY course_offering.semester ORDER BY course_offering.semester NULLS LAST;SELECT semester.semester_id, COUNT(DISTINCT course_offering.course_id) AS num_courses FROM semester LEFT JOIN course_offering ON semester.semester_id = course_offering.semester GROUP BY semester.semester_id;", "question": "How many courses are offered for each semester id?", "instructions": "", "generated_query": "SELECT semester AS semester_id,\n       COUNT(DISTINCT course_id) AS num_courses\nFROM course_offering\nGROUP BY semester;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.3462371826171875, "tokens_used": 2536, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.41756000000000004}, {"db_name": "advising", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT course.department, COUNT(DISTINCT course.course_id) AS num_courses FROM course GROUP BY course.department ORDER BY num_courses DESC;", "question": "How many courses does each department offer?", "instructions": "", "generated_query": "SELECT department,\n       COUNT(*) AS num_courses\nFROM course\nGROUP BY department;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.528934955596924, "tokens_used": 2204, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27214}, {"db_name": "advising", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT i.name, AVG(c.clarity_score) FROM course AS c JOIN course_offering AS co ON c.course_id = co.course_id JOIN offering_instructor AS oi ON co.offering_id = oi.offering_id JOIN instructor AS i ON oi.instructor_id = i.instructor_id GROUP BY i.name;SELECT i.instructor_id, AVG(c.clarity_score) FROM course AS c JOIN course_offering AS co ON c.course_id = co.course_id JOIN offering_instructor AS oi ON co.offering_id = oi.offering_id JOIN instructor AS i ON oi.instructor_id = i.instructor_id GROUP BY i.instructor_id;SELECT i.name, i.instructor_id, AVG(c.clarity_score) FROM course AS c JOIN course_offering AS co ON c.course_id = co.course_id JOIN offering_instructor AS oi ON co.offering_id = oi.offering_id JOIN instructor AS i ON oi.instructor_id = i.instructor_id GROUP BY i.name, i.instructor_id;", "question": "What is the average clarity score for each instructor who taught a course?", "instructions": "", "generated_query": "SELECT i.instructor_id,\n       i.name,\n       AVG(c.clarity_score) AS avg_clarity_score\nFROM instructor i\nJOIN offering_instructor oi ON i.instructor_id = oi.instructor_id\nJOIN course_offering co ON oi.offering_id = co.offering_id\nJOIN course c ON co.course_id = c.course_id\nGROUP BY i.instructor_id,\n         i.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.6365652084350586, "tokens_used": 2469, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.38676000000000005}, {"db_name": "advising", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT course_tags_count.course_id, SUM(course_tags_count.hilarious) AS total_hilarious FROM course_tags_count GROUP BY course_tags_count.course_id;", "question": "What is the total number of students who found the instructor to be hilarious per course id?", "instructions": "", "generated_query": "SELECT course_id,\n       SUM(hilarious) AS total_hilarious\nFROM course_tags_count\nGROUP BY course_id;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.644670009613037, "tokens_used": 2479, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.38984}, {"db_name": "advising", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT student_id FROM student_record WHERE student_record.how = 'in-person' AND student_record.grade IN ('A', 'C');", "question": "Return the student IDs who have taken an in-person course and have gotten a grade of A or C.", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter strings with an exact match.\nWhen asked for specific students or courses, do not return duplicates.\n", "generated_query": "SELECT DISTINCT student_id\nFROM student_record\nWHERE how = 'in-person'\n  AND (grade = 'A'\n       OR grade = 'C');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.71199107170105, "tokens_used": 2388, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.33891000000000004}, {"db_name": "advising", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT course.name, course.easiness_score FROM course WHERE course.department = 'Computer Science';SELECT course.course_id, course.easiness_score FROM course WHERE course.department = 'Computer Science';SELECT course.number, course.easiness_score FROM course WHERE course.department = 'Computer Science';SELECT course.name, course.course_id, course.easiness_score FROM course WHERE course.department = 'Computer Science';SELECT course.name, course.number, course.easiness_score FROM course WHERE course.department = 'Computer Science';SELECT course.course_id, course.number, course.easiness_score FROM course WHERE course.department = 'Computer Science';SELECT course.name, course.course_id, course.number, course.easiness_score FROM course WHERE course.department = 'Computer Science';", "question": "What are the easiness scores for courses in the \"Computer Science\" department? Show both courses and scores.", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using exact string matching\n", "generated_query": "SELECT name,\n       easiness_score\nFROM course\nWHERE department = 'Computer Science';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.9958839416503906, "tokens_used": 2428, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.36046999999999996}, {"db_name": "advising", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT course.name FROM course WHERE LOWER(course.department) LIKE LOWER('%Computer Science%') ORDER BY course.name ASC NULLS LAST;", "question": "What are the names of all the courses offered by the department of Computer Science?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings using LIKE.\nUse the student_record table for all information relating to students' choices and their course.\n", "generated_query": "SELECT DISTINCT course.name\nFROM student_record\nJOIN course ON student_record.course_id = course.course_id\nWHERE course.department LIKE '%Computer Science%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.7760376930236816, "tokens_used": 2705, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.47971}, {"db_name": "advising", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT AVG(student.total_gpa) FROM student JOIN program ON student.program_id = program.program_id WHERE LOWER(program.name) = 'mathematics';", "question": "What is the average GPA of students in the program mathematics?", "instructions": "\nFollow the instructions below to generate the query:\nMatch strings case-insensitively\n", "generated_query": "SELECT AVG(student.total_gpa) AS average_gpa\nFROM student\nJOIN program ON student.program_id = program.program_id\nWHERE LOWER(program.name) = 'mathematics';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.9339053630828857, "tokens_used": 2374, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34001}, {"db_name": "advising", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT student.firstname, student.lastname FROM student WHERE NOT student.minor IS NULL ORDER BY student.lastname NULLS LAST;", "question": "Which students have declared a minor program? List their firstname and lastname. Order the results by the students' last names.", "instructions": "\nFollow the instructions below to generate the query:\nstudent.declare_major is null for students who have not declared their major.\nstudent.minor is null for students who have not declared a minor program.\n", "generated_query": "SELECT firstname,\n       lastname\nFROM student\nWHERE minor IS NOT NULL\nORDER BY lastname;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.829996585845947, "tokens_used": 2327, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.30811000000000005}, {"db_name": "advising", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT instructor.name, COUNT(offering_instructor.offering_id) AS num_courses FROM offering_instructor JOIN instructor ON offering_instructor.instructor_id = instructor.instructor_id GROUP BY instructor.name ORDER BY num_courses DESC NULLS FIRST LIMIT 1;", "question": "What is the name of the instructor who has taught the most courses, and how many courses have they taught?", "instructions": "", "generated_query": "SELECT i.name,\n       COUNT(oi.offering_id) AS courses_taught\nFROM offering_instructor AS oi\nJOIN instructor AS i ON oi.instructor_id = i.instructor_id\nGROUP BY i.instructor_id\nORDER BY courses_taught DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.6525774002075195, "tokens_used": 2898, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5728800000000001}, {"db_name": "advising", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT student.student_id, student.total_credit FROM student ORDER BY student.total_credit DESC;", "question": "What is the total number of credits earned by each student, ordered from highest to lowest? Give the student id and the total number of credits.", "instructions": "", "generated_query": "SELECT student_id,\n       total_credit\nFROM student\nORDER BY total_credit DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.9600563049316406, "tokens_used": 2481, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.38709}, {"db_name": "advising", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT course.course_id, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.course_id ORDER BY total_students DESC;SELECT course.name, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.name ORDER BY total_students DESC;SELECT course.number, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.number ORDER BY total_students DESC;SELECT course.course_id, course.name, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.course_id, course.name ORDER BY total_students DESC;SELECT course.course_id, course.number, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.course_id, course.number ORDER BY total_students DESC;SELECT course.name, course.number, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.name, course.number ORDER BY total_students DESC;SELECT course.course_id, course.name, course.number, SUM(course.num_enrolled) AS total_students FROM course GROUP BY course.course_id, course.name, course.number ORDER BY total_students DESC;", "question": "What is the total number of students enrolled in each course, ordered from highest to lowest?", "instructions": "", "generated_query": "SELECT name,\n       num_enrolled\nFROM course\nORDER BY num_enrolled DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.239297151565552, "tokens_used": 2599, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44264000000000003}, {"db_name": "advising", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT course_tags_count.course_id, course_tags_count.participation FROM course_tags_count ORDER BY course_tags_count.participation DESC;", "question": "What is the total number of students who participated actively for each course id, ordered from highest to lowest participants?", "instructions": "", "generated_query": "SELECT course_id,\n       participation AS active_students\nFROM course_tags_count\nORDER BY participation DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.628276586532593, "tokens_used": 2605, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44396}, {"db_name": "advising", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT course.name, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;SELECT course.course_id, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;SELECT course.number, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;SELECT course.name, course.course_id, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;SELECT course.name, course.number, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;SELECT course.course_id, course.number, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;SELECT course.name, course.course_id, course.number, course.num_enrolled FROM course ORDER BY course.num_enrolled DESC LIMIT 1;", "question": "Which course has the highest number of enrolled students, and what is the enrollment number?", "instructions": "", "generated_query": "SELECT name,\n       num_enrolled\nFROM course\nORDER BY num_enrolled DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.2281856536865234, "tokens_used": 2282, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.30349000000000004}, {"db_name": "advising", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT course.course_id, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;SELECT course.name, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;SELECT course.number, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;SELECT course.course_id, course.name, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;SELECT course.course_id, course.number, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;SELECT course.name, course.number, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;SELECT course.course_id, course.name, course.number, CAST(course.num_enrolled AS REAL) / NULLIF(course.num_reviews, 0) AS student_review_ratio FROM course ORDER BY student_review_ratio NULLS LAST;", "question": "How does the ratio of enrolled students to the number of reviews vary across different courses?", "instructions": "", "generated_query": "SELECT course_id,\n       name,\n       num_enrolled,\n       num_reviews,\n       CASE\n           WHEN num_reviews = 0 THEN NULL\n           ELSE CAST(num_enrolled AS FLOAT) / num_reviews\n       END AS enrollment_to_reviews_ratio\nFROM course;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.5196266174316406, "tokens_used": 2444, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.37477000000000005}, {"db_name": "advising", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT course.course_id, CAST(course.helpfulness_score AS REAL) / NULLIF(course.clarity_score, 0) AS ratio FROM course;", "question": "What is the ratio of helpfulness scores to clarity scores for each course ID?", "instructions": "", "generated_query": "SELECT course_id,\n       (helpfulness_score * 1.0 / clarity_score) AS ratio\nFROM course;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.7522873878479004, "tokens_used": 2476, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.38917999999999997}, {"db_name": "advising", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT course_offering.semester, CAST(SUM(CASE WHEN course.has_projects THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN course.has_exams THEN 1 ELSE 0 END), 0) AS ratio FROM course JOIN course_offering ON course.course_id = course_offering.course_id GROUP BY course_offering.semester ORDER BY course_offering.semester NULLS LAST;", "question": "What is the ratio of the number of courses with projects to the number of courses with exams in each semester id?", "instructions": "", "generated_query": "SELECT semester AS semester_id,\n       CASE\n           WHEN SUM(CASE\n                        WHEN has_final_exam = 1 THEN 1\n                        ELSE 0\n                    END) = 0 THEN NULL\n           ELSE 1.0 * SUM(CASE\n                              WHEN has_final_project = 1 THEN 1\n                              ELSE 0\n                          END) / SUM(CASE\n                                         WHEN has_final_exam = 1 THEN 1\n                                         ELSE 0\n                                     END)\n       END AS ratio\nFROM course_offering\nGROUP BY semester;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.065226316452026, "tokens_used": 2938, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5901500000000001}, {"db_name": "advising", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT course_tags_count.course_id, CAST(course_tags_count.clear_grading AS REAL) / NULLIF(course_tags_count.good_feedback, 0) AS ratio FROM course_tags_count ORDER BY course_tags_count.course_id NULLS LAST;", "question": "What is the ratio of the number of students who found the grading criteria clear and easy to understand to the number of students who received good feedback from the instructor for each course id?", "instructions": "", "generated_query": "SELECT course_id,\n       CASE\n           WHEN good_feedback = 0 THEN NULL\n           ELSE CAST(clear_grading AS REAL) / good_feedback\n       END AS ratio\nFROM course_tags_count;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.1919846534729, "tokens_used": 2386, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34298}, {"db_name": "advising", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(SUM(CASE WHEN c.has_exams THEN c.num_enrolled ELSE 0 END) AS REAL) / SUM(CASE WHEN NOT c.has_exams THEN c.num_enrolled ELSE 0 END) AS ratio FROM course AS c;", "question": "What is the ratio of the total number of students enrolled in courses with exams to the total number of students enrolled in courses without exams?", "instructions": "", "generated_query": "SELECT (SUM(CASE\n                WHEN has_exams = 1 THEN num_enrolled\n                ELSE 0\n            END) * 1.0) / NULLIF(SUM(CASE\n                                         WHEN has_exams = 0 THEN num_enrolled\n                                         ELSE 0\n                                     END), 0) AS exam_to_noexam_ratio\nFROM course;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.398289442062378, "tokens_used": 2656, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.46475000000000005}, {"db_name": "advising", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT program.name, COUNT(student.student_id) AS number_of_students FROM student JOIN program ON student.program_id = program.program_id WHERE NOT student.declare_major IS NULL GROUP BY program.name ORDER BY number_of_students DESC NULLS FIRST;SELECT program.program_id, COUNT(student.student_id) AS number_of_students FROM student JOIN program ON student.program_id = program.program_id WHERE NOT student.declare_major IS NULL GROUP BY program.program_id ORDER BY number_of_students DESC NULLS FIRST;SELECT program.name, program.program_id, COUNT(student.student_id) AS number_of_students FROM student JOIN program ON student.program_id = program.program_id WHERE NOT student.declare_major IS NULL GROUP BY program.name, program.program_id ORDER BY number_of_students DESC NULLS FIRST;", "question": "How many students have declared a major in each program?", "instructions": "", "generated_query": "SELECT p.name AS program,\n       COUNT(s.student_id) AS declared_major_count\nFROM program p\nLEFT JOIN student s ON s.declare_major = p.name\nGROUP BY p.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 8.182599306106567, "tokens_used": 2678, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.47971}, {"db_name": "advising", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT program.name, SUM(student.total_credit) AS total_credits FROM student JOIN program ON student.program_id = program.program_id GROUP BY program.name;SELECT program.program_id, SUM(student.total_credit) AS total_credits FROM student JOIN program ON student.program_id = program.program_id GROUP BY program.program_id;SELECT program.name, program.program_id, SUM(student.total_credit) AS total_credits FROM student JOIN program ON student.program_id = program.program_id GROUP BY program.name, program.program_id;", "question": "What is the total number of credits earned by students in each program?", "instructions": "", "generated_query": "SELECT p.name AS program_name,\n       SUM(s.total_credit) AS total_credits\nFROM student s\nJOIN program p ON s.program_id = p.program_id\nGROUP BY p.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.2112414836883545, "tokens_used": 2425, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.3674}, {"db_name": "advising", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT COUNT(DISTINCT student_record.student_id) AS total_students FROM student_record JOIN course_offering ON student_record.course_id = course_offering.course_id WHERE course_offering.has_final_project = TRUE OR course_offering.has_final_exam = TRUE;", "question": "What is the total number of students who have taken a course with a final project or exam?", "instructions": "", "generated_query": "SELECT COUNT(DISTINCT sr.student_id)\nFROM student_record AS sr\nJOIN course_offering AS co ON sr.offering_id = co.offering_id\nWHERE co.has_final_project = 1\n  OR co.has_final_exam = 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.390852928161621, "tokens_used": 2504, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.40051000000000003}, {"db_name": "advising", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT DISTINCT course.name FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;SELECT DISTINCT course.course_id FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;SELECT DISTINCT course.number FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;SELECT DISTINCT course.name, course.course_id FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;SELECT DISTINCT course.name, course.number FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;SELECT DISTINCT course.course_id, course.number FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;SELECT DISTINCT course.name, course.course_id, course.number FROM course_offering JOIN course ON course_offering.course_id = course.course_id WHERE course_offering.has_final_project = TRUE AND course_offering.has_final_exam = TRUE;", "question": "Which courses have a final project and a final exam?", "instructions": "", "generated_query": "SELECT DISTINCT c.name\nFROM course AS c\nJOIN course_offering AS o ON c.course_id = o.course_id\nWHERE o.has_final_project = 1\n  AND o.has_final_exam = 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.5508034229278564, "tokens_used": 2427, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.36927}, {"db_name": "advising", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT DISTINCT course.name AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');SELECT DISTINCT course.course_id AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');SELECT DISTINCT course.number AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');SELECT DISTINCT course.name, course.course_id AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');SELECT DISTINCT course.name, course.number AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');SELECT DISTINCT course.course_id, course.number AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');SELECT DISTINCT course.name, course.course_id, course.number AS course_name FROM student JOIN student_record ON student.student_id = student_record.student_id JOIN program ON student.program_id = program.program_id JOIN course ON student_record.course_id = course.course_id WHERE LOWER(program.name) LIKE LOWER('%Computer Science%');", "question": "Which courses have been taken by students in the Computer Science program?", "instructions": "", "generated_query": "SELECT DISTINCT c.course_id,\n                c.name\nFROM course AS c\nJOIN student_record AS sr ON c.course_id = sr.course_id\nJOIN student AS s ON sr.student_id = s.student_id\nJOIN program AS p ON s.program_id = p.program_id\nWHERE p.name = 'Computer Science';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.229011058807373, "tokens_used": 2575, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- area AS a\n-- course AS c\n-- program AS p\n-- student AS s\n-- semester AS se\n-- instructor AS i\n-- program_course AS pc\n-- student_record AS sr\n-- course_offering AS co\n-- course_tags_count AS ctc\n-- comment_instructor AS ci\n-- course_prerequisite AS cp\n-- offering_instructor AS oi\n-- program_requirement AS pr\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43373000000000006}, {"db_name": "atis", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT month.month_name, COUNT(*) AS departure_count FROM flight JOIN month ON CAST(strftime('%m', datetime(flight.departure_time, 'unixepoch')) AS INTEGER) = month.month_number GROUP BY month.month_name ORDER BY month.month_number;SELECT strftime('%m', datetime(flight.departure_time, 'unixepoch')) AS month, COUNT(*) AS num_departures FROM flight GROUP BY month ORDER BY month;SELECT strftime('%Y-%m', datetime(flight.departure_time, 'unixepoch')) AS month, COUNT(*) AS num_departures FROM flight GROUP BY month ORDER BY month;SELECT strftime('%Y-%m-01', datetime(flight.departure_time, 'unixepoch')) AS month, COUNT(*) AS num_departures FROM flight GROUP BY month ORDER BY month;", "question": "Count the number of flight departures for each month?", "instructions": "", "generated_query": "SELECT m.month_name,\n       COUNT(*) AS departure_count\nFROM flight f\nJOIN MONTH m ON m.month_number = CAST(strftime('%m', datetime(f.departure_time, 'unixepoch')) AS INTEGER)\nGROUP BY m.month_number\nORDER BY m.month_number;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.84132981300354, "tokens_used": 3388, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5010500000000001}, {"db_name": "atis", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT CAST(julianday('now') - julianday(datetime(departure_time, 'unixepoch')) AS INTEGER) AS difference_in_days FROM flight ORDER BY departure_time ASC LIMIT 1;SELECT CAST((julianday('now') - julianday(datetime(MIN(f.departure_time), 'unixepoch'))) AS INTEGER) AS days_difference FROM flight AS f;", "question": "What's the absolute difference in time in days between today and the earliest flight departure? Give the answer as an integer.", "instructions": "", "generated_query": "SELECT CAST(ABS(julianday('now') - julianday(datetime(MIN(departure_time), 'unixepoch'))) AS INTEGER) AS diff_in_days\nFROM flight;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.146182298660278, "tokens_used": 3378, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.49236}, {"db_name": "atis", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT AVG((strftime('%s', datetime(arrival_time, 'unixepoch')) - strftime('%s', datetime(departure_time, 'unixepoch')) - (34 * 60)) / 60.0) AS average_duration FROM flight;SELECT AVG(arrival_time - departure_time) / 60 - 34 AS average_duration FROM flight;", "question": "What's the average duration between departure and arrival times minus 34 minutes? Convert from UNIX to regular datetime, and return the answer in minutes", "instructions": "", "generated_query": "SELECT AVG(((julianday(datetime(arrival_time, 'unixepoch')) - julianday(datetime(departure_time, 'unixepoch'))) * 24 * 60) - 34) AS average_duration\nFROM flight;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.528162717819214, "tokens_used": 3776, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.66616}, {"db_name": "atis", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT STRFTIME('%H:%M', datetime(departure_time, 'unixepoch')) AS earliest_departure_time FROM flight ORDER BY departure_time ASC LIMIT 1;", "question": "What's the earliest flight departure time in the day in HH:MM?", "instructions": "", "generated_query": "SELECT strftime('%H:%M', MIN(departure_time), 'unixepoch') AS earliest_departure\nFROM flight;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.336324214935303, "tokens_used": 3615, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5996100000000001}, {"db_name": "atis", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT flight.flight_number, (arrival_time - departure_time) / 60 AS duration_minutes FROM flight ORDER BY duration_minutes NULLS LAST LIMIT 1;SELECT flight.flight_id, (arrival_time - departure_time) / 60 AS duration_minutes FROM flight ORDER BY duration_minutes NULLS LAST LIMIT 1;SELECT flight.flight_number, flight.flight_id, (arrival_time - departure_time) / 60 AS duration_minutes FROM flight ORDER BY duration_minutes NULLS LAST LIMIT 1;", "question": "Which flight has the shortest duration between departure and arrival times? Convert to integer minutes.", "instructions": "", "generated_query": "SELECT flight_id,\n       flight_number,\n       CAST((arrival_time - departure_time) / 60 AS INTEGER) AS duration_minutes\nFROM flight\nORDER BY duration_minutes ASC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.192757844924927, "tokens_used": 3508, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.55154}, {"db_name": "atis", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT airport.airport_code, COUNT(flight.from_airport) AS num_departures FROM airport LEFT JOIN flight ON airport.airport_code = flight.from_airport AND flight.connections = 0 GROUP BY airport.airport_code;SELECT airport.airport_code, COUNT(flight.from_airport) AS num_departures FROM airport JOIN flight ON airport.airport_code = flight.from_airport WHERE flight.connections = 0 GROUP BY airport.airport_code;", "question": "How many flights depart from each airport code, excluding departures with connections?", "instructions": "", "generated_query": "SELECT from_airport,\n       COUNT(*) AS flight_count\nFROM flight\nWHERE connections = 0\nGROUP BY from_airport;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.851694822311401, "tokens_used": 3296, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.45925000000000005}, {"db_name": "atis", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT food_service.compartment, COUNT(food_service.meal_number) AS number_of_meals FROM food_service GROUP BY food_service.compartment ORDER BY number_of_meals DESC;", "question": "How many meals are served in each compartment, sorted by the number of meals in descending order?", "instructions": "", "generated_query": "SELECT compartment,\n       COUNT(*) AS meal_count\nFROM food_service\nGROUP BY compartment\nORDER BY meal_count DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.519317388534546, "tokens_used": 3105, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.37356000000000006}, {"db_name": "atis", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT f.from_airport, f.to_airport, AVG(f.one_direction_cost) AS average_cost FROM fare AS f GROUP BY f.from_airport, f.to_airport ORDER BY f.from_airport NULLS LAST, f.to_airport NULLS LAST;", "question": "What is the average cost of a one-way trip for each airport pair in the fare table?", "instructions": "", "generated_query": "SELECT from_airport,\n       to_airport,\n       AVG(one_direction_cost) AS avg_one_way_cost\nFROM fare\nGROUP BY from_airport,\n         to_airport;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.953955888748169, "tokens_used": 3185, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.40876}, {"db_name": "atis", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT fare.fare_airline, AVG(fare.round_trip_cost) AS average_cost FROM fare WHERE fare.from_airport = 'LAX' AND fare.to_airport = 'ORD' GROUP BY fare.fare_airline ORDER BY average_cost DESC;SELECT airline.airline_name, AVG(fare.round_trip_cost) AS avg_round_trip_cost FROM fare JOIN airline ON fare.fare_airline = airline.airline_code WHERE fare.from_airport = 'LAX' AND fare.to_airport = 'ORD' GROUP BY airline.airline_name ORDER BY avg_round_trip_cost DESC NULLS FIRST;", "question": "What is the average cost of round-trip fares from Los Angeles (LAX) to Chicago (ORD) for each airline, sorted in descending order by average cost?", "instructions": "", "generated_query": "SELECT airline.airline_name,\n       AVG(fare.round_trip_cost) AS average_round_trip_cost\nFROM fare\nJOIN airline ON fare.fare_airline = airline.airline_code\nWHERE fare.from_airport = 'LAX'\n  AND fare.to_airport = 'ORD'\nGROUP BY airline.airline_name\nORDER BY average_round_trip_cost DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.7645978927612305, "tokens_used": 3682, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.6228199999999999}, {"db_name": "atis", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT fare.fare_airline, SUM(fare.round_trip_cost) AS total_round_trip_cost FROM fare GROUP BY fare.fare_airline ORDER BY total_round_trip_cost DESC NULLS FIRST;", "question": "What is the total cost of round-trip fares for each airline code?", "instructions": "", "generated_query": "SELECT fare_airline AS airline_code,\n       SUM(round_trip_cost) AS total_round_trip_cost\nFROM fare\nGROUP BY fare_airline;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.300685405731201, "tokens_used": 3233, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43153}, {"db_name": "atis", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT COUNT(DISTINCT flight_fare.flight_id) FROM flight_fare JOIN fare ON flight_fare.fare_id = fare.fare_id WHERE fare.round_trip_required = 'Yes';", "question": "How many flights require a round-trip to purchase the fare?", "instructions": "\nFollow the instructions below to generate the query:\nFilter airport, city, country names using LIKE.\nFilter state code (eg NY) and airport codes (eg JFK) using upper-case matches.\n", "generated_query": "SELECT COUNT(DISTINCT flight.flight_id) AS count_of_flights\nFROM flight\nJOIN flight_fare ON flight.flight_id = flight_fare.flight_id\nJOIN fare ON flight_fare.fare_id = fare.fare_id\nWHERE fare.round_trip_required = 'Yes';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.644406080245972, "tokens_used": 3554, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.56089}, {"db_name": "atis", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT minimum_connect_time FROM airport WHERE airport_code = 'JFK';", "question": "What is the minimum amount of time required for a connecting flight at JFK Airport?", "instructions": "\nFollow the instructions below to generate the query:\nFilter airport, city, country names using LIKE.\nFilter state code (eg NY) and airport codes (eg JFK) using upper-case matches.\n", "generated_query": "SELECT minimum_connect_time\nFROM airport\nWHERE airport_code = 'JFK';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.400989055633545, "tokens_used": 3773, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.65593}, {"db_name": "atis", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT SUM(fare.round_trip_cost) AS total_round_trip_cost FROM fare WHERE fare.from_airport = 'JFK' AND fare.to_airport = 'LAX';", "question": "What is the total cost of all round-trip fares from New York (JFK) to Los Angeles?", "instructions": "\nFollow the instructions below to generate the query:\nFilter airport, city, country names using LIKE.\nFilter state code (eg NY), airport codes (eg JFK) using case-insensitive matches.\nfare.round_trip_required is not needed when getting the round trip cost.\n", "generated_query": "SELECT SUM(f.round_trip_cost) AS total_cost\nFROM fare AS f\nJOIN airport AS dep ON f.from_airport = dep.airport_code\nJOIN airport AS arr ON f.to_airport = arr.airport_code\nWHERE dep.airport_code LIKE 'JFK' COLLATE NOCASE\n  AND arr.airport_location LIKE '%Los Angeles%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 11.89480996131897, "tokens_used": 4809, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 1.1055000000000001}, {"db_name": "atis", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT flight.flight_number FROM flight WHERE LOWER(flight.flight_days) LIKE '%mon%' AND LOWER(flight.flight_days) LIKE '%wed%';SELECT flight.flight_id FROM flight WHERE LOWER(flight.flight_days) LIKE '%mon%' AND LOWER(flight.flight_days) LIKE '%wed%';SELECT flight.flight_number, flight.flight_id FROM flight WHERE LOWER(flight.flight_days) LIKE '%mon%' AND LOWER(flight.flight_days) LIKE '%wed%';", "question": "Which flights operate on Mondays and Wednesdays? Give me the relevant flight numbers", "instructions": "\nFollow the instructions below to generate the query:\nFilter airport, city, country names using LIKE.\nFilter state code (eg NY), airport codes (eg JFK) using case-insensitive matches.\nIf multiple flight days are requested, use LIKE for each of the days separately, since they are not necessarily ordered.\n", "generated_query": "SELECT flight_number\nFROM flight\nWHERE flight_days LIKE '%mon%'\n  AND flight_days LIKE '%wed%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.0976264476776123, "tokens_used": 3289, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.43604000000000004}, {"db_name": "atis", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT state_code FROM airport WHERE LOWER(airport_name) LIKE LOWER('%Orlando International Airport%');", "question": "Which state code is Orlando International Airport in?", "instructions": "\nFollow the instructions below to generate the query:\nFilter airport, city, country names using LIKE.\nFilter state code (eg NY), airport codes (eg JFK) using case-insensitive matches.\nIf multiple flight days are requested, use LIKE and wildcards for each of the days separately, since they are not necessarily ordered.\n", "generated_query": "SELECT state_code\nFROM airport\nWHERE airport_name LIKE '%Orlando International Airport%' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.090195655822754, "tokens_used": 3541, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.54758}, {"db_name": "atis", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT aircraft.aircraft_code FROM aircraft WHERE aircraft.cruising_speed > 200 ORDER BY aircraft.aircraft_code ASC NULLS LAST;", "question": "What are the aircraft codes for all aircraft with a cruising speed of over 200 mph? sort the aircraft codes in ascending order.", "instructions": "", "generated_query": "SELECT aircraft_code\nFROM aircraft\nWHERE cruising_speed > 200\nORDER BY aircraft_code ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.2260825634002686, "tokens_used": 3173, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.4011700000000001}, {"db_name": "atis", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT airline.airline_name, COUNT(flight.flight_id) AS number_of_flights FROM flight JOIN airline ON flight.airline_code = airline.airline_code GROUP BY airline.airline_name ORDER BY number_of_flights DESC LIMIT 2;SELECT airline.airline_code, COUNT(flight.flight_id) AS number_of_flights FROM flight JOIN airline ON flight.airline_code = airline.airline_code GROUP BY airline.airline_code ORDER BY number_of_flights DESC LIMIT 2;SELECT airline.airline_name, airline.airline_code, COUNT(flight.flight_id) AS number_of_flights FROM flight JOIN airline ON flight.airline_code = airline.airline_code GROUP BY airline.airline_name, airline.airline_code ORDER BY number_of_flights DESC LIMIT 2;", "question": "What are the top 2 airlines with the most flights?", "instructions": "", "generated_query": "SELECT airline.airline_name,\n       COUNT(flight.flight_id) AS flight_count\nFROM flight\nJOIN airline ON flight.airline_code = airline.airline_code\nGROUP BY airline.airline_code,\n         airline.airline_name\nORDER BY flight_count DESC\nLIMIT 2;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.3608438968658447, "tokens_used": 3257, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44275}, {"db_name": "atis", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT aircraft.aircraft_code FROM aircraft ORDER BY pay_load DESC LIMIT 1;", "question": "Which aircraft code can carry the highest weight of cargo that any aircraft can carry?", "instructions": "", "generated_query": "SELECT aircraft_code\nFROM aircraft\nWHERE pay_load =\n    (SELECT MAX(pay_load)\n     FROM aircraft);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.5060007572174072, "tokens_used": 3291, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.45639}, {"db_name": "atis", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT airport.airport_name, airport.minimum_connect_time FROM airport ORDER BY airport.minimum_connect_time ASC NULLS LAST;SELECT airport.airport_code, airport.minimum_connect_time FROM airport ORDER BY airport.minimum_connect_time ASC NULLS LAST;SELECT airport.airport_name, airport.airport_code, airport.minimum_connect_time FROM airport ORDER BY airport.minimum_connect_time ASC NULLS LAST;", "question": "Which airports have the shortest minimum connect time, sorted in ascending order? Show the minimum connect time.", "instructions": "", "generated_query": "SELECT airport_name,\n       minimum_connect_time\nFROM airport\nORDER BY minimum_connect_time ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.1567492485046387, "tokens_used": 3165, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.39963000000000004}, {"db_name": "atis", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT flight.flight_id, (flight.arrival_time - flight.departure_time) AS duration FROM flight WHERE to_airport = 'ORD' ORDER BY duration ASC NULLS LAST;", "question": "Which flight ids to Chicago (ORD) have the longest duration from departure to arrival, sorted in ascending order?", "instructions": "", "generated_query": "SELECT flight_id\nFROM flight\nWHERE to_airport = 'ORD'\n  AND time_elapsed =\n    (SELECT MAX(time_elapsed)\n     FROM flight\n     WHERE to_airport = 'ORD')\nORDER BY flight_id ASC;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.357676267623901, "tokens_used": 3773, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.6664900000000001}, {"db_name": "atis", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(aircraft.range_miles AS REAL) / NULLIF(aircraft.pay_load, 0) AS range_to_payload_ratio FROM aircraft;", "question": "Calculate the ratio of the maximum range to the maximum payload for each aircraft", "instructions": "", "generated_query": "SELECT aircraft_code,\n       (range_miles * 1.0) / pay_load AS range_to_payload_ratio\nFROM aircraft;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.55269455909729, "tokens_used": 3426, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.5164500000000001}, {"db_name": "atis", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT aircraft.manufacturer, AVG(CAST(aircraft.cruising_speed AS REAL) / NULLIF(aircraft.pay_load, 0)) AS speed_payload_ratio FROM aircraft GROUP BY aircraft.manufacturer ORDER BY speed_payload_ratio DESC;", "question": "How does the average ratio of the cruising speed to the payload of an aircraft vary across different aircraft manufacturers?", "instructions": "", "generated_query": "SELECT manufacturer,\n       AVG(cruising_speed * 1.0 / pay_load) AS avg_ratio\nFROM aircraft\nGROUP BY manufacturer;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.385521411895752, "tokens_used": 3184, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.40765999999999997}, {"db_name": "atis", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT flight.airline_code, CAST(SUM(CASE WHEN flight.stops > 0 THEN 1 ELSE 0 END) AS REAL) / NULLIF(COUNT(*), 0) AS ratio FROM flight GROUP BY flight.airline_code;", "question": "What is the proportion of flights with stops out of all flights for each airline code?", "instructions": "", "generated_query": "SELECT airline_code,\n       1.0 * SUM(CASE\n                     WHEN stops > 0 THEN 1\n                     ELSE 0\n                 END) / COUNT(*) AS proportion\nFROM flight\nGROUP BY airline_code;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.242734909057617, "tokens_used": 3378, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.49433999999999995}, {"db_name": "atis", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT aircraft.aircraft_code, CAST(aircraft.capacity AS REAL) / NULLIF(aircraft.range_miles, 0) AS capacity_range_ratio FROM aircraft;", "question": "What is the ratio of aircraft capacity to its range in miles for each aircraft code?", "instructions": "", "generated_query": "SELECT aircraft_code,\n       capacity * 1.0 / range_miles AS ratio\nFROM aircraft;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.220278263092041, "tokens_used": 3164, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.40018}, {"db_name": "atis", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT fare.fare_id, CAST(fare.one_direction_cost AS REAL) / NULLIF(fare.round_trip_cost, 0) AS cost_ratio FROM fare ORDER BY cost_ratio NULLS LAST;", "question": "What is the ratio of one-way trip costs to round-trip costs for each fare?", "instructions": "", "generated_query": "SELECT fare_id,\n       one_direction_cost,\n       round_trip_cost,\n       one_direction_cost * 1.0 / round_trip_cost AS ratio\nFROM fare;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.2694385051727295, "tokens_used": 3374, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.49258}, {"db_name": "atis", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT DISTINCT airline.airline_name FROM airline WHERE NOT airline.airline_code IN (SELECT flight.airline_code FROM flight WHERE flight.from_airport = 'JFK' OR flight.to_airport = 'JFK' OR flight.stops > 0);SELECT DISTINCT airline.airline_code FROM airline WHERE NOT airline.airline_code IN (SELECT flight.airline_code FROM flight WHERE flight.from_airport = 'JFK' OR flight.to_airport = 'JFK' OR flight.stops > 0);SELECT DISTINCT airline.airline_name, airline.airline_code FROM airline WHERE NOT airline.airline_code IN (SELECT flight.airline_code FROM flight WHERE flight.from_airport = 'JFK' OR flight.to_airport = 'JFK' OR flight.stops > 0);", "question": "Which airlines do not have any flights that either depart from/arrive at JFK, or have one or more stops?", "instructions": "", "generated_query": "SELECT airline.airline_code,\n       airline.airline_name\nFROM airline\nWHERE airline.airline_code NOT IN\n    (SELECT flight.airline_code\n     FROM flight\n     WHERE (flight.from_airport = 'JFK'\n            OR flight.to_airport = 'JFK'\n            OR flight.stops > 0));", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.303659200668335, "tokens_used": 3666, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.61875}, {"db_name": "atis", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT airline.airline_name, flight.stops FROM flight JOIN airline ON flight.airline_code = airline.airline_code WHERE flight.from_airport = 'ORD' AND flight.to_airport = 'JFK' ORDER BY flight.stops NULLS LAST;SELECT airline.airline_code, flight.stops FROM flight JOIN airline ON flight.airline_code = airline.airline_code WHERE flight.from_airport = 'ORD' AND flight.to_airport = 'JFK' ORDER BY flight.stops NULLS LAST;SELECT airline.airline_name, airline.airline_code, flight.stops FROM flight JOIN airline ON flight.airline_code = airline.airline_code WHERE flight.from_airport = 'ORD' AND flight.to_airport = 'JFK' ORDER BY flight.stops NULLS LAST;", "question": "Which airlines offer flights from Chicago (ORD) to New York (JFK), and how many stops do they have, sorted by number of stops in ascending order?", "instructions": "", "generated_query": "SELECT DISTINCT airline.airline_name,\n                flight.stops\nFROM flight\nJOIN airline ON flight.airline_code = airline.airline_code\nWHERE flight.from_airport = 'ORD'\n  AND flight.to_airport = 'JFK'\nORDER BY flight.stops ASC;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.003920793533325, "tokens_used": 3470, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.52954}, {"db_name": "atis", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT DISTINCT airline.airline_name FROM flight JOIN airline ON flight.airline_code = airline.airline_code WHERE flight.from_airport = 'LAX' AND flight.to_airport = 'ORD';SELECT DISTINCT airline.airline_code FROM flight JOIN airline ON flight.airline_code = airline.airline_code WHERE flight.from_airport = 'LAX' AND flight.to_airport = 'ORD';SELECT DISTINCT airline.airline_name, airline.airline_code FROM flight JOIN airline ON flight.airline_code = airline.airline_code WHERE flight.from_airport = 'LAX' AND flight.to_airport = 'ORD';", "question": "Which airlines offer flights from LAX to ORD?", "instructions": "", "generated_query": "SELECT DISTINCT airline.airline_name\nFROM flight\nJOIN airline ON flight.airline_code = airline.airline_code\nWHERE flight.from_airport = 'LAX'\n  AND flight.to_airport = 'ORD';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.106908082962036, "tokens_used": 3308, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.46585000000000004}, {"db_name": "atis", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT DISTINCT airline.airline_name FROM flight_stop JOIN airport ON flight_stop.stop_airport = airport.airport_code JOIN flight ON flight_stop.flight_id = flight.flight_id JOIN airline ON flight.airline_code = airline.airline_code WHERE LOWER(airport.airport_location) LIKE LOWER('%Dallas%');SELECT DISTINCT airline.airline_code FROM flight_stop JOIN airport ON flight_stop.stop_airport = airport.airport_code JOIN flight ON flight_stop.flight_id = flight.flight_id JOIN airline ON flight.airline_code = airline.airline_code WHERE LOWER(airport.airport_location) LIKE LOWER('%Dallas%');SELECT DISTINCT airline.airline_name, airline.airline_code FROM flight_stop JOIN airport ON flight_stop.stop_airport = airport.airport_code JOIN flight ON flight_stop.flight_id = flight.flight_id JOIN airline ON flight.airline_code = airline.airline_code WHERE LOWER(airport.airport_location) LIKE LOWER('%Dallas%');", "question": "Which airlines offer flights with a stopover in Dallas?", "instructions": "", "generated_query": "SELECT DISTINCT a.airline_name\nFROM airline a\nJOIN flight f ON a.airline_code = f.airline_code\nJOIN flight_stop fs ON f.flight_id = fs.flight_id\nJOIN airport ap ON fs.stop_airport = ap.airport_code\nWHERE ap.airport_location = 'Dallas';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.3934485912323, "tokens_used": 3775, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.671}, {"db_name": "atis", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT flight.flight_id, food_service.meal_description FROM flight JOIN food_service ON flight.meal_code = food_service.meal_code WHERE LOWER(food_service.compartment) LIKE '%first class%';", "question": "Which flights serve meals in first class? Give me the flight id and meal description.", "instructions": "", "generated_query": "SELECT flight.flight_id,\n       food_service.meal_description\nFROM flight\nJOIN food_service ON flight.meal_code = food_service.meal_code\nWHERE food_service.compartment = 'First Class';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.906077146530151, "tokens_used": 3631, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- days AS d\n-- fare AS f\n-- month AS m\n-- state AS s\n-- flight AS fl\n-- airline AS a\n-- airport AS ai\n-- aircraft AS air\n-- time_zone AS tz\n-- fare_basis AS fb\n-- flight_leg AS fli\n-- flight_fare AS ff\n-- flight_stop AS fs\n-- restriction AS r\n-- dual_carrier AS dc\n-- food_service AS fo\n-- time_interval AS ti\n-- ground_service AS gs\n-- airport_service AS a2\n-- class_of_service AS cos\n-- code_description AS cd\n-- compartment_class AS cc\n-- equipment_sequence AS es\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.6056600000000001}, {"db_name": "broker", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT MIN(sdp.sbDpClose) AS lowest_price FROM sbDailyPrice AS sdp JOIN sbTicker AS st ON sdp.sbDpTickerId = st.sbTickerId WHERE st.sbTickerSymbol = 'VTI' AND sdp.sbDpDate >= date('now', '-7 days');", "question": "Lowest daily closest price for symbol `VTI` in the past 7 days", "instructions": "", "generated_query": "SELECT MIN(sbDpClose) AS lowest_daily_close\nFROM sbDailyPrice\nJOIN sbTicker ON sbDailyPrice.sbDpTickerId = sbTicker.sbTickerId\nWHERE sbTickerSymbol = 'VTI'\n  AND sbDpDate >= date('now', '-7 days');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.057433605194092, "tokens_used": 873, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18150000000000002}, {"db_name": "broker", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT c.sbCustId, MIN(julianday(t.sbTxDateTime)) - julianday(c.sbCustJoinDate) AS DaysFromJoinToFirstTransaction FROM sbCustomer AS c JOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId GROUP BY c.sbCustId;", "question": "Return the customer id and the difference between their time from joining to their first transaction. Ignore customers who haven't made any transactions.", "instructions": "", "generated_query": "SELECT c.sbCustId,\n       julianday(MIN(t.sbTxDateTime)) - julianday(c.sbCustJoinDate) AS time_difference\nFROM sbCustomer c\nJOIN sbTransaction t ON c.sbCustId = t.sbTxCustId\nGROUP BY c.sbCustId;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.536174774169922, "tokens_used": 949, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.21197000000000005}, {"db_name": "broker", "db_type": "sqlite", "query_category": "date_functions", "query": "WITH SellTransactions AS (SELECT sbTxCustId, COUNT(*) AS num_tx FROM sbTransaction WHERE DATE(sbTxDateTime) = '2023-04-01' AND sbTxType = 'sell' GROUP BY sbTxCustId) SELECT c.sbCustId, c.sbCustName, st.num_tx FROM sbCustomer AS c JOIN SellTransactions AS st ON c.sbCustId = st.sbTxCustId ORDER BY st.num_tx DESC NULLS FIRST LIMIT 1;", "question": "Return the customer who made the most sell transactions on 2023-04-01. Return the id, name and number of transactions.", "instructions": "", "generated_query": "SELECT c.sbCustId AS id,\n       c.sbCustName AS name,\n       COUNT(*) AS number_of_transactions\nFROM sbTransaction t\nJOIN sbCustomer c ON t.sbTxCustId = c.sbCustId\nWHERE t.sbTxType = 'sell'\n  AND DATE(t.sbTxDateTime) = '2023-04-01'\nGROUP BY c.sbCustId\nORDER BY number_of_transactions DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.4541585445404053, "tokens_used": 1050, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25542}, {"db_name": "broker", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT strftime('%Y-%m', sbTxDateTime) AS month, AVG(sbTxPrice) AS avg_price FROM sbTransaction WHERE sbTxStatus = 'success' AND sbTxDateTime BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY month ORDER BY month;SELECT strftime('%Y-%m-01 00:00:00', sbTxDateTime) AS datetime, AVG(sbTxPrice) AS avg_price FROM sbTransaction WHERE sbTxStatus = 'success' AND sbTxDateTime BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY datetime ORDER BY datetime;SELECT strftime('%Y-%m-01', sbTxDateTime) AS datetime, AVG(sbTxPrice) AS avg_price FROM sbTransaction WHERE sbTxStatus = 'success' AND sbTxDateTime BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY datetime ORDER BY datetime;", "question": "What is the monthly average transaction price for successful transactions in the 1st quarter of 2023?", "instructions": "", "generated_query": "SELECT strftime('%Y-%m', sbTxDateTime) AS MONTH,\n       AVG(sbTxPrice) AS MonthlyAveragePrice\nFROM sbTransaction\nWHERE sbTxStatus = 'success'\n  AND sbTxDateTime >= '2023-01-01'\n  AND sbTxDateTime < '2023-04-01'\nGROUP BY strftime('%Y-%m', sbTxDateTime);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.7406201362609863, "tokens_used": 1035, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25113}, {"db_name": "broker", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(t.sbTxCustId) AS transaction_count FROM sbTransaction AS t JOIN sbCustomer AS c ON t.sbTxCustId = c.sbCustId WHERE c.sbCustJoinDate >= date('now', '-70 days');", "question": "number of transactions by users who joined in the past 70 days", "instructions": "", "generated_query": "SELECT c.sbCustId,\n       COUNT(t.sbTxId) AS transaction_count\nFROM sbCustomer AS c\nJOIN sbTransaction AS t ON c.sbCustId = t.sbTxCustId\nWHERE c.sbCustJoinDate >= date('now', '-70 days')\nGROUP BY c.sbCustId;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.000467538833618, "tokens_used": 1066, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- sbCustomer AS sc\n-- sbTicker AS st\n-- sbDailyPrice AS sdp\n-- sbTransaction AS sb\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.26741000000000004}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT s.first_name, s.last_name, s.phone, julianday(s.termination_date) - julianday(s.hire_date) AS days_employed FROM salespersons AS s ORDER BY CASE WHEN days_employed IS NULL THEN 1 ELSE 0 END, days_employed ASC LIMIT 1;", "question": "Return the name and phone number of the salesperson with the shortest time from being hired to getting fired. Return the number of days he/she was employed for.", "instructions": "", "generated_query": "SELECT first_name || ' ' || last_name AS name,\n       phone,\n       CAST(julianday(termination_date) - julianday(hire_date) AS INTEGER) AS days_employed\nFROM salespersons\nWHERE hire_date IS NOT NULL\n  AND termination_date IS NOT NULL\nORDER BY days_employed ASC\nLIMIT 1;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.288965702056885, "tokens_used": 1335, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27984000000000003}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(*) AS weekend_payments FROM payments_made WHERE vendor_name = 'Utility Company' AND strftime('%w', payment_date) IN ('0', '6');", "question": "Return the number of payments made on weekends to the vendor named 'Utility Company'", "instructions": "", "generated_query": "SELECT COUNT(*)\nFROM payments_made\nWHERE vendor_name = 'Utility Company'\n  AND strftime('%w', payment_date) IN ('0',\n                                       '6');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.029613971710205, "tokens_used": 1090, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17699}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT CASE WHEN strftime('%m', s.sale_date) BETWEEN '01' AND '03' THEN '2023-01-01' WHEN strftime('%m', s.sale_date) BETWEEN '04' AND '06' THEN '2023-04-01' WHEN strftime('%m', s.sale_date) BETWEEN '07' AND '09' THEN '2023-07-01' ELSE '2023-10-01' END AS quarter, c.state, SUM(s.sale_price) AS total_sales FROM sales AS s JOIN customers AS c ON s.customer_id = c.id WHERE strftime('%Y', s.sale_date) = '2023' GROUP BY c.state, quarter HAVING SUM(s.sale_price) > 0 ORDER BY quarter, c.state;", "question": "What were the total quarterly sales in 2023 grouped by customer's state? Represent each quarter as the first date in the quarter.", "instructions": "", "generated_query": "SELECT c.state,\n       CASE\n           WHEN CAST(strftime('%m', s.sale_date) AS INTEGER) BETWEEN 1 AND 3 THEN date(s.sale_date, 'start of year')\n           WHEN CAST(strftime('%m', s.sale_date) AS INTEGER) BETWEEN 4 AND 6 THEN date(s.sale_date, 'start of year', '+3 months')\n           WHEN CAST(strftime('%m', s.sale_date) AS INTEGER) BETWEEN 7 AND 9 THEN date(s.sale_date, 'start of year', '+6 months')\n           WHEN CAST(strftime('%m', s.sale_date) AS INTEGER) BETWEEN 10 AND 12 THEN date(s.sale_date, 'start of year', '+9 months')\n       END AS quarter_start,\n       SUM(s.sale_price) AS total_sales\nFROM sales s\nJOIN customers c ON s.customer_id = c.id\nWHERE s.sale_date BETWEEN '2023-01-01' AND '2023-12-31'\nGROUP BY c.state,\n         quarter_start\nORDER BY c.state,\n         quarter_start;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.8996264934539795, "tokens_used": 1923, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.54021}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "date_functions", "query": "WITH latest_snapshot AS (SELECT MAX(snapshot_date) AS snapshot_date FROM inventory_snapshots WHERE snapshot_date BETWEEN '2023-03-01' AND '2023-03-31'), latest_snapshot_data AS (SELECT inv.car_id FROM inventory_snapshots AS inv JOIN latest_snapshot AS ls ON inv.snapshot_date = ls.snapshot_date WHERE inv.is_in_inventory = TRUE) SELECT c.id, c.make, c.model, c.year FROM cars AS c JOIN latest_snapshot_data AS lsd ON c.id = lsd.car_id;", "question": "Which cars were in inventory in the latest snapshot for march 2023? Return the car id, make, model, and year. Cars are considered to be in inventory\" if is_in_inventory is True.\"", "instructions": "", "generated_query": "SELECT c.id,\n       c.make,\n       c.model,\n       c.year\nFROM cars c\nJOIN inventory_snapshots s ON c.id = s.car_id\nWHERE s.snapshot_date =\n    (SELECT MAX(snapshot_date)\n     FROM inventory_snapshots\n     WHERE snapshot_date BETWEEN '2023-03-01' AND '2023-03-31')\n  AND s.is_in_inventory = 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.643979787826538, "tokens_used": 1481, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34045000000000003}, {"db_name": "car_dealership", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT payment_date, payment_method, SUM(payment_amount) AS total_amount FROM payments_received WHERE payment_date >= DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days', '-7 days') AND payment_date < DATE('now',  '-' || ((strftime('%w', 'now') + 6) % 7) || ' days') GROUP BY payment_date, payment_method ORDER BY payment_date DESC, payment_method ASC;", "question": "show me the daily total amount of payments received in the whole of the previous ISO week not including the current week, split by the payment_method", "instructions": "", "generated_query": "SELECT payment_date,\n       payment_method,\n       SUM(payment_amount) AS daily_total\nFROM payments_received\nWHERE strftime('%Y-%W', payment_date) = strftime('%Y-%W', date('now', '-7 days'))\nGROUP BY payment_date,\n         payment_method\nORDER BY payment_date,\n         payment_method;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 9.933751344680786, "tokens_used": 2221, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cars AS c\n-- salespersons AS s\n-- customers AS cu\n-- sales AS sa\n-- inventory_snapshots AS inv\n-- payments_received AS pr\n-- payments_made AS pm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.67067}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(*) FROM treatments t JOIN diagnoses d ON t.diag_id = d.diag_id JOIN drugs dr ON t.drug_id = dr.drug_id WHERE d.diag_name LIKE '%psoriasis%' AND dr.fda_appr_dt IS NOT NULL AND t.end_dt >= DATE('now', '-6 months');", "question": "How many treatments for diagnoses containing 'psoriasis' (match with wildcards case-insensitively) involve drugs that have been FDA-approved and the treatments have ended within the last 6 months from today?", "instructions": "", "generated_query": "SELECT COUNT(*) AS treatment_count\nFROM treatments t\nJOIN diagnoses d ON t.diag_id = d.diag_id\nJOIN drugs dr ON t.drug_id = dr.drug_id\nWHERE d.diag_name LIKE '%psoriasis%'\n  AND dr.fda_appr_dt IS NOT NULL\n  AND t.end_dt IS NOT NULL\n  AND t.end_dt BETWEEN date('now', '-6 months') AND date('now');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.870765924453735, "tokens_used": 1993, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.52646}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "date_functions", "query": "WITH doc_first_treatment AS (SELECT d.doc_id, d.last_name, d.year_reg, t.treatment_id, t.start_dt, ROW_NUMBER() OVER (PARTITION BY d.doc_id ORDER BY t.start_dt ASC) AS rn FROM doctors AS d JOIN treatments AS t ON d.doc_id = t.doc_id WHERE d.year_reg = strftime('%Y', 'now', '-2 years')) SELECT last_name, year_reg, start_dt AS first_treatment_date, treatment_id AS first_treatment_id FROM doc_first_treatment WHERE rn = 1;", "question": "List the last name, year of registration, and first treatment (date and id) by doctors who were registered 2 years ago.", "instructions": "", "generated_query": "SELECT d.last_name,\n       d.year_reg,\n       t.treatment_id,\n       t.start_dt\nFROM doctors d\nJOIN treatments t ON d.doc_id = t.doc_id\nWHERE d.year_reg = (strftime('%Y', 'now') - 2)\n  AND t.start_dt =\n    (SELECT MIN(t2.start_dt)\n     FROM treatments t2\n     WHERE t2.doc_id = d.doc_id);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.966699838638306, "tokens_used": 1659, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.38444999999999996}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT t.treatment_id, t.start_dt, ae.reported_dt, ae.description FROM adverse_events AS ae JOIN treatments AS t ON ae.treatment_id = t.treatment_id WHERE ae.reported_dt BETWEEN t.start_dt AND date(t.start_dt, '+10 days');", "question": "Return the treatment id, treatment start date, adverse event date and description of all adverse events that occured within 10 days after starting treatment", "instructions": "", "generated_query": "SELECT t.treatment_id,\n       t.start_dt,\n       a.reported_dt,\n       a.description\nFROM treatments t\nJOIN adverse_events a ON t.treatment_id = a.treatment_id\nWHERE a.reported_dt BETWEEN t.start_dt AND date(t.start_dt, '+10 days');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.067788600921631, "tokens_used": 1244, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20185000000000003}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT t.treatment_id, t.start_dt AS treatment_start_date, t.end_dt AS treatment_end_date, cm.start_dt AS concomitant_med_start_date, cm.end_dt AS concomitant_med_end_date FROM treatments AS t JOIN concomitant_meds AS cm ON t.treatment_id = cm.treatment_id WHERE t.is_placebo = 1 AND cm.start_dt BETWEEN t.start_dt AND date(t.start_dt, '+14 days') ORDER BY t.treatment_id;", "question": "show all placebo treatment id, start and end date, where there concomitant_meds were started within 2 weeks of starting the treatment. also return the start and end dates of all concomitant drug usage.", "instructions": "", "generated_query": "SELECT t.treatment_id,\n       t.start_dt AS treatment_start,\n       t.end_dt AS treatment_end,\n       cm.start_dt AS concomitant_start,\n       cm.end_dt AS concomitant_end\nFROM treatments t\nJOIN concomitant_meds cm ON t.treatment_id = cm.treatment_id\nWHERE t.is_placebo = 1\n  AND date(cm.start_dt) BETWEEN t.start_dt AND date(t.start_dt, '+14 days');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.267807483673096, "tokens_used": 1549, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.33110000000000006}, {"db_name": "derm_treatment", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT AVG(strftime('%Y', 'now') - strftime('%Y', date_of_birth)) AS avg_age FROM patients WHERE gender = 'Male' AND ins_type = 'private';", "question": "what is average age (in integer years) of all registered male patients with private insurance currently?", "instructions": "", "generated_query": "SELECT CAST(AVG(age) AS INTEGER) AS avg_age\nFROM\n  (SELECT CAST((julianday('now') - julianday(date_of_birth)) / 365.25 AS INTEGER) AS age\n   FROM patients\n   WHERE gender = 'Male'\n     AND ins_type = 'private');", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.046670913696289, "tokens_used": 1816, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- doctors AS d\n-- patients AS p\n-- drugs AS dr\n-- diagnoses AS di\n-- treatments AS t\n-- outcomes AS o\n-- adverse_events AS ae\n-- concomitant_meds AS cm\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.45617}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "date_functions", "query": "WITH retail_merchants AS (SELECT mid FROM merchants WHERE LOWER(category) LIKE LOWER('%retail%') AND status = 'active'), merchant_balances AS (SELECT balance FROM wallet_merchant_balance_daily AS wmbd JOIN retail_merchants AS rm ON wmbd.merchant_id = rm.mid WHERE DATE(wmbd.updated_at) = date('now')) SELECT AVG(balance) AS median_balance FROM (SELECT balance FROM merchant_balances ORDER BY balance LIMIT 2 - (SELECT COUNT(*) FROM merchant_balances) % 2 OFFSET (SELECT (COUNT(*) - 1) / 2 FROM merchant_balances));", "question": "Give me today's median merchant wallet balance for all active merchants whose category contains 'retail'", "instructions": "", "generated_query": "WITH valid_merchants AS\n  (SELECT w.balance\n   FROM merchants m\n   JOIN wallet_merchant_balance_daily w ON m.mid = w.merchant_id\n   WHERE m.status = 'active'\n     AND m.category LIKE '%retail%'\n     AND date(w.updated_at) = date('now')),\n     ordered_balances AS\n  (SELECT balance,\n          ROW_NUMBER() OVER (\n                             ORDER BY balance) AS rn,\n          COUNT(*) OVER () AS total_count\n   FROM valid_merchants)\nSELECT AVG(balance) AS median_balance\nFROM ordered_balances\nWHERE rn IN ((total_count + 1) / 2,\n             (total_count + 2) / 2);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.306620121002197, "tokens_used": 2035, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.48488000000000003}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT AVG(tx_limit_daily) AS avg_daily_limit, AVG(tx_limit_monthly) AS avg_monthly_limit FROM user_setting_snapshot WHERE snapshot_date = (SELECT MIN(snapshot_date) FROM user_setting_snapshot WHERE snapshot_date >= '2023-01-01' AND snapshot_date < '2024-01-01');", "question": "What was the average transaction daily and monthly limit for the earliest setting snapshot in 2023?", "instructions": "", "generated_query": "WITH earliest_snapshots AS\n  (SELECT s.user_id,\n          s.tx_limit_daily,\n          s.tx_limit_monthly\n   FROM user_setting_snapshot s\n   JOIN\n     (SELECT user_id,\n             MIN(created_at) AS min_created_at\n      FROM user_setting_snapshot\n      WHERE created_at >= '2023-01-01'\n        AND created_at < '2024-01-01'\n      GROUP BY user_id) AS t ON s.user_id = t.user_id\n   AND s.created_at = t.min_created_at)\nSELECT AVG(tx_limit_daily) AS avg_tx_limit_daily,\n       AVG(tx_limit_monthly) AS avg_tx_limit_monthly\nFROM earliest_snapshots;", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 7.1374945640563965, "tokens_used": 2547, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.7098300000000001}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "date_functions", "query": "WITH earliest_coupons AS (SELECT c.merchant_id, MIN(c.start_date) AS earliest_coupon_start_date FROM coupons AS c GROUP BY c.merchant_id) SELECT m.mid AS merchant_id, m.created_at AS merchant_registration_date, ec.earliest_coupon_start_date, c.cid AS earliest_coupon_id FROM merchants AS m JOIN earliest_coupons AS ec ON m.mid = ec.merchant_id JOIN coupons AS c ON ec.merchant_id = c.merchant_id AND ec.earliest_coupon_start_date = c.start_date WHERE ec.earliest_coupon_start_date <= date(m.created_at, '+1 year');", "question": "Which merchants earliest coupon start date was within a year of the merchant's registration? Return the merchant id, registration date, and earliest coupon id and start date", "instructions": "", "generated_query": "SELECT m.mid,\n       m.created_at AS registration_date,\n       c.cid AS earliest_coupon_id,\n       c.start_date AS earliest_coupon_start_date\nFROM merchants m\nJOIN\n  (SELECT merchant_id,\n          MIN(start_date) AS earliest_start_date\n   FROM coupons\n   GROUP BY merchant_id) ec ON m.mid = ec.merchant_id\nJOIN coupons c ON c.merchant_id = ec.merchant_id\nAND c.start_date = ec.earliest_start_date\nWHERE date(c.start_date) BETWEEN date(m.created_at) AND date(m.created_at, '+1 year');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.232986927032471, "tokens_used": 1837, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.39347000000000004}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT u.username, u.email, u.created_at FROM users AS u LEFT JOIN notifications AS n ON u.uid = n.user_id AND n.created_at BETWEEN u.created_at AND date(u.created_at, '+1 year') WHERE n.user_id IS NULL;", "question": "Which users did not get a notification within the first year of signing up? Return their usernames, emails and signup dates.", "instructions": "", "generated_query": "SELECT u.username,\n       u.email,\n       u.created_at\nFROM users u\nWHERE NOT EXISTS\n    (SELECT 1\n     FROM notifications n\n     WHERE n.user_id = u.uid\n       AND n.created_at < datetime(u.created_at, '+1 year'));", "reason": "", "error_msg": "INCORRECT RESULTS", "exact_match": 0, "correct": 0, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.411865472793579, "tokens_used": 1576, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.28094}, {"db_name": "ewallet", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT device_type, AVG(strftime('%s', session_end_ts) - strftime('%s', session_start_ts)) AS avg_session_duration_seconds FROM user_sessions WHERE session_end_ts IS NOT NULL GROUP BY device_type;", "question": "what was the average user session duration in seconds split by device_type?", "instructions": "", "generated_query": "SELECT device_type,\n       AVG((julianday(session_end_ts) - julianday(session_start_ts)) * 86400) AS average_session_duration_seconds\nFROM user_sessions\nWHERE session_start_ts IS NOT NULL\n  AND session_end_ts IS NOT NULL\nGROUP BY device_type;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.705659866333008, "tokens_used": 1445, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- consumer_div.users AS u\n-- consumer_div.merchants AS m\n-- consumer_div.coupons AS c\n-- consumer_div.wallet_transactions_daily AS wtd\n-- consumer_div.wallet_user_balance_daily AS wubd\n-- consumer_div.wallet_merchant_balance_daily AS wmbd\n-- consumer_div.notifications AS n\n-- consumer_div.user_sessions AS us\n-- consumer_div.user_setting_snapshot AS uss\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22659999999999997}, {"db_name": "geography", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT lake.state_name, COUNT(lake.lake_name) AS lake_count FROM lake GROUP BY lake.state_name ORDER BY lake_count DESC NULLS FIRST;", "question": "How many lakes are there in each state?", "instructions": "", "generated_query": "SELECT state_name,\n       COUNT(*) AS lake_count\nFROM lake\nGROUP BY state_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3518025875091553, "tokens_used": 1108, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17336000000000001}, {"db_name": "geography", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT mountain.country_name, COUNT(mountain.mountain_name) AS number_of_mountains FROM mountain GROUP BY mountain.country_name ORDER BY number_of_mountains DESC NULLS FIRST;", "question": "How many mountains are there in each country?", "instructions": "", "generated_query": "SELECT country_name,\n       COUNT(*) AS mountain_count\nFROM mountain\nGROUP BY country_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.248549461364746, "tokens_used": 1053, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14916000000000001}, {"db_name": "geography", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT river.country_name, COUNT(DISTINCT river.river_name) AS number_of_rivers FROM river GROUP BY river.country_name ORDER BY number_of_rivers DESC NULLS FIRST;", "question": "How many rivers flow through each country?", "instructions": "", "generated_query": "SELECT country_name,\n       COUNT(*) AS num_rivers\nFROM river\nGROUP BY country_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.8089473247528076, "tokens_used": 1044, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14553000000000002}, {"db_name": "geography", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT river.country_name, AVG(river.length) AS average_length FROM river GROUP BY river.country_name ORDER BY average_length DESC;", "question": "What is the average length of rivers in each country?", "instructions": "", "generated_query": "SELECT country_name,\n       AVG(LENGTH) AS average_length\nFROM river\nGROUP BY country_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.0158939361572266, "tokens_used": 1134, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18414}, {"db_name": "geography", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT city.country_name, SUM(city.population) AS total_population FROM city GROUP BY city.country_name ORDER BY total_population DESC;", "question": "What is the total population in cities by country?", "instructions": "", "generated_query": "SELECT country_name,\n       SUM(population) AS total_population\nFROM city\nGROUP BY country_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.5136237144470215, "tokens_used": 1111, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17435000000000003}, {"db_name": "geography", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT city_name, population FROM city WHERE LOWER(country_name) LIKE LOWER('%United States%');", "question": "Get the cities in the United States and their population", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE\n", "generated_query": "SELECT city_name,\n       population\nFROM city\nWHERE country_name LIKE '%United States%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.8838181495666504, "tokens_used": 1258, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23408}, {"db_name": "geography", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT mountain_name, mountain_altitude FROM mountain WHERE LOWER(country_name) LIKE LOWER('%Nepal%');", "question": "What are the names and altitudes of the mountains in Nepal?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE\n", "generated_query": "SELECT mountain_name,\n       mountain_altitude\nFROM mountain\nWHERE country_name LIKE '%Nepal%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.4544174671173096, "tokens_used": 1257, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23265}, {"db_name": "geography", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT lake_name, area FROM lake WHERE LOWER(state_name) LIKE LOWER('%Michigan%');", "question": "What are the names and areas of the lakes in Michigan?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE\n", "generated_query": "SELECT lake_name,\n       area\nFROM lake\nWHERE state_name LIKE '%Michigan%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.621793508529663, "tokens_used": 1125, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.1749}, {"db_name": "geography", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT river_name FROM river WHERE traverse LIKE '%,%,%';", "question": "Which rivers traverse at least 3 cities/landmarks?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE\n", "generated_query": "SELECT river_name\nFROM river\nWHERE river_name LIKE '%'\n  AND ((LENGTH(traverse) - LENGTH(REPLACE(traverse, ',', ''))) + 1) >= 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 7.056023359298706, "tokens_used": 1531, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.35354}, {"db_name": "geography", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT state_name FROM state WHERE population < 100000;", "question": "Which states have fewer than a hundred thousand people?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter names using LIKE\n", "generated_query": "SELECT state_name\nFROM state\nWHERE population < 100000\n  AND state_name LIKE '%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.190859317779541, "tokens_used": 1514, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34672000000000003}, {"db_name": "geography", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT mountain.mountain_name, mountain.mountain_altitude FROM mountain ORDER BY mountain.mountain_altitude DESC;", "question": "What are the highest mountains in meters, ordered from highest to lowest altitude?", "instructions": "", "generated_query": "SELECT mountain_altitude,\n       mountain_name\nFROM mountain\nORDER BY mountain_altitude DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.03560209274292, "tokens_used": 1050, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14586}, {"db_name": "geography", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT river.river_name, river.length FROM river ORDER BY river.length DESC;", "question": "What are the longest rivers in meters, ordered from longest to shortest?", "instructions": "", "generated_query": "SELECT river_name,\n       LENGTH\nFROM river\nORDER BY LENGTH DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.9759044647216797, "tokens_used": 1109, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17215}, {"db_name": "geography", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT city.city_name, city.population FROM city ORDER BY city.population DESC LIMIT 5;", "question": "What are the top 5 cities with the highest population? Give both city names and the population.", "instructions": "", "generated_query": "SELECT city_name,\n       population\nFROM city\nORDER BY population DESC\nLIMIT 5;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.875504970550537, "tokens_used": 1119, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17457}, {"db_name": "geography", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT lake.lake_name, lake.area FROM lake ORDER BY lake.area DESC;", "question": "Which lakes have the largest areas in square kilometers, ordered from largest to smallest?", "instructions": "", "generated_query": "SELECT lake_name,\n       area\nFROM lake\nORDER BY area DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.2151646614074707, "tokens_used": 1047, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14421}, {"db_name": "geography", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT state.state_name, state.density FROM state ORDER BY state.density DESC;", "question": "Which states have the highest population density in people per square kilometer, ordered from highest to lowest?", "instructions": "", "generated_query": "SELECT state_name,\n       density\nFROM state\nORDER BY density DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3131651878356934, "tokens_used": 1178, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20086}, {"db_name": "geography", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT state_name, population / NULLIF(area, 0) AS population_density FROM state;", "question": "Get the ratio of population per area for each state", "instructions": "", "generated_query": "SELECT state_name,\n       (population * 1.0) / area AS population_per_area\nFROM state;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.048137903213501, "tokens_used": 1049, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.14707}, {"db_name": "geography", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT city.city_name, CAST(city.population AS REAL) / NULLIF(state.population, 0) AS population_ratio FROM city JOIN state ON city.state_name = state.state_name ORDER BY population_ratio DESC;", "question": "How does the population of each city vary in relation to the population of its corresponding state? Return the city name, and the proportion of each city's population relative to the state.", "instructions": "", "generated_query": "SELECT city.city_name,\n       1.0 * city.population / state.population AS proportion\nFROM city\nJOIN state ON city.state_name = state.state_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.5226962566375732, "tokens_used": 1277, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23914000000000002}, {"db_name": "geography", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT (CAST(everest.mountain_altitude AS REAL) / NULLIF(dhaulagiri.mountain_altitude, 0)) AS altitude_ratio FROM (SELECT mountain_altitude FROM mountain WHERE mountain_name = 'Mount Everest') AS everest, (SELECT mountain_altitude FROM mountain WHERE mountain_name = 'Dhaulagiri') AS dhaulagiri;", "question": "What is the ratio of the altitude of 'Mount Everest' to the altitude of 'Dhaulagiri'? Match strings exactly", "instructions": "", "generated_query": "SELECT (m1.mountain_altitude * 1.0 / m2.mountain_altitude) AS ratio\nFROM mountain m1,\n     mountain m2\nWHERE m1.mountain_name = 'Mount Everest'\n  AND m2.mountain_name = 'Dhaulagiri';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.3087410926818848, "tokens_used": 1228, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22088000000000002}, {"db_name": "geography", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST((SELECT length FROM river WHERE LOWER(river_name) LIKE '%mississippi%') AS REAL) / NULLIF((SELECT length FROM river WHERE LOWER(river_name) LIKE '%rhine%'), 0) AS ratio;", "question": "What is the ratio of the length of the Mississippi River to the length of the Rhine River?", "instructions": "", "generated_query": "SELECT (1.0 *\n          (SELECT LENGTH\n           FROM river\n           WHERE river_name = 'Mississippi') /\n          (SELECT LENGTH\n           FROM river\n           WHERE river_name = 'Rhine')) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.912062644958496, "tokens_used": 1268, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.24045999999999998}, {"db_name": "geography", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(SUM(NULLIF(state.population, 0)) FILTER(WHERE LOWER(state.country_name) LIKE '%united states%') AS REAL) / CAST(SUM(NULLIF(state.population, 0)) FILTER(WHERE LOWER(state.state_name) LIKE '%california%') AS REAL) AS population_ratio FROM state;", "question": "What is the ratio of the population of the United States to the population of California?", "instructions": "", "generated_query": "SELECT\n  (SELECT SUM(population)\n   FROM state\n   WHERE country_name = 'United States') * 1.0 /\n  (SELECT population\n   FROM state\n   WHERE state_name = 'California'\n     AND country_name = 'United States') AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.955341815948486, "tokens_used": 1341, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27324000000000004}, {"db_name": "geography", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT l.country_name, AVG(r.length) AS average_length FROM river AS r JOIN lake AS l ON r.country_name = l.country_name GROUP BY 1;", "question": "What is the average length of rivers per country in countries with a lake?", "instructions": "", "generated_query": "SELECT r.country_name,\n       AVG(r.length) AS average_river_length\nFROM river AS r\nWHERE r.country_name IN\n    (SELECT DISTINCT country_name\n     FROM lake)\nGROUP BY r.country_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.707150459289551, "tokens_used": 1207, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.21494000000000002}, {"db_name": "geography", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT highlow.state_name, highlow.highest_point, state.density FROM highlow JOIN state ON highlow.state_name = state.state_name;", "question": "What is the highest point in each state and what is the population density of that state?", "instructions": "", "generated_query": "SELECT h.state_name,\n       h.highest_point,\n       s.density\nFROM highlow h\nJOIN state s ON h.state_name = s.state_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.434893846511841, "tokens_used": 1260, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23727}, {"db_name": "geography", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT DISTINCT lake.country_name FROM lake JOIN river ON lake.country_name = river.country_name;", "question": "Which countries have both lakes and rivers?", "instructions": "", "generated_query": "SELECT DISTINCT lake.country_name\nFROM lake\nJOIN river ON lake.country_name = river.country_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.4934842586517334, "tokens_used": 1173, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20229000000000003}, {"db_name": "geography", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT lake.lake_name FROM lake JOIN state ON lake.state_name = state.state_name WHERE state.area > 1000 AND LOWER(lake.lake_name) LIKE LOWER('Lake%') ORDER BY lake.lake_name NULLS LAST;", "question": "Which lakes have a name that starts with \"Lake\"? They should be located in states with an area greater than 1000 square kilometers.", "instructions": "", "generated_query": "SELECT lake.lake_name\nFROM lake\nJOIN state ON lake.state_name = state.state_name\nWHERE lake.lake_name LIKE 'Lake%'\n  AND state.area > 1000;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.8788442611694336, "tokens_used": 1274, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.24013000000000004}, {"db_name": "geography", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT border_info.border FROM border_info JOIN lake ON border_info.state_name = lake.state_name WHERE LOWER(lake.lake_name) LIKE LOWER('%Ontario%');", "question": "Which states border the state where lake ontario is?", "instructions": "", "generated_query": "SELECT DISTINCT b.border\nFROM border_info AS b\nWHERE b.state_name =\n    (SELECT l.state_name\n     FROM lake AS l\n     WHERE lower(l.lake_name) = 'lake ontario');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.437904596328735, "tokens_used": 1456, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- city AS c\n-- lake AS l\n-- river AS r\n-- state AS s\n-- highlow AS h\n-- mountain AS m\n-- border_info AS bi\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.32582}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT location.city_name, COUNT(DISTINCT location.restaurant_id) AS number_of_restaurants FROM LOCATION GROUP BY location.city_name ORDER BY number_of_restaurants DESC;", "question": "How many restaurants are there in each city? Order the results by the number of restaurants in descending order.", "instructions": "", "generated_query": "SELECT city_name,\n       COUNT(*) AS restaurant_count\nFROM restaurant\nGROUP BY city_name\nORDER BY restaurant_count DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.9543697834014893, "tokens_used": 401, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.07645}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT restaurant.city_name, COUNT(*) AS number_of_restaurants FROM restaurant WHERE LOWER(restaurant.food_type) LIKE LOWER('%Italian%') GROUP BY restaurant.city_name ORDER BY number_of_restaurants DESC;", "question": "How many restaurants serve Italian food in each city?", "instructions": "", "generated_query": "SELECT city_name,\n       COUNT(*) AS restaurant_count\nFROM restaurant\nWHERE food_type = 'Italian'\nGROUP BY city_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.9730541706085205, "tokens_used": 455, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.10384000000000002}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT restaurant.food_type, AVG(restaurant.rating) AS average_rating FROM restaurant GROUP BY restaurant.food_type ORDER BY average_rating DESC;", "question": "What is the average rating of restaurants serving each type of food?", "instructions": "", "generated_query": "SELECT food_type,\n       AVG(rating) AS average_rating\nFROM restaurant\nGROUP BY food_type;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.8387672901153564, "tokens_used": 389, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.07381}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT location.city_name, COUNT(DISTINCT location.restaurant_id) AS total_count FROM LOCATION GROUP BY location.city_name;", "question": "What is the total count of restaurants in each city?", "instructions": "", "generated_query": "SELECT city_name,\n       COUNT(*) AS total_restaurants\nFROM restaurant\nGROUP BY city_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.6763083934783936, "tokens_used": 391, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.07535}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT restaurant.food_type, COUNT(DISTINCT restaurant.id) AS total_number_of_restaurants FROM restaurant GROUP BY restaurant.food_type;", "question": "What is the total number of restaurants serving each type of food?", "instructions": "", "generated_query": "SELECT food_type,\n       COUNT(*) AS total\nFROM restaurant\nGROUP BY food_type;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.644996166229248, "tokens_used": 386, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.07249000000000001}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT restaurant.name FROM restaurant WHERE LOWER(restaurant.city_name) LIKE LOWER('%Los Angeles%') AND restaurant.rating > 4 ORDER BY restaurant.name NULLS LAST;", "question": "What are the names of the restaurants in Los Angeles that have a rating higher than 4?", "instructions": "\nFollow the instructions below to generate the query:\nMatch all strings case-insensitively using wildcard operators\n", "generated_query": "SELECT name\nFROM restaurant\nWHERE rating > 4\n  AND city_name LIKE '%los angeles%' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.759917736053467, "tokens_used": 620, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.16654}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT restaurant.name FROM restaurant WHERE LOWER(LOWER(restaurant.food_type)) LIKE LOWER('%italian%');", "question": "What are the names of the restaurants that serve Italian food?", "instructions": "\nFollow the instructions below to generate the query:\nMatch all strings case-insensitively using wildcard operators\n", "generated_query": "SELECT name\nFROM restaurant\nWHERE food_type LIKE '%italian%' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.1942732334136963, "tokens_used": 536, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.13189}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT restaurant.name, restaurant.food_type FROM restaurant JOIN LOCATION ON restaurant.id = location.restaurant_id WHERE LOWER(location.street_name) LIKE LOWER('%Market St%') AND LOWER(location.city_name) LIKE LOWER('%San Francisco%');", "question": "What's the name and food type of all the restaurants located on Market St in San Francisco?", "instructions": "\nFollow the instructions below to generate the query:\nMatch all strings case-insensitively using wildcard operators\n", "generated_query": "SELECT r.name,\n       r.food_type\nFROM restaurant r\nJOIN LOCATION l ON l.restaurant_id = r.id\nWHERE l.street_name LIKE '%market st%' COLLATE NOCASE\n  AND r.city_name LIKE '%san francisco%' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.799038648605347, "tokens_used": 832, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.26015}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT restaurant.name, restaurant.rating FROM restaurant WHERE restaurant.rating > 4 AND LOWER(restaurant.city_name) LIKE LOWER('%New York%');", "question": "What's the name and rating of all the restaurants that have a rating greater than 4 and are located in the city of New York?", "instructions": "\nFollow the instructions below to generate the query:\nMatch all strings case-insensitively using wildcard operators\n", "generated_query": "SELECT name,\n       rating\nFROM restaurant\nWHERE rating > 4\n  AND city_name LIKE '%new york%' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.047644376754761, "tokens_used": 688, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19382000000000002}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT DISTINCT restaurant.city_name FROM restaurant WHERE rating = (SELECT MAX(rating) FROM restaurant);", "question": "Which city has the highest-rated restaurant?", "instructions": "\nFollow the instructions below to generate the query:\nMatch all strings case-insensitively using wildcard operators\n", "generated_query": "SELECT r.city_name\nFROM restaurant r\nWHERE r.rating =\n    (SELECT MAX(rating)\n     FROM restaurant)\n  AND r.city_name LIKE '%' || r.city_name || '%' COLLATE NOCASE\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 9.47581672668457, "tokens_used": 1390, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.50897}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT name, rating FROM restaurant ORDER BY rating DESC NULLS FIRST;SELECT id, rating FROM restaurant ORDER BY rating DESC NULLS FIRST;SELECT name, id, rating FROM restaurant ORDER BY rating DESC NULLS FIRST;", "question": "List the restaurants starting from the best ratings to the lowest", "instructions": "", "generated_query": "SELECT *\nFROM restaurant\nORDER BY rating DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.2967355251312256, "tokens_used": 505, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.12550999999999998}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT restaurant.name FROM restaurant ORDER BY restaurant.rating DESC LIMIT 3;", "question": "What are the names of the top 3 restaurants with the highest ratings?", "instructions": "", "generated_query": "SELECT name\nFROM restaurant\nORDER BY rating DESC\nLIMIT 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.0367465019226074, "tokens_used": 383, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.07050999999999999}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT geographic.region, AVG(restaurant.rating) AS average_rating FROM restaurant JOIN geographic ON restaurant.city_name = geographic.city_name GROUP BY geographic.region ORDER BY geographic.region NULLS LAST;", "question": "What is the average rating of restaurants in each region? Order the results by the region name.", "instructions": "", "generated_query": "SELECT geographic.region,\n       AVG(restaurant.rating) AS average_rating\nFROM restaurant\nJOIN geographic ON restaurant.city_name = geographic.city_name\nGROUP BY geographic.region\nORDER BY geographic.region;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3935699462890625, "tokens_used": 476, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.11011}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT name FROM restaurant WHERE LOWER(food_type) LIKE LOWER('%Italian%') OR LOWER(city_name) LIKE LOWER('%New York%') ORDER BY name NULLS LAST;", "question": "Which restaurants serve Italian cuisine or are located in New York? Order the results by the restaurant name.", "instructions": "", "generated_query": "SELECT name\nFROM restaurant\nWHERE food_type = 'Italian'\n  OR city_name = 'New York'\nORDER BY name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.815725803375244, "tokens_used": 850, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27434000000000003}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT street_name FROM location GROUP BY street_name ORDER BY COUNT(restaurant_id) DESC NULLS FIRST LIMIT 1;", "question": "Which street has the most number of restaurants?", "instructions": "", "generated_query": "SELECT street_name\nFROM LOCATION\nGROUP BY street_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.0842247009277344, "tokens_used": 643, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18689}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(CASE WHEN LOWER(food_type) LIKE LOWER('%Italian%') THEN 1 END) AS REAL) / NULLIF(COUNT(food_type), 0) AS ratio FROM restaurant WHERE LOWER(city_name) LIKE LOWER('%Los Angeles%');", "question": "What is the ratio of Italian restaurants out of all restaurants in Los Angeles?", "instructions": "", "generated_query": "SELECT SUM(CASE\n               WHEN food_type = 'Italian' THEN 1\n               ELSE 0\n           END) * 1.0 / COUNT(*) AS ratio\nFROM restaurant\nWHERE city_name = 'Los Angeles';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.374281406402588, "tokens_used": 670, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19679}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(SUM(CASE WHEN LOWER(restaurant.food_type) LIKE '%vegan%' THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN NOT LOWER(restaurant.food_type) LIKE '%vegan%' THEN 1 ELSE 0 END), 0) AS ratio FROM restaurant WHERE LOWER(LOWER(restaurant.city_name)) LIKE LOWER('%san francisco%');", "question": "What is the ratio of restaurants serving vegan food to restaurants serving non-vegan food in San Francisco? Match food_type case insensitively", "instructions": "", "generated_query": "SELECT CAST(SUM(CASE\n                    WHEN lower(food_type) = 'vegan' THEN 1\n                    ELSE 0\n                END) AS REAL) / SUM(CASE\n                                        WHEN lower(food_type) <> 'vegan' THEN 1\n                                        ELSE 0\n                                    END) AS vegan_to_non_vegan_ratio\nFROM restaurant\nWHERE lower(city_name) = 'san francisco';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.246607065200806, "tokens_used": 908, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.29722000000000004}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(CASE WHEN rating > 4 THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN rating < 4 THEN 1 END), 0) AS ratio FROM restaurant WHERE LOWER(city_name) LIKE LOWER('New York');", "question": "What is the ratio of restaurants with a rating above 4 to restaurants with a rating below 4 in New York?", "instructions": "", "generated_query": "SELECT\n  (SELECT COUNT(*)\n   FROM restaurant\n   WHERE city_name = 'New York'\n     AND rating > 4) * 1.0 /\n  (SELECT COUNT(*)\n   FROM restaurant\n   WHERE city_name = 'New York'\n     AND rating < 4) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.005918979644775, "tokens_used": 697, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20570000000000002}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(SUM(CASE WHEN restaurant.rating > 4.0 THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN restaurant.rating < 4.0 THEN 1 ELSE 0 END), 0) AS ratio FROM restaurant;", "question": "What is the ratio of restaurants with a rating above 4.0 to restaurants with a rating below 4.0 overall?", "instructions": "", "generated_query": "SELECT 1.0 * SUM(CASE\n                     WHEN rating > 4.0 THEN 1\n                     ELSE 0\n                 END) / SUM(CASE\n                                WHEN rating < 4.0 THEN 1\n                                ELSE 0\n                            END) AS ratio\nFROM restaurant;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.749067783355713, "tokens_used": 689, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20152}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(*) AS REAL) / NULLIF((SELECT COUNT(*) FROM restaurant), 0) AS rating_ratio FROM restaurant WHERE rating > 4.5;", "question": "What is the ratio of restaurants with rating > 4.5 to the total number of restaurants in the database.", "instructions": "", "generated_query": "SELECT (1.0 * SUM(CASE\n                      WHEN rating > 4.5 THEN 1\n                      ELSE 0\n                  END)) / COUNT(*) AS ratio\nFROM restaurant;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.4169623851776123, "tokens_used": 542, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.13783}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT geographic.region, COUNT(DISTINCT restaurant.id) AS number_of_restaurants FROM geographic JOIN restaurant ON geographic.city_name = restaurant.city_name GROUP BY geographic.region ORDER BY number_of_restaurants DESC NULLS FIRST;SELECT geographic.region, COUNT(DISTINCT restaurant.id) AS number_of_restaurants FROM geographic LEFT JOIN restaurant ON geographic.city_name = restaurant.city_name GROUP BY geographic.region ORDER BY number_of_restaurants DESC NULLS FIRST;", "question": "How many restaurants are there in each region?", "instructions": "", "generated_query": "SELECT g.region,\n       COUNT(*) AS restaurant_count\nFROM restaurant AS r\nJOIN geographic AS g ON r.city_name = g.city_name\nGROUP BY g.region;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6939613819122314, "tokens_used": 526, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.13541}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT geographic.region, COUNT(restaurant.id) AS number_of_restaurants FROM restaurant JOIN geographic ON restaurant.city_name = geographic.city_name WHERE LOWER(restaurant.food_type) LIKE '%italian%' GROUP BY geographic.region ORDER BY number_of_restaurants DESC;", "question": "How many restaurants serve Italian food in each region?", "instructions": "", "generated_query": "SELECT g.region,\n       COUNT(*) AS COUNT\nFROM restaurant r\nJOIN geographic g ON r.city_name = g.city_name\nWHERE r.food_type = 'Italian'\nGROUP BY g.region;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.9915204048156738, "tokens_used": 468, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.10955999999999999}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT r.city_name, r.name, COUNT(r.id) AS restaurant_count FROM restaurant AS r GROUP BY r.city_name, r.name HAVING COUNT(r.id) > 1;", "question": "What cities have more than one restaurants with the same name, and how many of them are there? Return the city name, restaurant name, and restaurant count", "instructions": "", "generated_query": "SELECT city_name,\n       name,\n       COUNT(*) AS restaurant_count\nFROM restaurant\nGROUP BY city_name,\n         name\nHAVING COUNT(*) > 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.754199743270874, "tokens_used": 673, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19283000000000003}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT geographic.region, AVG(restaurant.rating) AS average_rating FROM geographic JOIN restaurant ON geographic.city_name = restaurant.city_name GROUP BY 1;", "question": "What is the average rating of restaurants in each region?", "instructions": "", "generated_query": "SELECT geographic.region,\n       AVG(restaurant.rating) AS average_rating\nFROM restaurant\nJOIN geographic ON restaurant.city_name = geographic.city_name\nGROUP BY geographic.region;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.1768813133239746, "tokens_used": 463, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.10703000000000001}, {"db_name": "restaurants", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT location.city_name, AVG(restaurant.rating) AS average_rating FROM restaurant JOIN LOCATION ON restaurant.id = location.restaurant_id WHERE LOWER(restaurant.food_type) LIKE '%mexican%' GROUP BY location.city_name;", "question": "What is the average rating of restaurants that serve Mexican food in each city?", "instructions": "", "generated_query": "SELECT city_name,\n       AVG(rating) AS average_rating\nFROM restaurant\nWHERE food_type = 'Mexican'\nGROUP BY city_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3574204444885254, "tokens_used": 463, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- location AS l\n-- geographic AS g\n-- restaurant AS r\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.10571}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT COUNT(*) AS number_of_authors FROM (SELECT writes.authorid FROM writes GROUP BY writes.authorid HAVING COUNT(writes.paperid) > 2) AS subquery;", "question": "How many authors have published more than 2 papers?", "instructions": "", "generated_query": "SELECT COUNT(*) AS num_authors\nFROM\n  (SELECT authorid\n   FROM writes\n   GROUP BY authorid\n   HAVING COUNT(paperid) > 2);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6009273529052734, "tokens_used": 1041, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17259}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT paperkeyphrase.paperid, COUNT(paperkeyphrase.keyphraseid) AS keyphrase_count FROM paperkeyphrase GROUP BY paperkeyphrase.paperid ORDER BY keyphrase_count DESC;SELECT p.title, COUNT(pk.keyphraseid) AS num_keyphrases FROM paper AS p JOIN paperkeyphrase AS pk ON p.paperid = pk.paperid GROUP BY p.title ORDER BY num_keyphrases DESC;", "question": "How many keyphrases are associated with each paper?", "instructions": "", "generated_query": "SELECT p.paperid,\n       COUNT(pk.keyphraseid) AS keyphrase_count\nFROM paper p\nLEFT JOIN paperkeyphrase pk ON p.paperid = pk.paperid\nGROUP BY p.paperid;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.089463233947754, "tokens_used": 1108, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20207000000000003}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT paperdataset.datasetid, COUNT(DISTINCT paperdataset.paperid) AS total_papers FROM paperdataset GROUP BY paperdataset.datasetid;SELECT dataset.datasetname, COUNT(paperdataset.paperid) AS total_papers FROM paperdataset JOIN dataset ON paperdataset.datasetid = dataset.datasetid GROUP BY dataset.datasetname;", "question": "What is the total number of papers associated with each dataset?", "instructions": "", "generated_query": "SELECT d.datasetname,\n       COUNT(pd.paperid) AS total_papers\nFROM dataset AS d\nLEFT JOIN paperdataset AS pd ON d.datasetid = pd.datasetid\nGROUP BY d.datasetid,\n         d.datasetname;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.170461177825928, "tokens_used": 1116, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20526}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT paper.year, COUNT(paper.paperid) AS total_papers FROM paper GROUP BY paper.year ORDER BY paper.year NULLS LAST;", "question": "What is the total number of papers published in each year?", "instructions": "", "generated_query": "SELECT YEAR,\n       COUNT(*) AS total_papers\nFROM paper\nGROUP BY YEAR;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.7038285732269287, "tokens_used": 957, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.1353}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT paper.year, COUNT(paper.paperid) AS total_papers FROM paper GROUP BY paper.year ORDER BY paper.year NULLS LAST;", "question": "What is the total number of papers published per year?", "instructions": "", "generated_query": "SELECT YEAR,\n       COUNT(*) AS total_papers\nFROM paper\nGROUP BY YEAR\nORDER BY YEAR;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.0372657775878906, "tokens_used": 1024, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.16511}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT COUNT(DISTINCT writes.authorid) AS number_of_authors FROM writes JOIN paper ON writes.paperid = paper.paperid JOIN journal ON paper.journalid = journal.journalid WHERE LOWER(journal.journalname) LIKE LOWER('%Science%') AND paper.year = 2020;", "question": "How many authors wrote papers that were published in the journal \"Science\" in the year 2020?", "instructions": "\nFollow the instructions below to generate the query:\nFilter paper names using exact matches.\nFilter keyphrases and journal names with case-insensitive matching.\n", "generated_query": "SELECT COUNT(DISTINCT writes.authorid)\nFROM writes\nJOIN paper ON writes.paperid = paper.paperid\nJOIN journal ON paper.journalid = journal.journalid\nWHERE paper.year = 2020\n  AND journal.journalname = 'Science' COLLATE NOCASE;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.9258410930633545, "tokens_used": 1421, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.32692}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT COUNT(DISTINCT paper.paperid) FROM paper JOIN journal ON paper.journalid = journal.journalid JOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid JOIN keyphrase ON paperkeyphrase.keyphraseid = keyphrase.keyphraseid WHERE LOWER(keyphrase.keyphrasename) LIKE LOWER('%machine learning%') AND journal.journalname = 'IEEE Transactions on Pattern Analysis and Machine Intelligence';", "question": "How many papers are associated with the keyphrase \"machine learning\" and were published in the journal named \"IEEE Transactions on Pattern Analysis and Machine Intelligence\"?", "instructions": "\nFollow the instructions below to generate the query:\nFilter paper names, journal names, using exact matches.\nFilter keyphrases with case-insensitive matching.\n", "generated_query": "SELECT COUNT(DISTINCT paper.paperid)\nFROM paper\nJOIN journal ON paper.journalid = journal.journalid\nJOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid\nJOIN keyphrase ON paperkeyphrase.keyphraseid = keyphrase.keyphraseid\nWHERE journal.journalname = 'IEEE Transactions on Pattern Analysis and Machine Intelligence'\n  AND lower(keyphrase.keyphrasename) = 'machine learning';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.819946765899658, "tokens_used": 1460, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34078}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT COUNT(paper.paperid) FROM paper JOIN journal ON paper.journalid = journal.journalid WHERE paper.year = 2020 AND LOWER(journal.journalname) LIKE LOWER('%nature%');", "question": "How many papers were published in the journal \"nature\" in the year 2020?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings with case-insensitive matching\n", "generated_query": "SELECT COUNT(*)\nFROM paper\nJOIN journal ON paper.journalid = journal.journalid\nWHERE paper.year = 2020\n  AND LOWER(journal.journalname) = 'nature';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.5795769691467285, "tokens_used": 1068, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17655}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT author.authorname FROM author JOIN writes ON author.authorid = writes.authorid JOIN paper ON writes.paperid = paper.paperid WHERE paper.title = 'The Effects of Climate Change on Agriculture';", "question": "What are the names of the authors who wrote the paper with the title \"The Effects of Climate Change on Agriculture\"?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter strings with an exact match\n", "generated_query": "SELECT DISTINCT author.authorname\nFROM paper\nJOIN writes ON paper.paperid = writes.paperid\nJOIN author ON writes.authorid = author.authorid\nWHERE paper.title = 'The Effects of Climate Change on Agriculture';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.939917325973511, "tokens_used": 1203, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23430000000000004}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT venue.venuename, COUNT(DISTINCT paper.paperid) FROM paper JOIN venue ON paper.venueid = venue.venueid WHERE paper.venueid = (SELECT venueid FROM paper WHERE paperid = 2) GROUP BY venue.venuename;", "question": "What is the name of the venue where the paper with paper ID 2 was published, and how many papers were published in total in that venue?", "instructions": "\nFollow the instructions below to generate the query:\nAlways filter strings using LIKE\n", "generated_query": "SELECT v.venuename,\n\n  (SELECT COUNT(*)\n   FROM paper\n   WHERE venueid = p.venueid) AS total_papers\nFROM paper AS p\nJOIN venue AS v ON p.venueid = v.venueid\nWHERE p.paperid = 2;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.079423904418945, "tokens_used": 1350, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.29733000000000004}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT cite.citingpaperid, COUNT(*) AS citation_count FROM cite GROUP BY cite.citingpaperid ORDER BY citation_count DESC;SELECT p.paperid, p.numciting FROM paper AS p WHERE p.numciting > 0 ORDER BY p.numciting DESC NULLS FIRST;SELECT p.title, COUNT(c.citedpaperid) AS num_cited_papers FROM paper AS p JOIN cite AS c ON p.paperid = c.citingpaperid GROUP BY p.title ORDER BY num_cited_papers DESC NULLS FIRST;", "question": "For each paper that cites other papers, how many other papers does it cite? Sort by the number of papers cited in descending order", "instructions": "", "generated_query": "SELECT citingpaperid AS paperid,\n       COUNT(citedpaperid) AS num_cited\nFROM cite\nGROUP BY citingpaperid\nORDER BY num_cited DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.641190528869629, "tokens_used": 1117, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20108}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT journal.journalname FROM journal ORDER BY LENGTH(journal.journalname) ASC NULLS LAST;", "question": "What are the names of the journals in the database, ordered by the length of the journal name from shortest to longest?", "instructions": "", "generated_query": "SELECT journalname\nFROM journal\nORDER BY LENGTH(journalname);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6597139835357666, "tokens_used": 1030, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.16346}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT paper.title FROM paper WHERE paper.year = 2020 ORDER BY paper.title ASC NULLS LAST;", "question": "What are the titles of the papers published in the year 2020, ordered alphabetically?", "instructions": "", "generated_query": "SELECT title\nFROM paper\nWHERE YEAR = 2020\nORDER BY title ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.103116512298584, "tokens_used": 962, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.13519}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT paperkeyphrase.paperid, COUNT(paperkeyphrase.keyphraseid) AS total_keyphrases FROM paperkeyphrase GROUP BY paperkeyphrase.paperid ORDER BY paperkeyphrase.paperid ASC NULLS LAST;", "question": "What is the total number of keyphrases associated with each paper, ordered by the paper ID in ascending order?", "instructions": "", "generated_query": "SELECT paper.paperid,\n       COUNT(paperkeyphrase.keyphraseid) AS total_keyphrases\nFROM paper\nLEFT JOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid\nGROUP BY paper.paperid\nORDER BY paper.paperid ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6260530948638916, "tokens_used": 1068, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18051}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT paper.paperid, COUNT(DISTINCT writes.authorid) AS num_authors FROM paper JOIN writes ON paper.paperid = writes.paperid GROUP BY paper.paperid ORDER BY num_authors DESC NULLS FIRST;SELECT paper.title, COUNT(DISTINCT writes.authorid) AS num_authors FROM paper JOIN writes ON paper.paperid = writes.paperid GROUP BY paper.title ORDER BY num_authors DESC NULLS FIRST;SELECT paper.paperid, paper.title, COUNT(DISTINCT writes.authorid) AS num_authors FROM paper JOIN writes ON paper.paperid = writes.paperid GROUP BY paper.paperid, paper.title ORDER BY num_authors DESC NULLS FIRST;", "question": "Which papers have the highest number of authors, ordered by the number of authors in descending order?", "instructions": "", "generated_query": "SELECT paper.paperid,\n       paper.title,\n       COUNT(writes.authorid) AS num_authors\nFROM paper\nJOIN writes ON paper.paperid = writes.paperid\nGROUP BY paper.paperid,\n         paper.title\nORDER BY num_authors DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.744004726409912, "tokens_used": 1060, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17831000000000002}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(CASE WHEN dataset_count > 1 THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN dataset_count = 1 THEN 1 END), 0) AS ratio FROM (SELECT paperdataset.paperid, COUNT(paperdataset.datasetid) AS dataset_count FROM paperdataset GROUP BY paperdataset.paperid) AS subquery;", "question": "What is the proportion of papers that belong to more than 1 dataset to papers that belong to 1 dataset?", "instructions": "", "generated_query": "WITH paper_ds_count AS\n  (SELECT paperid,\n          COUNT(datasetid) AS ds_count\n   FROM paperdataset\n   GROUP BY paperid)\nSELECT\n  (SELECT COUNT(*)\n   FROM paper_ds_count\n   WHERE ds_count > 1) * 1.0 /\n  (SELECT COUNT(*)\n   FROM paper_ds_count\n   WHERE ds_count = 1) AS proportion;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.802522897720337, "tokens_used": 1473, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.35871000000000003}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(DISTINCT CASE WHEN paper_count >= 3 THEN subquery.authorid END) AS REAL) / NULLIF(COUNT(DISTINCT CASE WHEN paper_count < 3 THEN subquery.authorid END), 0) AS ratio FROM (SELECT writes.authorid, COUNT(writes.paperid) AS paper_count FROM writes GROUP BY writes.authorid) AS subquery;", "question": "What is the ratio of authors who have written 3 or more papers to authors who have written less than 3 papers?", "instructions": "", "generated_query": "WITH author_counts AS\n  (SELECT authorid,\n          COUNT(*) AS paper_count\n   FROM writes\n   GROUP BY authorid)\nSELECT 1.0 * SUM(CASE\n                     WHEN paper_count >= 3 THEN 1\n                     ELSE 0\n                 END) / SUM(CASE\n                                WHEN paper_count < 3 THEN 1\n                                ELSE 0\n                            END) AS ratio\nFROM author_counts;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.558833122253418, "tokens_used": 1477, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.35981}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(CASE WHEN paper.year = 2020 THEN 1 END) AS REAL) / NULLIF(COUNT(paper.paperid), 0) AS ratio FROM paper;", "question": "What is the ratio of papers published in the year 2020 to the total number of papers in the database?", "instructions": "", "generated_query": "SELECT 1.0 *\n  (SELECT COUNT(*)\n   FROM paper\n   WHERE YEAR = 2020) /\n  (SELECT COUNT(*)\n   FROM paper) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.3262526988983154, "tokens_used": 1113, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20031000000000002}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(CASE WHEN paper.numcitedby > 1 THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN paper.numcitedby < 2 THEN 1 END), 0) AS ratio FROM paper;", "question": "What is the ratio of papers that have been cited by 2 or more papers to papers that have been cited by less than 2 papers?", "instructions": "", "generated_query": "SELECT 1.0 *\n  (SELECT COUNT(*)\n   FROM paper\n   WHERE numcitedby >= 2) /\n  (SELECT COUNT(*)\n   FROM paper\n   WHERE numcitedby < 2) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.585899591445923, "tokens_used": 1257, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.26169000000000003}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(DISTINCT CASE WHEN keyphrase_count > 1 THEN subquery.paperid END) AS REAL) / NULLIF(COUNT(DISTINCT CASE WHEN keyphrase_count = 1 THEN subquery.paperid END), 0) AS ratio FROM (SELECT paperkeyphrase.paperid, COUNT(paperkeyphrase.keyphraseid) AS keyphrase_count FROM paperkeyphrase GROUP BY paperkeyphrase.paperid) AS subquery;", "question": "What is the ratio of papers that have more than 1 keyphrases to papers that have 1 keyphrase?", "instructions": "", "generated_query": "SELECT 1.0 *\n  (SELECT COUNT(*)\n   FROM\n     (SELECT paperid\n      FROM paperkeyphrase\n      GROUP BY paperid\n      HAVING COUNT(keyphraseid) > 1)) /\n  (SELECT COUNT(*)\n   FROM\n     (SELECT paperid\n      FROM paperkeyphrase\n      GROUP BY paperid\n      HAVING COUNT(keyphraseid) = 1)) AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.778582811355591, "tokens_used": 1342, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.30074}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT paperdataset.paperid, COUNT(cite.citedpaperid) AS citation_count FROM paperdataset JOIN cite ON paperdataset.paperid = cite.citedpaperid WHERE paperdataset.datasetid = (SELECT datasetid FROM dataset WHERE LOWER(datasetname) LIKE LOWER('%COVID-19 Research%')) GROUP BY paperdataset.paperid ORDER BY citation_count DESC NULLS FIRST;SELECT p.title, COUNT(c.citingpaperid) AS num_citing_papers FROM paper AS p JOIN paperdataset AS pd ON p.paperid = pd.paperid JOIN cite AS c ON p.paperid = c.citedpaperid JOIN dataset AS d ON pd.datasetid = d.datasetid WHERE d.datasetname = 'COVID-19 Research' GROUP BY p.title ORDER BY num_citing_papers DESC;", "question": "How many papers cite each paper in the dataset named \"COVID-19 Research\"?", "instructions": "", "generated_query": "SELECT p.paperid,\n       p.title,\n       COUNT(c.citingpaperid) AS citation_count\nFROM paper AS p\nJOIN paperdataset AS pd ON p.paperid = pd.paperid\nJOIN dataset AS d ON pd.datasetid = d.datasetid\nAND d.datasetname = 'COVID-19 Research'\nLEFT JOIN cite AS c ON p.paperid = c.citedpaperid\nGROUP BY p.paperid,\n         p.title;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.369215250015259, "tokens_used": 1674, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.44946}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT journal.journalname, COUNT(DISTINCT paper.paperid) AS total_papers FROM paper JOIN journal ON paper.journalid = journal.journalid GROUP BY journal.journalname ORDER BY journal.journalname NULLS LAST;", "question": "What is the total number of papers published in each journal, ordered by the journal name?", "instructions": "", "generated_query": "SELECT journal.journalname,\n       COUNT(paper.paperid) AS total_papers\nFROM journal\nLEFT JOIN paper ON paper.journalid = journal.journalid\nGROUP BY journal.journalname\nORDER BY journal.journalname;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.8792638778686523, "tokens_used": 1058, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17776}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT COUNT(DISTINCT paperkeyphrase.keyphraseid) AS total_keyphrases FROM paper JOIN journal ON paper.journalid = journal.journalid JOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid WHERE LOWER(journal.journalname) LIKE LOWER('%IEEE Transactions%');", "question": "What is the total number of unique keyphrases associated with papers published in the journal with \"IEEE Transactions\" in its name?", "instructions": "", "generated_query": "SELECT COUNT(DISTINCT paperkeyphrase.keyphraseid) AS total_unique_keyphrases\nFROM paper\nJOIN journal ON paper.journalid = journal.journalid\nJOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid\nWHERE journal.journalname LIKE '%IEEE Transactions%';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.9324381351470947, "tokens_used": 1143, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.21252000000000001}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT author.authorname, COUNT(DISTINCT writes.paperid) AS number_of_papers FROM author JOIN writes ON author.authorid = writes.authorid GROUP BY author.authorname ORDER BY number_of_papers DESC;SELECT author.authorid, COUNT(DISTINCT writes.paperid) AS number_of_papers FROM author JOIN writes ON author.authorid = writes.authorid GROUP BY author.authorid ORDER BY number_of_papers DESC;SELECT author.authorname, author.authorid, COUNT(DISTINCT writes.paperid) AS number_of_papers FROM author JOIN writes ON author.authorid = writes.authorid GROUP BY author.authorname, author.authorid ORDER BY number_of_papers DESC;", "question": "Which authors have published the most papers, ordered by the number of papers they have published in descending order?", "instructions": "", "generated_query": "SELECT author.authorname,\n       COUNT(writes.paperid) AS num_papers\nFROM author\nJOIN writes ON author.authorid = writes.authorid\nGROUP BY author.authorid\nORDER BY num_papers DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 1.8462426662445068, "tokens_used": 1056, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17589000000000002}, {"db_name": "scholar", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT paper.title FROM paper JOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid JOIN keyphrase ON paperkeyphrase.keyphraseid = keyphrase.keyphraseid WHERE LOWER(keyphrase.keyphrasename) LIKE LOWER('%Machine Learning%');SELECT paper.paperid FROM paper JOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid JOIN keyphrase ON paperkeyphrase.keyphraseid = keyphrase.keyphraseid WHERE LOWER(keyphrase.keyphrasename) LIKE LOWER('%Machine Learning%');SELECT paper.title, paper.paperid FROM paper JOIN paperkeyphrase ON paper.paperid = paperkeyphrase.paperid JOIN keyphrase ON paperkeyphrase.keyphraseid = keyphrase.keyphraseid WHERE LOWER(keyphrase.keyphrasename) LIKE LOWER('%Machine Learning%');", "question": "Which papers are associated with the keyphrase \"Machine Learning\"?", "instructions": "", "generated_query": "SELECT p.title\nFROM paper AS p\nJOIN paperkeyphrase AS pk ON p.paperid = pk.paperid\nJOIN keyphrase AS k ON pk.keyphraseid = k.keyphraseid\nWHERE k.keyphrasename = 'Machine Learning';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.855624437332153, "tokens_used": 1055, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- cite AS c\n-- field AS f\n-- paper AS p\n-- venue AS v\n-- author AS a\n-- writes AS w\n-- dataset AS d\n-- journal AS j\n-- keyphrase AS k\n-- paperfield AS pa\n-- paperdataset AS pap\n-- paperkeyphrase AS p2\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.17842000000000002}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(DISTINCT MONTH) AS num_months FROM review WHERE YEAR = 2021 AND CASE MONTH WHEN 'January' THEN 1 WHEN 'February' THEN 2 WHEN 'March' THEN 3 WHEN 'April' THEN 4 WHEN 'May' THEN 5 WHEN 'June' THEN 6 WHEN 'July' THEN 7 WHEN 'August' THEN 8 WHEN 'September' THEN 9 WHEN 'October' THEN 10 WHEN 'November' THEN 11 WHEN 'December' THEN 12 END BETWEEN 6 AND 12;", "question": "How many months between June 2021 and December 2021 had reviews?", "instructions": "", "generated_query": "SELECT COUNT(DISTINCT MONTH)\nFROM review\nWHERE YEAR = 2021\n  AND MONTH IN ('June',\n                'July',\n                'August',\n                'September',\n                'October',\n                'November',\n                'December');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6909189224243164, "tokens_used": 1121, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22494999999999998}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(*) AS review_count FROM review WHERE DATE (CAST(review.year AS TEXT) || '-' || CASE review.month WHEN 'January' THEN '01' WHEN 'February' THEN '02' WHEN 'March' THEN '03' WHEN 'April' THEN '04' WHEN 'May' THEN '05' WHEN 'June' THEN '06' WHEN 'July' THEN '07' WHEN 'August' THEN '08' WHEN 'September' THEN '09' WHEN 'October' THEN '10' WHEN 'November' THEN '11' WHEN 'December' THEN '12' END || '-01') = (SELECT DATE (CAST(r.year AS TEXT) || '-' || CASE r.month WHEN 'January' THEN '01' WHEN 'February' THEN '02' WHEN 'March' THEN '03' WHEN 'April' THEN '04' WHEN 'May' THEN '05' WHEN 'June' THEN '06' WHEN 'July' THEN '07' WHEN 'August' THEN '08' WHEN 'September' THEN '09' WHEN 'October' THEN '10' WHEN 'November' THEN '11' WHEN 'December' THEN '12' END || '-01', '-2 months') FROM review AS r WHERE r.rid = 3);", "question": "How many reviews were there 2 months before the review with id 3?", "instructions": "", "generated_query": "WITH target AS\n  (SELECT YEAR AS base_year,\n                  CASE MONTH\n                      WHEN 'January' THEN 1\n                      WHEN 'February' THEN 2\n                      WHEN 'March' THEN 3\n                      WHEN 'April' THEN 4\n                      WHEN 'May' THEN 5\n                      WHEN 'June' THEN 6\n                      WHEN 'July' THEN 7\n                      WHEN 'August' THEN 8\n                      WHEN 'September' THEN 9\n                      WHEN 'October' THEN 10\n                      WHEN 'November' THEN 11\n                      WHEN 'December' THEN 12\n                  END AS base_month\n   FROM review\n   WHERE rid = 3)\nSELECT COUNT(*) AS review_count\nFROM review,\n     target\nWHERE review.year = CASE\n                        WHEN target.base_month > 2 THEN target.base_year\n                        ELSE target.base_year - 1\n                    END\n  AND (CASE review.month\n           WHEN 'January' THEN 1\n           WHEN 'February' THEN 2\n           WHEN 'March' THEN 3\n           WHEN 'April' THEN 4\n           WHEN 'May' THEN 5\n           WHEN 'June' THEN 6\n           WHEN 'July' THEN 7\n           WHEN 'August' THEN 8\n           WHEN 'September' THEN 9\n           WHEN 'October' THEN 10\n           WHEN 'November' THEN 11\n           WHEN 'December' THEN 12\n       END) = CASE\n                  WHEN target.base_month > 2 THEN target.base_month - 2\n                  WHEN target.base_month = 1 THEN 11\n                  WHEN target.base_month = 2 THEN 12\n              END;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 10.003314018249512, "tokens_used": 2517, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.8391900000000001}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT COUNT(*) AS review_count FROM review AS r JOIN business AS b ON r.business_id = b.business_id WHERE b.state = 'CA' AND ((r.year * 12 + CASE r.month WHEN 'January' THEN 1 WHEN 'February' THEN 2 WHEN 'March' THEN 3 WHEN 'April' THEN 4 WHEN 'May' THEN 5 WHEN 'June' THEN 6 WHEN 'July' THEN 7 WHEN 'August' THEN 8 WHEN 'September' THEN 9 WHEN 'October' THEN 10 WHEN 'November' THEN 11 WHEN 'December' THEN 12 END) >= ((CAST(strftime('%Y', 'now') AS INTEGER) * 12 + CAST(strftime('%m', 'now') AS INTEGER)) - 10));", "question": "How many reviews were written for businesses located in California in the last 10 months?", "instructions": "", "generated_query": "SELECT COUNT(*) AS review_count\nFROM review\nJOIN business ON review.business_id = business.business_id\nWHERE business.state = 'CA'\n  AND date(review.year || '-' || CASE review.month\n                                     WHEN 'January' THEN '01'\n                                     WHEN 'February' THEN '02'\n                                     WHEN 'March' THEN '03'\n                                     WHEN 'April' THEN '04'\n                                     WHEN 'May' THEN '05'\n                                     WHEN 'June' THEN '06'\n                                     WHEN 'July' THEN '07'\n                                     WHEN 'August' THEN '08'\n                                     WHEN 'September' THEN '09'\n                                     WHEN 'October' THEN '10'\n                                     WHEN 'November' THEN '11'\n                                     WHEN 'December' THEN '12'\n                                 END || '-01') >= date('now', '-10 months');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 11.330646514892578, "tokens_used": 1692, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.47586}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT SUM(COUNT) AS total_checkins FROM checkin WHERE DAY IN ('Thursday', 'Friday');", "question": "What is the total number of check-ins on the 2 days before Saturday?", "instructions": "", "generated_query": "SELECT SUM(COUNT) AS total_checkins\nFROM checkin\nWHERE DAY IN ('Thursday',\n              'Friday');", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.1867973804473877, "tokens_used": 1166, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.24475}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "date_functions", "query": "SELECT text AS message FROM tip WHERE LOWER(MONTH) LIKE LOWER('%May%') AND YEAR = 2021 LIMIT 1;", "question": "What was the message that came with the tip made exactly 2 months after March 2021?", "instructions": "", "generated_query": "SELECT text\nFROM tip\nWHERE YEAR = 2021\n  AND MONTH = 'May';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.591256856918335, "tokens_used": 1039, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.18755}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT checkin.day, SUM(checkin.count) AS total_checkins FROM checkin GROUP BY checkin.day ORDER BY total_checkins DESC;", "question": "How many check-ins occurred on each day of the week?", "instructions": "", "generated_query": "SELECT DAY,\n       SUM(COUNT) AS total_checkins\nFROM checkin\nGROUP BY DAY;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.308230400085449, "tokens_used": 966, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.15807000000000002}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT business.name, AVG(review.rating) AS average_rating FROM business JOIN review ON business.business_id = review.business_id WHERE LOWER(business.city) LIKE LOWER('%NEW YORK%') GROUP BY business.name;", "question": "Return the name and average rating for each business in new york", "instructions": "", "generated_query": "SELECT business.name,\n       AVG(review.rating) AS average_rating\nFROM business\nJOIN review ON business.business_id = review.business_id\nWHERE business.city = 'New York'\nGROUP BY business.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.463975191116333, "tokens_used": 1242, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.27951}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT checkin.business_id, SUM(checkin.count) AS total_checkins FROM checkin GROUP BY checkin.business_id ORDER BY total_checkins DESC;", "question": "What is the total count of check-ins for each business id?", "instructions": "", "generated_query": "SELECT business_id,\n       SUM(COUNT) AS total_checkins\nFROM checkin\nGROUP BY business_id;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.6317431926727295, "tokens_used": 969, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.15906}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT checkin.day, SUM(checkin.count) AS total_checkins FROM checkin WHERE checkin.business_id = 'abc123' GROUP BY checkin.day ORDER BY total_checkins DESC;", "question": "What is the total number of check-ins for each day of the week for the business with ID \"abc123\"?", "instructions": "", "generated_query": "SELECT DAY,\n       SUM(COUNT) AS total_checkins\nFROM checkin\nWHERE business_id = 'abc123'\nGROUP BY DAY;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.644800901412964, "tokens_used": 985, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.1628}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "group_by", "query": "SELECT neighbourhood.neighbourhood_name, COUNT(DISTINCT neighbourhood.business_id) AS business_count FROM neighbourhood GROUP BY neighbourhood.neighbourhood_name ORDER BY business_count DESC;SELECT neighbourhood.id, COUNT(DISTINCT neighbourhood.business_id) AS business_count FROM neighbourhood GROUP BY neighbourhood.id ORDER BY business_count DESC;SELECT neighbourhood.neighbourhood_name, neighbourhood.id, COUNT(DISTINCT neighbourhood.business_id) AS business_count FROM neighbourhood GROUP BY neighbourhood.neighbourhood_name, neighbourhood.id ORDER BY business_count DESC;", "question": "Which neighbourhoods have the highest number of businesses, and how many businesses are located in each neighbourhood?", "instructions": "", "generated_query": "SELECT neighbourhood_name,\n       COUNT(business_id) AS business_count\nFROM neighbourhood\nGROUP BY neighbourhood_name\nORDER BY business_count DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.337827205657959, "tokens_used": 1046, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.19063000000000002}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' AND LOWER(checkin.day) LIKE LOWER('%Monday%');", "question": "How many check-ins occurred on Mondays at businesses in the state of California?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings of users, city, address, business.name using LIKE with wildcards.\nFilter strings of state using exact upper case matches.\nAssume the rating of a business to be its average rating, and compute it before computing other aggregates on it.\n\n", "generated_query": "SELECT SUM(checkin.count) AS total_checkins\nFROM checkin\nJOIN business ON checkin.business_id = business.business_id\nWHERE checkin.day LIKE '%Monday%'\n  AND business.state = 'CA';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 6.515047788619995, "tokens_used": 1949, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.57013}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT COUNT(*) FROM review JOIN users ON review.user_id = users.user_id WHERE LOWER(users.name) LIKE LOWER('%Sarah Williams%') AND review.month = 'April' AND review.year = 2021;", "question": "How many reviews were posted by users with the name \"Sarah Williams\" in the month of April 2021?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings of users, city, address, business.name using LIKE with wildcards.\nFilter strings of state using exact upper case matches.\nAssume the rating of a business to be its average rating, and compute it before computing other aggregates on it.\n\n", "generated_query": "SELECT COUNT(r.rid) AS review_count\nFROM review r\nJOIN users u ON r.user_id = u.user_id\nWHERE u.name LIKE '%Sarah Williams%'\n  AND r.month LIKE '%April%'\n  AND r.year = 2021;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.154140949249268, "tokens_used": 1453, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.34925}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT review.business_id, COUNT(*) AS review_count FROM review WHERE review.year = 2021 GROUP BY review.business_id ORDER BY review_count DESC;", "question": "How many reviews were posted for each business id in the year 2021?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings of users, city, address, business.name using LIKE with wildcards.\nFilter strings of state using exact upper case matches.\nAssume the rating of a business to be its average rating, and compute it before computing other aggregates on it.\n\n", "generated_query": "WITH review_metrics AS\n  (SELECT business_id,\n          AVG(rating) AS avg_rating,\n          COUNT(*) AS review_count\n   FROM review\n   WHERE YEAR = 2021\n   GROUP BY business_id)\nSELECT business_id,\n       review_count\nFROM review_metrics;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 9.021122694015503, "tokens_used": 2344, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.7436}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT AVG(sf.average_rating) AS sf_average_rating FROM (SELECT business.business_id, AVG(review.rating) AS average_rating FROM business JOIN review ON business.business_id = review.business_id WHERE LOWER(LOWER(business.city)) LIKE LOWER('%san francisco%') GROUP BY business.business_id) AS sf;", "question": "What is the average rating of businesses in the city of San Francisco?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings of users, city, address, business.name using LIKE with wildcards.\nFilter strings of state using exact upper case matches.\nThe rating of businesses in a city refers to the average rating of the businesses in that city.\nI.e., you must compute the average rating of each business before computing the average rating of businesses in the city.\n\n", "generated_query": "SELECT AVG(business_avg) AS overall_avg_rating\nFROM\n  (SELECT AVG(review.rating) AS business_avg\n   FROM business\n   JOIN review ON business.business_id = review.business_id\n   WHERE business.city LIKE '%San Francisco%'\n   GROUP BY business.business_id);", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.8175761699676514, "tokens_used": 1211, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.23947000000000004}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "instruct", "query": "SELECT COUNT(review.rid) AS total_reviews FROM review JOIN category ON review.business_id = category.business_id WHERE review.year = 2021 AND LOWER(category.category_name) LIKE LOWER('%Cafe%');", "question": "What is the total number of reviews posted in the year 2021 for businesses in the category \"Cafe\"?", "instructions": "\nFollow the instructions below to generate the query:\nFilter strings of users, city, address, business.name using LIKE with wildcards.\nFilter strings of state using exact upper case matches.\nAssume the rating of a business to be its average rating, and compute it before computing other aggregates on it.\n\n", "generated_query": "WITH BusinessAvg AS\n  (SELECT business_id,\n          AVG(rating) AS avg_rating\n   FROM review\n   GROUP BY business_id)\nSELECT COUNT(r.rid) AS total_reviews\nFROM review r\nJOIN BusinessAvg ba ON r.business_id = ba.business_id\nJOIN category c ON r.business_id = c.business_id\nWHERE r.year = 2021\n  AND c.category_name = 'Cafe';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 8.845286846160889, "tokens_used": 2509, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.81422}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT review.month, COUNT(review.rid) AS review_count FROM review WHERE review.year = 2021 GROUP BY review.month ORDER BY CASE review.month WHEN 'January' THEN 1 WHEN 'February' THEN 2 WHEN 'March' THEN 3 WHEN 'April' THEN 4 WHEN 'May' THEN 5 WHEN 'June' THEN 6 WHEN 'July' THEN 7 WHEN 'August' THEN 8 WHEN 'September' THEN 9 WHEN 'October' THEN 10 WHEN 'November' THEN 11 WHEN 'December' THEN 12 END;", "question": "How many reviews were posted in each month of the year 2021, ordered by the month?", "instructions": "", "generated_query": "SELECT MONTH,\n       COUNT(*) AS review_count\nFROM review\nWHERE YEAR = 2021\nGROUP BY MONTH\nORDER BY CASE MONTH\n             WHEN 'January' THEN 1\n             WHEN 'February' THEN 2\n             WHEN 'March' THEN 3\n             WHEN 'April' THEN 4\n             WHEN 'May' THEN 5\n             WHEN 'June' THEN 6\n             WHEN 'July' THEN 7\n             WHEN 'August' THEN 8\n             WHEN 'September' THEN 9\n             WHEN 'October' THEN 10\n             WHEN 'November' THEN 11\n             WHEN 'December' THEN 12\n         END;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.064244508743286, "tokens_used": 1355, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.32659000000000005}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT business.name, AVG(review.rating) AS average_rating FROM business JOIN review ON business.business_id = review.business_id WHERE LOWER(business.city) LIKE LOWER('%New York%') GROUP BY business.name, business.business_id ORDER BY average_rating DESC;", "question": "Please provide a list of business names in New York and their average ratings ordered by the highest average rating first.", "instructions": "", "generated_query": "SELECT b.name,\n       AVG(r.rating) AS avg_rating\nFROM business b\nJOIN review r ON b.business_id = r.business_id\nWHERE b.state = 'NY'\nGROUP BY b.name\nORDER BY avg_rating DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.100461483001709, "tokens_used": 1323, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.31185}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT business.name FROM business ORDER BY business.name ASC NULLS LAST;", "question": "What are the names of the businesses in the database, ordered alphabetically?", "instructions": "", "generated_query": "SELECT name\nFROM business\nORDER BY name ASC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3865807056427, "tokens_used": 960, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.15444}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT business.name, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;SELECT business.business_id, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;SELECT business.bid, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;SELECT business.name, business.business_id, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;SELECT business.name, business.bid, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;SELECT business.business_id, business.bid, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;SELECT business.name, business.business_id, business.bid, business.review_count FROM business ORDER BY business.review_count DESC LIMIT 3;", "question": "What are the top 3 businesses in terms of review count?", "instructions": "", "generated_query": "SELECT name,\n       review_count\nFROM business\nORDER BY review_count DESC\nLIMIT 3;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.1414101123809814, "tokens_used": 903, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.13002}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "order_by", "query": "SELECT business.latitude, business.longitude FROM business JOIN review ON business.business_id = review.business_id GROUP BY business.business_id, business.latitude, business.longitude ORDER BY AVG(review.rating) DESC NULLS FIRST LIMIT 1;", "question": "What is the latitude and longitude of the business with the highest rating?", "instructions": "", "generated_query": "SELECT b.latitude,\n       b.longitude\nFROM business b\nJOIN\n  (SELECT business_id,\n          AVG(rating) AS avg_rating\n   FROM review\n   GROUP BY business_id) r ON b.business_id = r.business_id\nORDER BY r.avg_rating DESC\nLIMIT 1;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 10.675078630447388, "tokens_used": 1583, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.42889}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT category.category_name, CAST(COUNT(CASE WHEN review.rating > 3 THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN review.rating < 3 THEN 1 END), 0) AS ratio FROM review JOIN category ON review.business_id = category.business_id GROUP BY category.category_name ORDER BY ratio DESC;SELECT category.id, CAST(COUNT(CASE WHEN review.rating > 3 THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN review.rating < 3 THEN 1 END), 0) AS ratio FROM review JOIN category ON review.business_id = category.business_id GROUP BY category.id ORDER BY ratio DESC;SELECT category.category_name, category.id, CAST(COUNT(CASE WHEN review.rating > 3 THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN review.rating < 3 THEN 1 END), 0) AS ratio FROM review JOIN category ON review.business_id = category.business_id GROUP BY category.category_name, category.id ORDER BY ratio DESC;", "question": "How does the ratio of positive reviews (rating > 3) to negative reviews (rating < 3) vary across different categories of businesses, ordered by descending ratio?", "instructions": "", "generated_query": "SELECT c.category_name,\n       1.0 * SUM(CASE\n                     WHEN r.rating > 3 THEN 1\n                     ELSE 0\n                 END) / NULLIF(SUM(CASE\n                                       WHEN r.rating < 3 THEN 1\n                                       ELSE 0\n                                   END), 0) AS pos_neg_ratio\nFROM review r\nJOIN category c ON r.business_id = c.business_id\nGROUP BY c.category_name\nORDER BY pos_neg_ratio DESC;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 4.7446184158325195, "tokens_used": 1314, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.30393000000000003}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(COUNT(CASE WHEN business.state = 'CA' THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN business.state = 'NY' THEN 1 END), 0) AS ratio FROM business;", "question": "What is the ratio of businesses in the state of California to businesses in the state of New York?", "instructions": "", "generated_query": "SELECT\n  (SELECT COUNT(*)\n   FROM business\n   WHERE state = 'CA') * 1.0 /\n  (SELECT COUNT(*)\n   FROM business\n   WHERE state = 'NY') AS ratio;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.814133405685425, "tokens_used": 992, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.16687}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(SUM(CASE WHEN checkin.day IN ('Saturday', 'Sunday') THEN checkin.count ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN NOT checkin.day IN ('Saturday', 'Sunday') THEN checkin.count ELSE 0 END), 0) AS ratio FROM checkin JOIN business ON checkin.business_id = business.business_id WHERE LOWER(business.name) LIKE LOWER('%Mark''s Bistro%');", "question": "What is the ratio of check-ins on weekends to check-ins on weekdays for the business named \"Mark's Bistro\"?", "instructions": "", "generated_query": "SELECT (1.0 * SUM(CASE\n                      WHEN checkin.day IN ('Saturday', 'Sunday') THEN checkin.count\n                      ELSE 0\n                  END)) / NULLIF(SUM(CASE\n                                         WHEN checkin.day IN ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday') THEN checkin.count\n                                         ELSE 0\n                                     END), 0) AS ratio\nFROM checkin\nJOIN business ON checkin.business_id = business.business_id\nWHERE business.name = 'Mark''s Bistro';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.587766408920288, "tokens_used": 1378, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.33572}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT CAST(SUM(CASE WHEN business.is_open = 1 THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN business.is_open = 0 THEN 1 ELSE 0 END), 0) AS ratio FROM business WHERE LOWER(LOWER(business.city)) LIKE LOWER('%san francisco%');", "question": "What is the ratio of open businesses to closed businesses in the city of San Francisco?", "instructions": "", "generated_query": "SELECT CAST(SUM(CASE\n                    WHEN is_open = 1 THEN 1\n                    ELSE 0\n                END) AS FLOAT) / NULLIF(SUM(CASE\n                                                WHEN is_open = 0 THEN 1\n                                                ELSE 0\n                                            END), 0) AS ratio\nFROM business\nWHERE city = 'San Francisco';", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.070835590362549, "tokens_used": 1078, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.2057}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "ratio", "query": "SELECT business.state, COUNT(business.business_id) / NULLIF(CAST((SELECT COUNT(*) FROM business) AS REAL), 0) AS ratio FROM business GROUP BY business.state;", "question": "What is the ratio of the number of businesses in each state to the total number of businesses in the database?", "instructions": "", "generated_query": "SELECT state,\n       COUNT(*) * 1.0 /\n  (SELECT COUNT(*)\n   FROM business) AS ratio\nFROM business\nGROUP BY state;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.3425350189208984, "tokens_used": 989, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.16489}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT category.category_name FROM (SELECT business.business_id, AVG(review.rating) AS average_rating FROM business JOIN review ON business.business_id = review.business_id GROUP BY business.business_id) AS business_rating JOIN category ON business_rating.business_id = category.business_id GROUP BY category.category_name ORDER BY AVG(business_rating.average_rating) DESC LIMIT 2;SELECT category.id FROM (SELECT business.business_id, AVG(review.rating) AS average_rating FROM business JOIN review ON business.business_id = review.business_id GROUP BY business.business_id) AS business_rating JOIN category ON business_rating.business_id = category.business_id GROUP BY category.id ORDER BY AVG(business_rating.average_rating) DESC LIMIT 2;SELECT category.category_name, category.id FROM (SELECT business.business_id, AVG(review.rating) AS average_rating FROM business JOIN review ON business.business_id = review.business_id GROUP BY business.business_id) AS business_rating JOIN category ON business_rating.business_id = category.business_id GROUP BY category.category_name, category.id ORDER BY AVG(business_rating.average_rating) DESC LIMIT 2;", "question": "What are the top 2 categories of businesses with the highest average rating?", "instructions": "", "generated_query": "SELECT c.category_name,\n       AVG(r.rating) AS avg_rating\nFROM review AS r\nJOIN category AS c ON r.business_id = c.business_id\nGROUP BY c.category_name\nORDER BY avg_rating DESC\nLIMIT 2;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.2262513637542725, "tokens_used": 1125, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.22704000000000002}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT business.business_id, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.business_id ORDER BY total_checkins DESC;SELECT business.name, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.name ORDER BY total_checkins DESC;SELECT business.bid, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.bid ORDER BY total_checkins DESC;SELECT business.business_id, business.name, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.business_id, business.name ORDER BY total_checkins DESC;SELECT business.business_id, business.bid, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.business_id, business.bid ORDER BY total_checkins DESC;SELECT business.name, business.bid, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.name, business.bid ORDER BY total_checkins DESC;SELECT business.business_id, business.name, business.bid, SUM(checkin.count) AS total_checkins FROM business JOIN checkin ON business.business_id = checkin.business_id WHERE business.state = 'CA' GROUP BY business.business_id, business.name, business.bid ORDER BY total_checkins DESC;", "question": "What is the total number of check-ins for each business in the state of California?", "instructions": "", "generated_query": "SELECT b.business_id,\n       b.name,\n       SUM(c.count) AS total_checkins\nFROM business AS b\nJOIN checkin AS c ON b.business_id = c.business_id\nWHERE b.state = 'CA'\nGROUP BY b.business_id,\n         b.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 2.7381646633148193, "tokens_used": 1070, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.20217999999999997}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT category.category_name, SUM(business.review_count) AS total_reviews FROM business JOIN category ON business.business_id = category.business_id GROUP BY category.category_name ORDER BY total_reviews DESC;SELECT category.id, SUM(business.review_count) AS total_reviews FROM business JOIN category ON business.business_id = category.business_id GROUP BY category.id ORDER BY total_reviews DESC;SELECT category.category_name, category.id, SUM(business.review_count) AS total_reviews FROM business JOIN category ON business.business_id = category.business_id GROUP BY category.category_name, category.id ORDER BY total_reviews DESC;", "question": "What is the total number of reviews for each business category?", "instructions": "", "generated_query": "SELECT c.category_name,\n       COUNT(r.rid) AS total_reviews\nFROM review r\nJOIN category c ON r.business_id = c.business_id\nGROUP BY c.category_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.885756254196167, "tokens_used": 1179, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.25179}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT category.category_name, SUM(business.review_count) AS total_reviews FROM business JOIN category ON business.business_id = category.business_id WHERE business.state = 'CA' GROUP BY category.category_name ORDER BY total_reviews DESC;SELECT category.id, SUM(business.review_count) AS total_reviews FROM business JOIN category ON business.business_id = category.business_id WHERE business.state = 'CA' GROUP BY category.id ORDER BY total_reviews DESC;SELECT category.category_name, category.id, SUM(business.review_count) AS total_reviews FROM business JOIN category ON business.business_id = category.business_id WHERE business.state = 'CA' GROUP BY category.category_name, category.id ORDER BY total_reviews DESC;", "question": "What is the total number of reviews for each category in the state of \"California\"?", "instructions": "", "generated_query": "SELECT category.category_name,\n       COUNT(review.rid) AS total_reviews\nFROM business\nJOIN review ON business.business_id = review.business_id\nJOIN category ON business.business_id = category.business_id\nWHERE business.state = 'CA'\nGROUP BY category.category_name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 5.050809621810913, "tokens_used": 1585, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.42878000000000005}, {"db_name": "yelp", "db_type": "sqlite", "query_category": "table_join", "query": "SELECT users.name, COUNT(review.rid) AS review_count FROM review JOIN neighbourhood ON review.business_id = neighbourhood.business_id JOIN users ON review.user_id = users.user_id WHERE LOWER(neighbourhood.neighbourhood_name) LIKE LOWER('%Downtown%') GROUP BY users.name ORDER BY review_count DESC;SELECT users.user_id, COUNT(review.rid) AS review_count FROM review JOIN neighbourhood ON review.business_id = neighbourhood.business_id JOIN users ON review.user_id = users.user_id WHERE LOWER(neighbourhood.neighbourhood_name) LIKE LOWER('%Downtown%') GROUP BY users.user_id ORDER BY review_count DESC;SELECT users.name, users.user_id, COUNT(review.rid) AS review_count FROM review JOIN neighbourhood ON review.business_id = neighbourhood.business_id JOIN users ON review.user_id = users.user_id WHERE LOWER(neighbourhood.neighbourhood_name) LIKE LOWER('%Downtown%') GROUP BY users.name, users.user_id ORDER BY review_count DESC;", "question": "Which users have posted reviews for businesses located in the neighbourhood of \"Downtown\" and how many reviews have they posted?", "instructions": "", "generated_query": "SELECT u.user_id,\n       u.name,\n       COUNT(r.rid) AS review_count\nFROM review r\nJOIN users u ON r.user_id = u.user_id\nJOIN neighbourhood n ON r.business_id = n.business_id\nWHERE n.neighbourhood_name = 'Downtown'\nGROUP BY u.user_id,\n         u.name;", "reason": "", "error_msg": "", "exact_match": 0, "correct": 1, "error_query_gen": 0, "error_db_exec": 0, "timeout": 0, "latency_seconds": 3.5215907096862793, "tokens_used": 1167, "k_shot_prompt": "", "glossary": "", "table_metadata_string": "", "table_aliases": "Use the following table aliases when referencing tables in the query:\n-- tip AS t\n-- users AS u\n-- review AS r\n-- checkin AS c\n-- business AS b\n-- category AS ca\n-- neighbourhood AS n\n", "prev_invalid_sql": "", "prev_error_msg": "", "question_0": "", "query_0": "", "question_1": "", "query_1": "", "cot_instructions": "", "cot_pregen": false, "cost_in_cents": 0.24254999999999996}]