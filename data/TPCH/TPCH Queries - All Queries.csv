Query,SQL,PyDough
"his query seeks to determine **the amount of business that was billed, shipped, and returned**. More specifically, it provides a summary pricing report for all line items shipped as of a given date. The date is within 90 days of the greatest ship date contained in the database.","select
        l_returnflag,
        l_linestatus,
        sum(l_quantity) as sum_qty,
        sum(l_extendedprice) as sum_base_price,
        sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
        sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
        avg(l_quantity) as avg_qty,
        avg(l_extendedprice) as avg_price,
        avg(l_discount) as avg_disc,
        count(*) as count_order
from
        lineitem
where
        l_shipdate <= date '1998-12-01' - interval '90' day
group by
        l_returnflag,
        l_linestatus
order by
        l_returnflag,
        l_linestatus","%%pydough

disc_price = l.extended_price * (1 - l.discount)
charge = disc_price * (1 + l.tax)
selected_lines = lines.WHERE((ship_date <= datetime.date(1998, 9, 2)))
partitioned_lines = PARTITION(selected_lines, name=""l"", by=(return_flag, status))
output = partitioned_lines(
    L_RETURNFLAG=return_flag,
    L_LINESTATUS=status,
    SUM_QTY=SUM(l.quantity),
    SUM_BASE_PRICE=SUM(l.extended_price),
    SUM_DISC_PRICE=SUM(disc_price),
    SUM_CHARGE=SUM(charge),
    AVG_QTY=AVG(l.quantity),
    AVG_PRICE=AVG(l.extended_price),
    AVG_DISC=AVG(l.discount),
    COUNT_ORDER=COUNT(l),
).ORDER_BY(return_flag.ASC(), status.ASC())
pydough.to_df(output)"
"This question seeks to determine **which supplier should be selected to place an order for a given part in a given region**. More verbosely, it finds, in a given region, for each part of a certain type and size, the supplier who can supply it at minimum cost. If several suppliers in that region offer the desired part type and size at the same (minimum) cost, the query lists the parts from suppliers with the 100 highest account balances. For each supplier, the query lists the supplier's account balance, name and nation; the part's number and manufacturer; the supplier's address, phone number and comment information. The chosen region, part type, and size are Europe, brass parts, and 15, respectively.","SELECT
    S_ACCTBAL,
    S_NAME,
    N_NAME,
    P_PARTKEY,
    P_MFGR,
    S_ADDRESS,
    S_PHONE,
    S_COMMENT
FROM
    PART,
    SUPPLIER,
    PARTSUPP,
    NATION,
    REGION
WHERE
    P_PARTKEY = PS_PARTKEY
    AND S_SUPPKEY = PS_SUPPKEY
    AND P_SIZE = 15
    AND P_TYPE LIKE '%BRASS'
    AND S_NATIONKEY = N_NATIONKEY
    AND N_REGIONKEY = R_REGIONKEY
    AND R_NAME = 'EUROPE'
    AND PS_SUPPLYCOST = (
        SELECT MIN(PS_SUPPLYCOST)
        FROM PARTSUPP, SUPPLIER, NATION, REGION
        WHERE P_PARTKEY = PS_PARTKEY
          AND S_SUPPKEY = PS_SUPPKEY
          AND S_NATIONKEY = N_NATIONKEY
          AND N_REGIONKEY = R_REGIONKEY
          AND R_NAME = 'EUROPE'
    )
ORDER BY
    S_ACCTBAL DESC,
    N_NAME,
    S_NAME,
    P_PARTKEY
LIMIT 100;","%%pydough

selected_parts = (
    nations.WHERE(region.name == ""EUROPE"")
    .suppliers.supply_records.part(
        s_acctbal=BACK(2).account_balance,
        s_name=BACK(2).name,
        n_name=BACK(3).name,
        s_address=BACK(2).address,
        s_phone=BACK(2).phone,
        s_comment=BACK(2).comment,
        supplycost=BACK(1).supplycost,
    )
    .WHERE(ENDSWITH(part_type, ""BRASS"") & (size == 15))
)
part_groups = PARTITION(selected_parts, name=""p"", by=key)(
    best_cost=MIN(p.supplycost)
)
output = part_groups.p.WHERE(
    (supplycost == BACK(1).best_cost)
    & ENDSWITH(part_type, ""BRASS"")
    & (size == 15)
)(
    S_ACCTBAL=s_acctbal,
    S_NAME=s_name,
    N_NAME=n_name,
    P_PARTKEY=key,
    P_MFGR=manufacturer,
    S_ADDRESS=s_address,
    S_PHONE=s_phone,
    S_COMMENT=s_comment,
).TOP_K(
    100,
    by=(S_ACCTBAL.DESC(), N_NAME.ASC(), S_NAME.ASC(), P_PARTKEY.ASC()),
)
pydough.to_df(output)"
"The question seeks to find **the 10 unshipped orders with the highest value**. More verbosely, it retrieves the shipping priority and potential revenue, defined as the sum of the extended price times one minus the discount, of the orders having the largest revenue among those that had not been shipped as of a given date. Orders are listed in decreasing order of revenue. If more than 10 unshipped orders exist, only the 10 orders with the largest revenue are listed.","SELECT
    L_ORDERKEY,
    SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,
    O_ORDERDATE,
    O_SHIPPRIORITY
FROM
    CUSTOMER,
    ORDERS,
    LINEITEM
WHERE
    C_MKTSEGMENT = 'BUILDING'
    AND C_CUSTKEY = O_CUSTKEY
    AND L_ORDERKEY = O_ORDERKEY
    AND O_ORDERDATE < DATE '1995-03-15'
    AND L_SHIPDATE > DATE '1995-03-15'
GROUP BY
    L_ORDERKEY,
    O_ORDERDATE,
    O_SHIPPRIORITY
ORDER BY
    REVENUE DESC,
    O_ORDERDATE
LIMIT 10;","cutoff_date = datetime.date(1995, 3, 15)
selected_orders = orders.WHERE(
    (customer.mktsegment == ""BUILDING"") & (order_date < cutoff_date)
)
selected_lines = selected_orders.lines.WHERE(ship_date > cutoff_date)(
    BACK(1).order_date,
    BACK(1).ship_priority,
)
output = PARTITION(
    selected_lines, name=""l"", by=(order_key, order_date, ship_priority)
)(
    L_ORDERKEY=order_key,
    REVENUE=SUM(l.extended_price * (1 - l.discount)),
    O_ORDERDATE=order_date,
    O_SHIPPRIORITY=ship_priority,
).TOP_K(10, by=(REVENUE.DESC(), O_ORDERDATE.ASC(), L_ORDERKEY.ASC()))
pydough.to_df(output)"
This question seeks to answer **how well the order priority system is working at ensuring that orders are delivered on time within a particular quarter**. It does this by counting the number of orders ordered in a given quarter of a given year in which at least one lineitem was received by the customer later than its committed date. The query lists the count of such orders for each order priority sorted in ascending priority order.,"SELECT
    O_ORDERPRIORITY,
    COUNT(*) AS ORDER_COUNT
FROM
    ORDERS
WHERE
    O_ORDERDATE >= DATE '1993-07-01'
    AND O_ORDERDATE < DATE '1993-10-01'
    AND EXISTS (
        SELECT 1
        FROM LINEITEM
        WHERE L_ORDERKEY = O_ORDERKEY
          AND L_COMMITDATE < L_RECEIPTDATE
    )
GROUP BY
    O_ORDERPRIORITY
ORDER BY
    O_ORDERPRIORITY;","selected_lines = lines.WHERE(commit_date < receipt_date)
selected_orders = orders.WHERE(
    (order_date >= datetime.date(1993, 7, 1))
    & (order_date < datetime.date(1993, 10, 1))
    & HAS(selected_lines)
)
output = PARTITION(selected_orders, name=""o"", by=order_priority)(
    O_ORDERPRIORITY=order_priority,
    ORDER_COUNT=COUNT(o),
).ORDER_BY(O_ORDERPRIORITY.ASC())
pydough.to_df(output)"
"Local Supplier Volume The query below helps determine whether to invest in a local distribution center by returning the revenue volume for one year by local suppliers in the ""America"" region. The results are filtered to include only the orders where both the supplier and customer are in the same nation. The query displays the nations and their revenue volume in descending order.","SELECT
    n_name,
    SUM(l_extendedprice * (1 - l_discount)) AS revenue
FROM
    customer,
    orders,
    lineitem,
    supplier,
    nation,
    region
WHERE
    c_custkey = o_custkey
    AND l_orderkey = o_orderkey
    AND l_suppkey = s_suppkey
    AND c_nationkey = s_nationkey
    AND s_nationkey = n_nationkey
    AND n_regionkey = r_regionkey
    AND r_name = 'AMERICA'
    AND o_orderdate >= DATE('1994-01-01')
    AND o_orderdate < DATE('1995-01-01')
GROUP BY
    n_name
ORDER BY
    revenue DESC
LIMIT 1;","lines_info = lines.WHERE((order.customer.nation.region.name == ""AMERICA"")
  & (supplier.nation.name== order.customer.nation.name) & (order.order_date >= datetime.date(1994, 1, 1))
  & (order.order_date < datetime.date(1995, 1, 1))
)(revenue=extended_price * (1 - discount),r_name= supplier.nation.name)

output= PARTITION(lines_info, name=""l"", by=(r_name))(
    r_name=r_name,
    revenue= SUM(l.revenue)
).TOP_K(1, by=revenue.DESC())
pydough.to_df(output)"
"This question formulated a sample ""what-if"" question, asking **how was revenue impacted over a previous year due to the presence of certain discounts** and potentially speculating on future revenue due to a change in that discount. It considers all the lineitems shipped in a given year with discounts in a certain value (in this case, 0.05 to 0.07). The query lists the amount by which the total revenue would have increased if these discounts had been eliminated for lineitems with l_quantity less than quantity. Note that the potential revenue increase is equal to the sum of the extended price times one minus the discount for all lineitems with discounts and quantities in the qualifying range. The chosen quantity range is quantity values below 24.","SELECT
    SUM(L_EXTENDEDPRICE * L_DISCOUNT) AS REVENUE
FROM
    LINEITEM
WHERE
    L_SHIPDATE >= DATE '1994-01-01'
    AND L_SHIPDATE < DATE '1995-01-01'
    AND L_DISCOUNT BETWEEN 0.05 AND 0.07
    AND L_QUANTITY < 24;","selected_lines = lines.WHERE(
    (ship_date >= datetime.date(1994, 1, 1))
    & (ship_date < datetime.date(1995, 1, 1))
    & (0.05 <= discount)
    & (discount <= 0.07)
    & (quantity < 24)
)(amt=extended_price * discount)
output = TPCH(REVENUE=SUM(selected_lines.amt))
pydough.to_df(output)"
"This question asks about **the value of goods shipped between certain nations within a particular year** as a representation for future contract negotiations. More specifically, it finds, for two given nations, the gross discounted revenues derived from lineitems in which parts were shipped from a supplier in either nation to a customer in the other nation during 1995 and 1996. The query lists the supplier nation, the customer nation, the year, and the revenue from shipments that took place in that year. The query orders the answer by Supplier nation, Customer nation, and year (all ascending). The two nations chosen are France and Germany.","SELECT
    SUPP_NATION,
    CUST_NATION,
    L_YEAR,
    SUM(VOLUME) AS REVENUE
FROM (
    SELECT
        N1.N_NAME AS SUPP_NATION,
        N2.N_NAME AS CUST_NATION,
        EXTRACT(YEAR FROM L_SHIPDATE) AS L_YEAR,
        L_EXTENDEDPRICE * (1 - L_DISCOUNT) AS VOLUME
    FROM
        SUPPLIER,
        LINEITEM,
        ORDERS,
        CUSTOMER,
        NATION N1,
        NATION N2
    WHERE
        S_SUPPKEY = L_SUPPKEY
        AND O_ORDERKEY = L_ORDERKEY
        AND C_CUSTKEY = O_CUSTKEY
        AND S_NATIONKEY = N1.N_NATIONKEY
        AND C_NATIONKEY = N2.N_NATIONKEY
        AND (
            (N1.N_NAME = 'FRANCE' AND N2.N_NAME = 'GERMANY')
            OR (N1.N_NAME = 'GERMANY' AND N2.N_NAME = 'FRANCE')
        )
        AND L_SHIPDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31'
) SHIPPING
GROUP BY
    SUPP_NATION,
    CUST_NATION,
    L_YEAR
ORDER BY
    SUPP_NATION,
    CUST_NATION,
    L_YEAR;","line_info = lines(
    supp_nation=supplier.nation.name,
    cust_nation=order.customer.nation.name,
    l_year=YEAR(ship_date),
    volume=extended_price * (1 - discount),
).WHERE(
    (ship_date >= datetime.date(1995, 1, 1))
    & (ship_date <= datetime.date(1996, 12, 31))
    & (
        ((supp_nation == ""FRANCE"") & (cust_nation == ""GERMANY""))
        | ((supp_nation == ""GERMANY"") & (cust_nation == ""FRANCE""))
    )
)

output = PARTITION(line_info, name=""l"", by=(supp_nation, cust_nation, l_year))(
    SUPP_NATION=supp_nation,
    CUST_NATION=cust_nation,
    L_YEAR=l_year,
    REVENUE=SUM(l.volume),
).ORDER_BY(
    SUPP_NATION.ASC(),
    CUST_NATION.ASC(),
    L_YEAR.ASC(),
)
pydough.to_df(output)"
"This question asks about **how the market share of a given nation within a given region has changed over two years for a given part type**. The market share for a given nation within a given region is defined as the fraction of the revenue, defined as the sum of the extended price times one minus the discount, from the products of a specified type in that region that was supplied by suppliers from the given nation. The query determines this for the years 1995 and 1996 presented in this order. The chosen nation, region, and product type are Brazil America, and `'ECONOMY ANODIZED STEEL'`, respectively.","SELECT
    O_YEAR,
    SUM(CASE
            WHEN NATION = 'BRAZIL' THEN VOLUME
            ELSE 0
        END) / SUM(VOLUME) AS MKT_SHARE
FROM (
    SELECT
        EXTRACT(YEAR FROM O_ORDERDATE) AS O_YEAR,
        L_EXTENDEDPRICE * (1 - L_DISCOUNT) AS VOLUME,
        N2.N_NAME AS NATION
    FROM
        PART,
        SUPPLIER,
        LINEITEM,
        ORDERS,
        CUSTOMER,
        NATION N1,
        NATION N2,
        REGION
    WHERE
        P_PARTKEY = L_PARTKEY
        AND S_SUPPKEY = L_SUPPKEY
        AND L_ORDERKEY = O_ORDERKEY
        AND O_CUSTKEY = C_CUSTKEY
        AND C_NATIONKEY = N1.N_NATIONKEY
        AND N1.N_REGIONKEY = R_REGIONKEY
        AND R_NAME = 'AMERICA'
        AND S_NATIONKEY = N2.N_NATIONKEY
        AND O_ORDERDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31'
        AND P_TYPE = 'ECONOMY ANODIZED STEEL'
) ALL_NATIONS
GROUP BY
    O_YEAR
ORDER BY
    O_YEAR;","selected_orders = orders.WHERE(
  (order_date >= datetime.date(1995, 1, 1))
  & (order_date <= datetime.date(1996, 12, 31))
  & (customer.nation.region.name == ""AMERICA"")
)

volume = extended_price * (1 - discount)

volume_data = selected_orders.lines.WHERE(
    part.part_type == ""ECONOMY ANODIZED STEEL""
)(
    o_year=YEAR(BACK(1).order_date),
    volume=volume,
    brazil_volume=IFF(supplier.nation.name == ""BRAZIL"", volume, 0)
)

output = PARTITION(volume_data, name=""v"", by=o_year)(
    O_YEAR=o_year,
    MKT_SHARE=SUM(v.brazil_volume) / SUM(v.volume),
)

pydough.to_df(output)"
"This question asks about **the profit made for a particular line of parts looking at the supplying nation and particular year in question**. More specifically, it finds, for each nation and each year, the profit for all parts ordered in that year that contain a specified substring in their names and that were filled by a supplier in that nation. The profit is defined as the sum of the extended price times one minus the discount, minus the product of the supply cost and quantity, for all lineitems describing parts in the specified line. The query lists the nations in ascending alphabetical order and, for each nation, the year and profit in descending order by year (most recent first). The substring in question is `'green'`.","SELECT
    NATION,
    O_YEAR,
    SUM(AMOUNT) AS SUM_PROFIT
FROM (
    SELECT
        N_NAME AS NATION,
        EXTRACT(YEAR FROM O_ORDERDATE) AS O_YEAR,
        L_EXTENDEDPRICE * (1 - L_DISCOUNT) - PS_SUPPLYCOST * L_QUANTITY AS AMOUNT
    FROM
        PART,
        SUPPLIER,
        LINEITEM,
        PARTSUPP,
        ORDERS,
        NATION
    WHERE
        S_SUPPKEY = L_SUPPKEY
        AND PS_SUPPKEY = L_SUPPKEY
        AND PS_PARTKEY = L_PARTKEY
        AND P_PARTKEY = L_PARTKEY
        AND O_ORDERKEY = L_ORDERKEY
        AND S_NATIONKEY = N_NATIONKEY
        AND P_NAME LIKE '%green%'
) PROFIT
GROUP BY
    NATION,
    O_YEAR
ORDER BY
    NATION,
    O_YEAR;","selected_lines = nations.suppliers.supply_records.WHERE(
    CONTAINS(part.name, ""green"")
).lines(
    nation=BACK(3).name,
    o_year=YEAR(order.order_date),
    value=extended_price * (1 - discount) - BACK(1).supplycost * quantity,
)

output = PARTITION(selected_lines, name=""l"", by=(nation, o_year))(
    NATION=nation, O_YEAR=o_year, AMOUNT=SUM(l.value)
).ORDER_BY(NATION.ASC(), O_YEAR.DESC())
pydough.to_df(output)"
"This question **determines the top 20 customers based on impact in revenue due to having returned parts within a particular quarter**. Revenue lost is defined as the sum of the extended price times one minus the discount for all qualifying lineitems. The chosen quarter is the last 3 months of 1993. The query lists the customer's name, address, nation, phone number, account balance, comment information and revenue lost.","SELECT
    C_CUSTKEY,
    C_NAME,
    SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS REVENUE,
    C_ACCTBAL,
    N_NAME,
    C_ADDRESS,
    C_PHONE,
    C_COMMENT
FROM
    CUSTOMER,
    ORDERS,
    LINEITEM,
    NATION
WHERE
    C_CUSTKEY = O_CUSTKEY
    AND L_ORDERKEY = O_ORDERKEY
    AND O_ORDERDATE >= DATE '1993-10-01'
    AND O_ORDERDATE < DATE '1994-01-01'
    AND L_RETURNFLAG = 'R'
    AND C_NATIONKEY = N_NATIONKEY
GROUP BY
    C_CUSTKEY,
    C_NAME,
    C_ACCTBAL,
    C_PHONE,
    N_NAME,
    C_ADDRESS,
    C_COMMENT
ORDER BY
    REVENUE DESC
LIMIT 20;","selected_lines = orders.WHERE(
    (order_date >= datetime.date(1993, 10, 1))
    & (order_date < datetime.date(1994, 1, 1))
).lines.WHERE(return_flag == ""R"")(amt=extended_price * (1 - discount))

output = customers(
    C_CUSTKEY=key,
    C_NAME=name,
    REVENUE=SUM(selected_lines.amt),
    C_ACCTBAL=acctbal,
    N_NAME=nation.name,
    C_ADDRESS=address,
    C_PHONE=phone,
    C_COMMENT=comment,
).TOP_K(20, by=(REVENUE.DESC(), C_CUSTKEY.ASC()))
pydough.to_df(output)"
"The question seeks **to identify the most import subset of available part supplies from a particular nation**. It does so by finding, from scanning the available stock of suppliers in a given nation, all the parts that represent a significant percentage of the total value of all available parts. The query displays the part number and the value of those parts in descending order of value. A significant fraction is chosen to mean as at least 0.01%, and the chosen nation is Germany.","SELECT
    PS_PARTKEY,
    SUM(PS_SUPPLYCOST * PS_AVAILQTY) AS VALUE
FROM
    PARTSUPP,
    SUPPLIER,
    NATION
WHERE
    PS_SUPPKEY = S_SUPPKEY
    AND S_NATIONKEY = N_NATIONKEY
    AND N_NAME = 'GERMANY'
GROUP BY
    PS_PARTKEY
HAVING
    SUM(PS_SUPPLYCOST * PS_AVAILQTY) > (
        SELECT
            SUM(PS_SUPPLYCOST * PS_AVAILQTY) * 0.0001
        FROM
            PARTSUPP,
            SUPPLIER,
            NATION
        WHERE
            PS_SUPPKEY = S_SUPPKEY
            AND S_NATIONKEY = N_NATIONKEY
            AND N_NAME = 'GERMANY'
    )
ORDER BY
    VALUE DESC;","is_german_supplier = supplier.nation.name == ""GERMANY""
selected_records = supply_records.WHERE(is_german_supplier)(metric=supplycost * availqty)
output = TPCH(min_market_share=SUM(selected_records.metric) * 0.0001).PARTITION(
    selected_records, name=""ps"", by=part_key
)(
    PS_PARTKEY=part_key, VALUE=SUM(ps.metric)
).WHERE(VALUE > BACK(1).min_market_share).ORDER_BY(VALUE.DESC())
pydough.to_df(output)"
"This question seeks to determine **the impact of low cost shipping modes on delays for orders of varying priorities**. It does so by counting, by ship mode, for lineitems actually received by customers in a given year, the number of lineitems belonging to orders for which the receipt date exceeds the commit date for two different specified ship modes. Only lineitems that were actually shipped before the commit date are considered. The late lineitems are partitioned into two groups, those with priority `1-URGENT` or `2-HIGH`, and those with a priority other than `1-URGENT` or `2-HIGH`. The chosen year is 1994, and the two chosen ship modes are mail & ship.","SELECT
    L_SHIPMODE,
    SUM(CASE
            WHEN O_ORDERPRIORITY = '1-URGENT'
              OR O_ORDERPRIORITY = '2-HIGH'
            THEN 1
            ELSE 0
        END) AS HIGH_LINE_COUNT,
    SUM(CASE
            WHEN O_ORDERPRIORITY <> '1-URGENT'
              AND O_ORDERPRIORITY <> '2-HIGH'
            THEN 1
            ELSE 0
        END) AS LOW_LINE_COUNT
FROM
    ORDERS,
    LINEITEM
WHERE
    O_ORDERKEY = L_ORDERKEY
    AND L_SHIPMODE IN ('MAIL', 'SHIP')
    AND L_COMMITDATE < L_RECEIPTDATE
    AND L_SHIPDATE < L_COMMITDATE
    AND L_RECEIPTDATE >= DATE '1994-01-01'
    AND L_RECEIPTDATE < DATE '1995-01-01'
GROUP BY
    L_SHIPMODE
ORDER BY
    L_SHIPMODE;","selected_lines = lines.WHERE(
    ((ship_mode == ""MAIL"") | (ship_mode == ""SHIP""))
    & (ship_date < commit_date)
    & (commit_date < receipt_date)
    & (receipt_date >= datetime.date(1994, 1, 1))
    & (receipt_date < datetime.date(1995, 1, 1))
)(
    is_high_priority=(order.order_priority == ""1-URGENT"")
    | (order.order_priority == ""2-HIGH""),
)
output = PARTITION(selected_lines, ""l"", by=ship_mode)(
    L_SHIPMODE=ship_mode,
    HIGH_LINE_COUNT=SUM(l.is_high_priority),
    LOW_LINE_COUNT=SUM(~(l.is_high_priority)),
).ORDER_BY(L_SHIPMODE.ASC())
pydough.to_df(output)"
"This question seeks to **understand the order count of each customer, including any customer who has not placed an order**. More specifically, it determines the distribution of customers by the number of orders they have made, including customers who have no record of orders, past or present. It counts and reports how many customers have no orders, how many have 1, 2, 3, etc. A check is made to ensure that the orders counted do not fall into one of several special categories of orders. Special categories are identified in the order comment column by looking for a particular pattern. The chosen pattern is comments that contain `'special'`, and later contain `'requests'`.","SELECT
    C_COUNT,
    COUNT(*) AS CUSTDIST
FROM (
    SELECT
        C_CUSTKEY,
        COUNT(O_ORDERKEY) AS C_COUNT
    FROM
        CUSTOMER
        LEFT OUTER JOIN ORDERS ON C_CUSTKEY = O_CUSTKEY
        AND O_COMMENT NOT LIKE '%special%requests%'
    GROUP BY
        C_CUSTKEY
) C_ORDERS
GROUP BY
    C_COUNT
ORDER BY
    CUSTDIST DESC,
    C_COUNT DESC;","customer_info = customers(
    key,
    num_non_special_orders=COUNT(
        orders.WHERE(~(LIKE(comment, ""%special%requests%"")))
    ),
)
output = PARTITION(customer_info, name=""custs"", by=num_non_special_orders)(
    C_COUNT=num_non_special_orders, CUSTDIST=COUNT(custs)
).ORDER_BY(CUSTDIST.DESC(), C_COUNT.DESC())
pydough.to_df(output)"
"This question seeks seeks to determine **the impact of a promotion on revenue within a particular month**. More specifically, it determines what percentage of the revenue in a given year and month was derived from promotional parts. The query considers only parts actually shipped in that month and gives the percentage. Revenue is defined as extended price times one minus the discount. The chosen year and month are September of 1995.","SELECT
    100.00 * SUM(CASE
                     WHEN P_TYPE LIKE 'PROMO%'
                     THEN L_EXTENDEDPRICE * (1 - L_DISCOUNT)
                     ELSE 0
                 END) / SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS PROMO_REVENUE
FROM
    LINEITEM,
    PART
WHERE
    L_PARTKEY = P_PARTKEY
    AND L_SHIPDATE >= DATE '1995-09-01'
    AND L_SHIPDATE < DATE '1995-10-01';","value = extended_price * (1 - discount)
selected_lines = lines.WHERE(
    (ship_date >= datetime.date(1995, 9, 1))
    & (ship_date < datetime.date(1995, 10, 1))
)(
    value=value,
    promo_value=IFF(STARTSWITH(part.part_type, ""PROMO""), value, 0),
)
output = TPCH(PROMO_REVENUE=100.0 * SUM(selected_lines.promo_value) / SUM(selected_lines.value))
pydough.to_df(output)"
"This question seeks to determine **the top supplier within a particular quarter**. It does so by finding the supplier who contributed the most to the overall revenue for parts shipped during a given quarter of a given year. In case of a tie, the query lists all suppliers whose contribution was equal to the maximum, presented in supplier number order. The chosen quarter is the first 3 months of 1996.","with REVENUE (SUPPLIER_NO, TOTAL_REVENUE) AS
    SELECT
        L_SUPPKEY,
        SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT))
    FROM
        LINEITEM
    WHERE
        L_SHIPDATE >= DATE '1996-01-01'
        AND L_SHIPDATE < DATE '1996-04-01'
    GROUP BY
        L_SUPPKEY;

SELECT
    S_SUPPKEY,
    S_NAME,
    S_ADDRESS,
    S_PHONE,
    TOTAL_REVENUE
FROM
    SUPPLIER,
    REVENUE
WHERE
    S_SUPPKEY = SUPPLIER_NO AND
    TOTAL_REVENUE = (
        SELECT
            MAX(TOTAL_REVENUE)
        FROM
            REVENUE0
    )
ORDER BY
    SUPPLIER_NO;","selected_lines = lines.WHERE(
    (ship_date >= datetime.date(1996, 1, 1))
    & (ship_date < datetime.date(1996, 4, 1))
)
total = SUM(selected_lines.extended_price * (1 - selected_lines.discount))
output = TPCH(
    max_revenue=MAX(suppliers(total_revenue=total).total_revenue)
).suppliers(
    S_SUPPKEY=key,
    S_NAME=name,
    S_ADDRESS=address,
    S_PHONE=phone,
    TOTAL_REVENUE=total,
).WHERE(TOTAL_REVENUE == BACK(1).max_revenue).ORDER_BY(S_SUPPKEY.ASC())
pydough.to_df(output)"
"This question seeks to determine **how many suppliers can meet the needs of a part with a particular set of attributes**. It does so by counting the number of suppliers who can supply parts that satisfy a particular customer's requirements. The customer is interested in parts of eight different sizes as long as they are not of a given type, not of a given brand, and not from a supplier who has had complaints registered at the Better Business Bureau. Results must be presented in descending count and ascending brand, type, and size. The chosen brand, part type, and sizes are `'Brand#45'`, `'MEDIUM POLISHED'`, and `[49, 14, 23, 45, 19, 3, 36, 9]`, respectively.","select
    p_brand,
    p_type,
    p_size,
    count(distinct ps_suppkey) as supplier_cnt
from
    partsupp,
    part
where
    p_partkey = ps_partkey
    and p_brand <> 'BRAND#45'
    and p_type not like 'MEDIUM POLISHED%'
    and p_size in (49, 14, 23, 45, 19, 3, 36, 9)
    and ps_suppkey not in (
        select
            s_suppkey
        from
            supplier
        where
            s_comment like '%Customer%Complaints%'
    )
group by
    p_brand,
    p_type,
    p_size
order by
    supplier_cnt desc,
    p_brand,
    p_type,
    p_size;","selected_records = (
    parts.WHERE(
        (brand != ""BRAND#45"")
        & ~STARTSWITH(part_type, ""MEDIUM POLISHED%"")
        & ISIN(size, [49, 14, 23, 45, 19, 3, 36, 9])
    )
    .supply_records(
        p_brand=BACK(1).brand,
        p_type=BACK(1).part_type,
        p_size=BACK(1).size,
        ps_suppkey=supplier_key,
    )
    .WHERE(~LIKE(supplier.comment, ""%Customer%Complaints%""))
)
output = PARTITION(selected_records, name=""ps"", by=(p_brand, p_type, p_size))(
    P_BRAND=p_brand,
    P_TYPE=p_type,
    P_SIZE=p_size,
    SUPPLIER_COUNT=NDISTINCT(ps.supplier_key),
).ORDER_BY(SUPPLIER_COUNT.DESC(), P_BRAND.ASC(), P_TYPE.ASC(), P_SIZE.ASC())
pydough.to_df(output)"
"This question seeks to determine **how much average yearly revenue would be lost if orders were no longer filled for small quantities of certain parts**. It does so by considering parts of a given brand and with a given container type and determines the average lineitem quantity of such parts ordered for all orders (past and pending) in the 7-year database. What would be the average yearly gross (undiscounted) loss in revenue if orders for these parts with a quantity of less than 20% of this average were no longer taken? The chosen brand and container type are `'Brand#23'` and `MED BOX`, respectively.","select
    sum(l_extendedprice) / 7.0 as avg_yearly
from
    lineitem,
    part
where
    p_partkey = l_partkey
    and p_brand = 'Brand#23'
    and p_container = 'MED BOX'
    and l_quantity < (
        select
            0.2 * avg(l_quantity)
        from
            lineitem
        where
            l_partkey = p_partkey
    )","selected_lines = parts.WHERE((brand == ""Brand#23"") & (container == ""MED BOX""))(
    avg_quantity=AVG(lines.quantity)
).lines.WHERE(quantity < 0.2 * BACK(1).avg_quantity)
output = TPCH(AVG_YEARLY=SUM(selected_lines.extended_price) / 7.0)
pydough.to_df(output)"
"This question seeks to **ranks customers based on their status as having placed a large quantity order**. It does so by calculating a list of the top 100 customers who have ever placed large quantity orders. It lists the customer name, customer key, the order key, date and total price and the quantity for the order.","select
    c_name,
    c_custkey,
    o_orderkey,
    o_orderdate,
    o_totalprice,
    sum(l_quantity)
from
    customer,
    orders,
    lineitem
where
    o_orderkey in (
        select
            l_orderkey
        from
            lineitem
        group by
            l_orderkey 
        having
            sum(l_quantity) > 300
        )
    and c_custkey = o_custkey
    and o_orderkey = l_orderkey
group by
    c_name,
    c_custkey,
    o_orderkey,
    o_orderdate,
    o_totalprice
order by
    o_totalprice desc,
    o_orderdate;","output = orders(
    C_NAME=customer.name,
    C_CUSTKEY=customer.key,
    O_ORDERKEY=key,
    O_ORDERDATE=order_date,
    O_TOTALPRICE=total_price,
    TOTAL_QUANTITY=SUM(lines.quantity),
).WHERE(
    TOTAL_QUANTITY > 300
).TOP_K(100, by=(O_TOTALPRICE.DESC(), O_ORDERDATE.ASC()))
pydough.to_df(output)"
"This question seeks to **report the gross discounted revenue resulting from select parts with a set of handling details**. More specifically, it finds the gross discounted revenue for all orders for three different types of parts that were shipped by air and delivered in person. Parts are selected based on the combination of specific brands, a list of containers, and a range of sizes. The allowed combinations are:

- The brand is `'BRAND#12'`, the quantity is between 1 and 11, the size is between 1 and 5, and the container type is one of `['SM CASE', 'SM BOX', 'SM PACK', 'SM PKG']`.
- The brand is `'BRAND#23'`, the quantity is between 10 and 20, the size is between 1 and 10, and the container type is one of `['MED BAG', 'MED BOX', 'MED PKG', 'MED PACK']`.
- The brand is `'BRAND#34'`, the quantity is between 20 and 30, the size is between 1 and 15, and the container type is one of `['LG CASE', 'LG BOX', 'LG PACK', 'LG PKG']`.","select
    sum(l_extendedprice * (1 - l_discount) ) as revenue
from
    lineitem,
    part
where
    (
        p_partkey = l_partkey
        and p_brand = 'Brand#12'
        and p_container in ( 'SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        and l_quantity >= 1 and l_quantity <= 1 + 10
        and p_size between 1 and 5
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
    )
    or
    (
        p_partkey = l_partkey
        and p_brand = 'Brand#23'
        and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        and l_quantity >= 10 and l_quantity <= 10 + 10
        and p_size between 1 and 10
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
    )
    or
    (
        p_partkey = l_partkey
        and p_brand = 'Brand#34'
        and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        and l_quantity >= 20 and l_quantity <= 20 + 10
        and p_size between 1 and 15
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
    )","selected_lines = lines.WHERE(
    (ISIN(ship_mode, (""AIR"", ""AIR REG"")))
    & (ship_instruct == ""DELIVER IN PERSON"")
    & (part.size >= 1)
    & (
        (
            (part.size <= 5)
            & (quantity >= 1)
            & (quantity <= 11)
            & ISIN(
                part.container,
                (""SM CASE"", ""SM BOX"", ""SM PACK"", ""SM PKG""),
            )
            & (part.brand == ""Brand#12"")
        )
        | (
            (part.size <= 10)
            & (quantity >= 10)
            & (quantity <= 20)
            & ISIN(
                part.container,
                (""MED BAG"", ""MED BOX"", ""MED PACK"", ""MED PKG""),
            )
            & (part.brand == ""Brand#23"")
        )
        | (
            (part.size <= 15)
            & (quantity >= 20)
            & (quantity <= 30)
            & ISIN(
                part.container,
                (""LG CASE"", ""LG BOX"", ""LG PACK"", ""LG PKG""),
            )
            & (part.brand == ""Brand#34"")
        )
    )
)
output = TPCH(
    REVENUE=SUM(selected_lines.extended_price * (1 - selected_lines.discount))
)
pydough.to_df(output)"
"This question seeks to **determine supppliers in a particular nation that may be candidate for discounts over a year in question**. More specifically, it identifies suppliers who have an excess of a given part available; an excess is defined to be more than 50% of the parts like the given part that the supplier shipped in a given year for a given nation. Only parts whose names share a certain naming convention are considered. The chosen year and nation are 1994 and Canada, respectively. The chosen naming convention is parts whose names start with `'forest'`.","select
    s_name,
    s_address
from
    supplier, nation
where
    s_suppkey in (
        select
            ps_suppkey
        from
            partsupp
        where
            ps_partkey in (
                select
                    p_partkey
                from
                    part
                where
                    p_name like 'forest%'
            )
            and ps_availqty > (
                select
                    0.5 * sum(l_quantity)
                from
                    lineitem
                where
                    l_partkey = ps_partkey
                    and l_suppkey = ps_suppkey
                    and l_shipdate >= date('1994-01-01')
                    and l_shipdate < date('1994-01-01') + interval '1' year
            )
    )
    and s_nationkey = n_nationkey
    and n_name = 'CANADA'
order by
    s_name;","part_qty = SUM(
    lines.WHERE(
        (ship_date >= datetime.date(1994, 1, 1))
        & (ship_date < datetime.date(1995, 1, 1))
    ).quantity
)
selected_part_supplied = supply_records.part.WHERE(
    STARTSWITH(name, ""forest"") & (BACK(1).availqty > part_qty * 0.5)
)
output = suppliers(
    S_NAME=name,
    S_ADDRESS=address,
).WHERE((nation.name == ""CANADA"") & COUNT(selected_part_supplied) > 0).ORDER_BY(S_NAME.ASC())
pydough.to_df(output)"
Find All Customers in the Asia Region,"SELECT c_custkey, c_name, c_address 
FROM customer c
JOIN nation n ON c.c_nationkey = n.n_nationkey
JOIN region r ON n.n_regionkey = r.r_regionkey
WHERE r_name = 'ASIA';","filter_c= nations.WHERE(region.name == ""ASIA"").customers(
        c_name=name,
        c_address=address,
        n_nation= BACK(1).name
       )"
"Find the total number of orders placed in a specific year
","SELECT COUNT(*) AS total_orders 
FROM orders o 
WHERE strftime('%Y', o.o_orderdate) = '1998';","orders_1998= TPCH(total_orders=COUNT(orders.WHERE(YEAR(order_date) == 1998)))

pydough.to_df(orders_1998)"
total revenue for each customer region.,"SELECT r_name, SUM(l_extendedprice * (1 - l_discount)) AS total_revenue
FROM region r
JOIN nation n ON r_regionkey = n_regionkey
JOIN customer c ON n_nationkey = c_nationkey
JOIN orders o ON c_custkey = o_custkey
JOIN lineitem l ON o_orderkey = l_orderkey
GROUP BY r_name
ORDER BY total_revenue DESC;","%%pydough

line_info = lines(
    region_name=order.customer.nation.region.name,
    revenue=extended_price * (1 - discount),
)
output = PARTITION(line_info, name=""l"", by=(region_name))(
    REGION=region_name,
    REVENUE= SUM(l.revenue)
).ORDER_BY(
    REVENUE.DESC(),
)
pydough.to_df(output)
"
Find the customer who placed the most orders in a specific year,"SELECT o.o_custkey, c.c_name, COUNT(o.o_orderkey) AS order_count
FROM orders o
JOIN customer c ON o.o_custkey = c.c_custkey
WHERE strftime('%Y', o.o_orderdate) = '1992'
GROUP BY o.o_custkey
ORDER BY order_count DESC
LIMIT 1;","%%pydough

line_info = customers(
    key,
    region_name=name,
    num_orders=COUNT(
        orders.WHERE(YEAR(order_date) == 1992)
    ),
)
output = PARTITION(line_info, name=""l"", by=(key,region_name, num_orders))(
    key,
    REGION=region_name,
    NUM_ORDERS=num_orders
).TOP_K(1,
    NUM_ORDERS.DESC(),
)

pydough.to_df(output)"
Find the top 5 customers with the highest total order value:,"SELECT c_custkey, c_name, SUM(l_extendedprice * (1 - l_discount)) AS total_revenue
FROM customer c
JOIN orders o ON c.c_custkey = o.o_custkey
JOIN lineitem l ON o.o_orderkey = l.l_orderkey
GROUP BY c_custkey, c_name
ORDER BY total_revenue DESC
LIMIT 5;","line_info = lines(
    customer_key= order.customer.key,
    customer_name=order.customer.name,
    revenue=extended_price * (1 - discount),
)
output = PARTITION(line_info, name=""l"", by=(customer_key,customer_name))(
    customer_name=customer_name,
    customer_key= customer_key,
    total_revenue=SUM(l.revenue)
).TOP_K(5, by=total_revenue.DESC())
pydough.to_df(output)"
Identify suppliers who have never supplied any parts,,
Number of Orders per Customer made in 1995,"SELECT
    c.c_custkey,
    c.c_name,
    COUNT(o.o_orderkey) AS num_orders
FROM
    customer c
JOIN orders o ON c.c_custkey = o.o_custkey
WHERE
    o.o_orderdate >= DATE('1995-01-01') 
    AND o.o_orderdate < DATE('1996-01-01') 
GROUP BY
    c.c_custkey, c.c_name
ORDER BY
    num_orders DESC;","%%pydough

selected_lines = orders.WHERE(
    (order_date >= datetime.date(1995, 1, 1))
    & (order_date < datetime.date(1996, 1, 1))
)(key=key)

output = customers(
    C_CUSTKEY=key,
    C_NAME=name,
    NUM_ORDERS=COUNT(selected_lines.key),
).TOP_K(20, by=(NUM_ORDERS.DESC()))
pydough.to_df(output)"
Orders Shipped Late in 1998 - Customer Details,,
Determine the number of orders placed in each month of a year:,"SELECT
    strftime('%m', o_orderdate) AS order_month,
    COUNT(o_orderkey) AS num_orders            
FROM
    orders
WHERE
    o_orderdate >= '1998-01-01'  
    AND o_orderdate < '1999-01-01'
GROUP BY
    order_month
ORDER BY
    order_month;","%%pydough

selected_lines = orders(key=key,  o_month=MONTH(order_date),).WHERE(
    (order_date >= datetime.date(1998, 1, 1))
    & (order_date < datetime.date(1999, 1, 1))
)

output = PARTITION(selected_lines, name=""o"", by=(o_month))(
    o_month=o_month,
    num_orders= COUNT(o.key)
)
pydough.to_df(output)"
"Retrieve the names and comments of nations whose names start with the letter ""A""","SELECT N_NAME, N_COMMENT
FROM nation
WHERE N_NAME LIKE 'A%';","%%pydough

# PyDough equivalent using STARTWITH
nations_startwith= nations(n_name=name, n_comment= comment).WHERE(STARTSWITH(name,'A'))

# PyDough equivalent using LIKE
nations_like= nations(n_name=name, n_comment= comment).WHERE(LIKE(name,'A%'))

print(pydough.to_df(nations_startwith))
pydough.to_df(nations_like)"
Retrieve the names of customers who are from Peru.,"SELECT C.C_NAME
FROM customers C
JOIN nation N
ON C.C_NATIONKEY = N.N_NATIONKEY
WHERE N.N_NAME = 'Peru';","%%pydough

peru_nations= customers.WHERE(nation.name == ""PERU"")

customers_from_peru= peru_nations(n_name=name)

pydough.to_df(customers_from_peru)"
" Retrieve the customer IDs and names of customers who have a negative account balance, are not from Brazil, live in the Americas region, and have placed more than 5 orders.","SELECT c.c_custkey, c.c_name
FROM customer c
JOIN orders o ON c.c_custkey = o.o_custkey
JOIN nation n ON c.c_nationkey = n.n_nationkey
JOIN region r ON n.n_regionkey = r.r_regionkey
WHERE c.c_acctbal < 0
  AND n.n_name != 'BRAZIL'
  AND r.r_name = 'AMERICA'
GROUP BY c.c_custkey, c.c_name
HAVING COUNT(o.o_orderkey) > 5;","%%pydough

customer_in_debt= customers(
    name
).WHERE(
    (acctbal < 0) &
    (COUNT(orders) >= 5) &
    (nation.region.name == ""AMERICA"") &
    (nation.name != ""BRAZIL""))

pydough.to_df(customer_in_debt)"
Find the total number of orders per customers placed in 1998,"SELECT c.c_custkey, c.c_name, COUNT(o.o_orderkey) AS total_orders
FROM customer c
JOIN orders o ON c.c_custkey = o.o_custkey
WHERE strftime('%Y', o.o_orderdate) = '1998'  
ORDER BY total_orders DESC;","%%pydough

customers_orders = customers(
    key,
    name,
    # Get the total number of orders placed in 1998 by customer
    num_orders=COUNT(
        orders.WHERE(YEAR(order_date) == 1998)
    ),
).ORDER_BY(num_orders.DESC())
pydough.to_sql(customers_orders)"
" List the names of nations and the count of orders placed by customers from each nation, ordered by the number of orders in descending order.","SELECT n.n_name, COUNT(o.o_orderkey) AS order_count
FROM nation n
JOIN customer c ON n.n_nationkey = c.c_nationkey
JOIN orders o ON c.c_custkey = o.o_custkey
GROUP BY n.n_name
ORDER BY order_count DESC;","%%pydough

orders_by_nation= orders.customer(o_keys= BACK(1).key,region_name=nation.name)
grouped_orders= PARTITION(
    orders_by_nation, name=""o"", by=(region_name)
)(
    region_name,
    orders_count=COUNT(o.o_keys)
).ORDER_BY(orders_count.DESC())
pydough.to_df(grouped_orders)
"
" List the number of orders placed each month in the year 1998, ordered by month.","SELECT
    strftime('%m', o_orderdate) AS order_month,
    COUNT(o_orderkey) AS num_orders            
FROM
    orders
WHERE
    o_orderdate >= '1998-01-01'  
    AND o_orderdate < '1999-01-01'
GROUP BY
    order_month
ORDER BY
    order_month;","%%pydough

selected_lines = orders(key=key,  o_month=MONTH(order_date)).WHERE(
    (order_date >= datetime.date(1995, 1, 1))
    & (order_date < datetime.date(1996, 1, 1))
)

output = PARTITION(selected_lines, name=""o"", by=(o_month))(
    o_month=o_month,
    num_orders= COUNT(o.key)
)
pydough.to_df(output)"
"Identify the customer IDs, names, and total spending of customers from the Asia region who have spent more than 1000 in total on orders.","SELECT c.c_custkey, c.c_name, SUM(o.o_totalprice) AS total_spent
FROM customer c
JOIN orders o ON c.c_custkey = o.o_custkey
JOIN nation n ON c.c_nationkey = n.n_nationkey
JOIN region r ON n.n_regionkey = r.r_regionkey
WHERE r.r_name = 'ASIA'
GROUP BY c.c_custkey, c.c_name
HAVING SUM(o.o_totalprice) > 1000;","%%pydough

filter_c= customers(
        c_key= key,
        c_name=name,
        TOTAL_PRICE=SUM(orders.total_price)
       ).WHERE((TOTAL_PRICE > 1000 ) & (nation.region.name == ""ASIA""))

pydough.to_df(filter_c)"
Calculate the average order value for each region.,"SELECT 
    r.r_name AS Region, 
    AVG(o.o_totalprice) AS AvgOrderValue 
FROM 
    orders o
JOIN 
    customer c ON o.o_custkey = c.c_custkey
JOIN 
    nation n ON c.c_nationkey = n.n_nationkey
JOIN 
    region r ON n.n_regionkey = r.r_regionkey
GROUP BY 
    r.r_name;","%%pydough

selected_customers = customers(customer_region_name= nation.region.name).orders( 
orders_price=total_price, customer_region_name= BACK(1).customer_region_name
)
output = PARTITION(selected_customers, ""cust"", by=customer_region_name)(
    REGION_NAME=customer_region_name,
    TOTALREVENUE= AVG(cust.orders_price)
)
pydough.to_df(output)"
Find the top 5 regions with the highest total revenue from orders.,"SELECT 
    r.r_name AS RegionName, 
    SUM(o.o_totalprice) AS TotalRevenue
FROM 
    region r
JOIN nation n ON r.r_regionkey = n.n_regionkey
JOIN customer c ON n.n_nationkey = c.c_nationkey
JOIN orders o ON c.c_custkey = o.o_custkey
GROUP BY 
    r.r_name
ORDER BY 
    TotalRevenue DESC
LIMIT 5;","%%pydough

selected_customers = customers(customer_region_name= nation.region.name).orders( 
orders_price=total_price, customer_region_name= BACK(1).customer_region_name
)
output = PARTITION(selected_customers, ""cust"", by=customer_region_name)(
    REGION_NAME=customer_region_name,
    TOTALREVENUE= SUM(cust.orders_price)
).TOP_K(5, by=TOTALREVENUE.DESC())
pydough.to_df(output)"
"For each region and nation, calculate the maximum and minimum order values, the difference between them, and the total number of orders, ordered by the order value difference in descending order.","SELECT 
    r.r_name AS region_name,
    n.n_name AS nation_name,
    MAX(o.o_totalprice) AS max_order_value,
    MIN(o.o_totalprice) AS min_order_value,
    MAX(o.o_totalprice) - MIN(o.o_totalprice) AS order_value_difference,
    COUNT(o.o_orderkey) AS total_orders
FROM region r
JOIN nation n ON r.r_regionkey = n.n_regionkey  
JOIN customer c ON c.c_nationkey = n.n_nationkey
JOIN orders o ON o.o_custkey = c.c_custkey
GROUP BY r.r_name, n.n_name
ORDER BY order_value_difference DESC;","%%pydough
selected_customers= customers(region_name= nation.region.name, nation_name= nation.name)

selected_orders= selected_customers.orders(BACK(1).region_name, BACK(1).nation_name,
total_price=total_price)

output= PARTITION(selected_orders, ""o"", by=(region_name, nation_name))(
    region_name=region_name,
    nation_name= nation_name,
    max_order_value= MAX(o.total_price),
    min_order_value= MIN(o.total_price),
    order_value_difference= MAX(o.total_price) - MIN(o.total_price),
    total_orders= COUNT(o.total_price)
).ORDER_BY(order_value_difference.DESC())

pydough.to_df(output)"
"List the nations and the count of customers in the ""Machinery"" and ""Automobile"" market segments, ordered by the number of customers in descending order.","SELECT 
    n.n_name AS nation_name,
    COUNT(c.c_custkey) AS customer_count
FROM nation n
JOIN customer c ON c.c_nationkey = n.n_nationkey
WHERE c.c_mktsegment IN ('MACHINERY', 'AUTOMOBILE') 
GROUP BY n.n_name
ORDER BY customer_count DESC;","%%pydough

customer_mktsegment= customers.WHERE(ISIN(mktsegment, ('MACHINERY', 'AUTOMOBILE')))
selected_customers= customer_mktsegment(nation_name=nation.name, key=key)

output= PARTITION(selected_customers, name=""cust"", by=(nation_name))(
    nation_name= nation_name,
    customer_count= COUNT(cust.key)
).ORDER_BY(customer_count.DESC())

pydough.to_df(output)"
"Calculate the percentage of high-priority orders (e.g., '1-URGENT', '2-HIGH') for each region.","SELECT r.r_name AS region_name, 
  ROUND(
    SUM(
      CASE 
        WHEN o.o_orderpriority IN ('1-URGENT', '2-HIGH') THEN 1 
        ELSE 0 
      END
    ) * 100.0 / COUNT(o.o_orderkey),
    2
  ) AS high_priority_percentage
  
FROM orders o
JOIN customer c ON o.o_custkey = c.c_custkey
JOIN nation n ON c.c_nationkey = n.n_nationkey
JOIN region r ON n.n_regionkey = r.r_regionkey
GROUP BY r.r_name
ORDER BY high_priority_percentage DESC;","%%pydough

customer_regions= customers(region_name=nation.region.name)
selected_orders= customer_regions.orders(key, region_name= BACK(1).region_name, is_prioritary=IFF(ISIN(order_priority,('1-URGENT', '2-HIGH')),1,0))

output= PARTITION(selected_orders, name=""o"", by=(region_name))(
    region_name= region_name,
    high_priority_percentage= ROUND((SUM(o.is_prioritary) * 100 ) / COUNT(o.key),2)
).ORDER_BY(high_priority_percentage.DESC())

pydough.to_df(output)"
 Customers Who Have Never Placed Orders,"SELECT c.c_custkey, c.c_name
FROM customer c
LEFT JOIN orders o ON c.c_custkey = o.o_custkey
WHERE o.o_orderkey IS NULL;","%%pydough

customers_without_orders= customers.WHERE(HASNOT(orders)==1)
selected_customers = customers_without_orders(key, name)


pydough.to_df(selected_customers)"
"How many total, active, and inactive customers are there in each nation, sorted by the total number of customers?","SELECT
    n.n_name,
    COUNT(DISTINCT c.c_custkey) AS total_customers,
    COUNT(DISTINCT CASE WHEN o.o_orderkey IS NOT NULL THEN c.c_custkey END) AS active_customers,
    COUNT(DISTINCT CASE WHEN o.o_orderkey IS NULL THEN c.c_custkey END) AS inactive_customers
FROM
    nation n
JOIN customer c ON n.n_nationkey = c.c_nationkey
LEFT JOIN orders o ON c.c_custkey = o.o_custkey
GROUP BY n.n_name
ORDER BY total_customers DESC;","%%pydough

selected_customers = customers(customer_nation_name= nation.name, 
active_customers=KEEP_IF(key,HAS(orders)),
inactive_customers= KEEP_IF(key, HASNOT(orders))
)
output = PARTITION(selected_customers, ""cust"", by=customer_nation_name)(
    NATION_NAME=customer_nation_name,
    TOTAL_CUSTOMERS= COUNT(cust.key),
    ACTIVE_CUSTOMERS=NDISTINCT(cust.active_customers),
    INACTIVE_CUSTOMERS=NDISTINCT(cust.inactive_customers),
).ORDER_BY(TOTAL_CUSTOMERS.DESC())
pydough.to_df(output)"
Retrieve customers who belong to the top 10% in account balance but rank in the bottom 25% in terms of order activity,"SELECT c_name, c_acctbal, total_orders
FROM (
    SELECT 
        c.c_name,
        c.c_acctbal,
        COUNT(o.o_orderkey) AS total_orders,
        PERCENT_RANK() OVER (ORDER BY c.c_acctbal DESC) AS balance_percentile,
        PERCENT_RANK() OVER (ORDER BY COUNT(o.o_orderkey)) AS order_activity_percentile
    FROM customer c
    LEFT JOIN orders o ON c.c_custkey = o.o_custkey
    GROUP BY c.c_custkey, c.c_name, c.c_acctbal
) sub
WHERE 
    balance_percentile <= 0.1  
    AND order_activity_percentile <= 0.25 
ORDER BY c_acctbal DESC;","%%pydough

customers_activity= customers.WHERE((PERCENTILE(by=acctbal.DESC()) <= 10) & (PERCENTILE(by=COUNT(orders.key).ASC()) <= 25))

selected_customers= customers_activity(key, name, acctbal)

output= PARTITION(selected_customers, name=""cust"", by=(key, name, acctbal))(
    key= key,
    name= name,
    acctbal= acctbal
).ORDER_BY(acctbal.DESC())
pydough.to_df(output)"
"Which region has the highest total supply cost, considering the supply cost and available quantity for suppliers across different nations?","SELECT r_name AS region_name, SUM(ps_supplycost * ps_availqty) AS total_supply_cost
FROM region
JOIN nation ON r_regionkey = n_regionkey
JOIN supplier ON n_nationkey = s_nationkey
JOIN partsupp ON s_suppkey = ps_suppkey
GROUP BY r_name
ORDER BY total_supply_cost DESC;","%%pydough

supply= supply_records(region_name= supplier.nation.region.name, supply_cost= supplycost, availqty= availqty)

supply_cost_by_regions= PARTITION(
    supply, name=""supp"", by=region_name
)(region_name,total_supply_cost= SUM(supp.supplycost * supp.availqty))

sort= supply_cost_by_regions.ORDER_BY(total_supply_cost.DESC())

pydough.to_df(sort)"
Find the top 5 parts with the highest supply cost.,"SELECT p_name AS part_name, ps_supplycost AS supply_cost
FROM part
JOIN partsupp ON p_partkey = ps_partkey
ORDER BY ps_supplycost DESC
LIMIT 5;","%%pydough

parts_by_supplycost = supply_records.part(part_name= name, supply_cost= BACK(1).supplycost)


output=parts_by_supplycost.TOP_K(5,supply_cost.DESC())

pydough.to_df(output)"
"Find the parts that contain ""STEEL"" in their name and show the total available quantity, ordered by the highest available quantity.","SELECT p_name, SUM(ps_availqty) AS total_available
FROM part
JOIN partsupp ON p_partkey = ps_partkey
WHERE p_name LIKE '%STEEL%'
GROUP BY p_name
ORDER BY total_available DESC;","%%pydough

availability_parts= supply_records.WHERE(CONTAINS(part.name, ""steel""))(part_name= part.name)

output= PARTITION(availability_parts, name=""supp"", by=part_name)(
    part_name= part_name,
    total_available= SUM(supp.availqty)
).ORDER_BY(total_available.DESC())
pydough.to_df(output)"
"Find suppliers in each nation who supply more than 1000 units of parts with 'BRASS' in their type.
","SELECT 
    s.s_name AS SupplierName,
    n.n_name AS Nation,
    SUM(ps.ps_availqty) AS TotalUnitsSupplied
FROM supplier s
JOIN nation n ON s.s_nationkey = n.n_nationkey
JOIN partsupp ps ON s.s_suppkey = ps.ps_suppkey
JOIN part p ON ps.ps_partkey = p.p_partkey
WHERE 
    p.p_type LIKE '%BRASS%'
GROUP BY s.s_name, n.n_name
HAVING SUM(ps.ps_availqty) > 1000
ORDER BY TotalUnitsSupplied DESC;
","%%pydough

availability_parts= supply_records.WHERE(CONTAINS(part.part_type, ""BRASS""))(supplier_name= supplier.name, nation= supplier.nation.name)

output= PARTITION(availability_parts, name=""supp"", by=(supplier_name,nation))(
    supplier_name= supplier_name,
    nation= nation,
    total_units_supplied= SUM(supp.availqty)
).WHERE(total_units_supplied > 1000).ORDER_BY(total_units_supplied.DESC())
pydough.to_df(output)
"
"Find parts that are supplied by at least 5 different nations.
","SELECT 
    p.P_NAME AS PartName,
    COUNT(DISTINCT n.N_NAME) AS NumberOfNations
FROM PART p
JOIN PARTSUPP ps ON p.P_PARTKEY = ps.PS_PARTKEY
JOIN SUPPLIER s ON ps.PS_SUPPKEY = s.S_SUPPKEY
JOIN NATION n ON s.S_NATIONKEY = n.N_NATIONKEY
GROUP BY p.P_NAME
HAVING COUNT(DISTINCT n.N_NAME) > 5
ORDER BY NumberOfNations DESC;","%%pydough

availability_parts= supply_records(part_name= part.name, nation= supplier.nation.name)

output= PARTITION(availability_parts, name=""supp"", by=(part_name))(
    part_name= part_name,
    number_of_nations= NDISTINCT(supp.nation)
).WHERE(number_of_nations > 5).ORDER_BY(number_of_nations.DESC())
pydough.to_df(output)"
"Which 10 customers purchased the highest quantity of products with ""green"" in the product name during 1998? Provide their names, adress and the total quantity ordered.

","SELECT c_name AS customer_name, c_address AS customer_address, SUM(l_quantity) AS total_quantity_ordered
FROM customer
JOIN orders ON c_custkey = o_custkey
JOIN lineitem ON o_orderkey = l_orderkey
JOIN part ON l_partkey = p_partkey
WHERE p_name LIKE '%green%'
  AND strftime('%Y', o_orderdate) = '1998'
GROUP BY c_name, c_address
ORDER BY total_quantity_ordered DESC
LIMIT 10;","%%pydough

selected_orders = orders.WHERE(YEAR(order_date) == 1998)
selected_lines = selected_orders.lines.WHERE(
    CONTAINS(part.name, ""green"")
)
result = customers(
    name,
    address,
    total_quantity=SUM(selected_lines.quantity)
).TOP_K(10, by=total_quantity.DESC())
pydough.to_df(result)"
"Find the top 10 suppliers supplying ECONOMY parts (by total quantity).","SELECT 
    s.S_NAME AS SupplierName,
    SUM(ps.AVAILQTY) AS TotalQuantitySupplied
FROM SUPPLIER s
JOIN PARTSUPP ps ON s.S_SUPPKEY = ps.PS_SUPPKEY
JOIN PART p ON ps.PS_PARTKEY = p.P_PARTKEY
WHERE p.P_BRAND LIKE 'ECONOMY%'
GROUP BY s.S_NAME
ORDER BY TotalQuantitySupplied DESC
LIMIT 10;",
Retrieve all parts," SELECT
     p.p_name
 FROM
     part p","%%pydough

output = parts(name)

pydough.to_df(output)"
Retrieve all parts where the retail price is greater than 2000," SELECT
     p.p_name
 FROM
     part p
 WHERE 
     p.p_retail_price > 2000","%%pydough

parts_list = parts.WHERE(retail_price > 2000)
pydough.to_df(parts_list)"
Retrieve the 100 priciest parts by retail price," SELECT
     *
 FROM
     part p
 ORDER BY
     p.p_retailprize DESC","%%pydough

priciest_parts = parts.TOP_K(100, by=retail_price.DESC())
pydough.to_df(priciest_parts)"
"Retrieve the name, supplier name and supply cost of all brasstype products"," SELECT
     p.p_name,
     s.s_name,
     ps.ps_supplycost
 FROM
     part p
 JOIN
     partsupp ps ON p.p_partkey = ps.ps_partkey
 JOIN
     supplier s ON ps.ps_suppkey = s.s_suppkey
 WHERE
     p.p_type LIKE '%BRASS%';","%%pydough

tables = suppliers.supply_records.part

filter = tables.WHERE(CONTAINS(part_type, ""BRASS""))

output = filter(product_name=name, supplier_name = BACK(2).name, supply_cost = BACK(1).supplycost)

pydough.to_df(output)"
Provide the suppliers who supply parts called STANDARD BRUSHED TIN,"SELECT
    s.s_name
 FROM
    supplier s
 JOIN
    partsupp ps ON s.s_suppkey = ps.ps_suppkey
JOIN 
    part p on ps.ps_partkey = p.p_partkey
WHERE
    p.p_type = 'STANDARD BRUSHED TIN'","%%pydough

parts_supp_partsupp= suppliers.supply_records.part

filter = parts_supp_partsupp.WHERE(part_type == ""STANDARD BRUSHED TIN"")

pydough.to_sql(filter(BACK(2).name, part_type, name))"
Provide the parts named LAVENDER SPRING that have a stock of 10+ from ordered by cheaper first with it's available stock and its supplier,"SELECT
    p.p_name,
    s.s_name,
    ps.ps_supplycost,
    ps.ps_availqty
 FROM
    supplier s
 JOIN
    partsupp ps ON s.s_suppkey = ps.ps_suppkey
JOIN 
    part p on ps.ps_partkey = p.p_partkey
WHERE
    p.p_name LIKE 'LAVENDER SPRING%' AND
    ps.ps_availqty >= 10
ORDER BY
    ps.ps_supplycost ASC
LIMIT 1;","%%pydough

tables = suppliers.supply_records

filter = tables.WHERE(availqty >= 10).part.WHERE(CONTAINS(name, ""LAVENDER SPRING"")).TOP_K(1, by=BACK(1).supplycost.ASC())

output = filter(product_name=name, supplier_name = BACK(2).name, supply_cost = BACK(1).supplycost, avail_quantity = BACK(1).availqty)

pydough.to_df(output)"
"Provide the top 10 suppliers, part name, supply cost, available quantity and country of origin of all the Green Dodger products with a Bold style that are made by Brand#42; ordered by highest available quantity","SELECT
    p.p_name,
    s.s_name,
    ps.ps_supplycost,
    ps.ps_availqty,
    n.n_name
 FROM
    supplier s
 JOIN
    partsupp ps ON s.s_suppkey = ps.ps_suppkey
JOIN 
    part p on ps.ps_partkey = p.p_partkey
JOIN
    nation n on s.s_nationkey = n.n_nationkey
WHERE
    p.p_name LIKE '%GREEN DODGER%' AND
    p.p_brand LIKE '%Brand#41%' AND
    p.p_comment LIKE '%bold%'
ORDER BY
    ps.ps_availqty DESC
LIMIT 10;","tables = nations.suppliers.supply_records.part

filter = tables.WHERE(CONTAINS(name, ""GREEN DODGER"") & (brand == ""Brand#41"") & CONTAINS(comment, ""bold"")).TOP_K(10, by=BACK(1).availqty.DESC())

output = filter(product_name=name, supplier_name = BACK(2).name, supply_cost = BACK(1).supplycost, avail_quantity = BACK(1).availqty, country_of_origin = BACK(3).name)

pydough.to_df(output)"
How many parts does each registered supplier handle?,"SELECT
    s.s_name,
    COUNT(*)
 FROM
    partsupp ps
 JOIN
     supplier s ON s.s_suppkey = ps.ps_suppkey
 GROUP BY
     s.s_name","%%pydough

tables = supply_records.supplier

filter = PARTITION(tables, name=""t"", by=(name))

output = filter(name, products_by_supp = COUNT(t.key))

pydough.to_df(output)"
Find the Average order amount for each customer segment in each region,"SELECT
    n.n_name AS region_name,
    c.c_mktsegment AS customer_segment,
    AVG(l.l_extendedprice * (1 - l.l_discount)) AS average_order_amount
FROM
    CUSTOMER AS c
JOIN
    ORDERS AS o ON c.c_custkey = o.o_custkey
JOIN
    LINEITEM AS l ON o.o_orderkey = l.l_orderkey
JOIN
    NATION AS n ON c.c_nationkey = n.n_nationkey
JOIN
    REGION AS r ON n.n_regionkey = r.r_regionkey
GROUP BY
    n.n_name,
    c.c_mktsegment
ORDER BY
    n.n_name,
    c.c_mktsegment;","%%pydough

tables = regions.nations.customers.orders.lines(countries_names = tables.BACK(3).name , customer_mktsgm = tables.BACK(2).mktsegment)

partitioned_tables = PARTITION(tables, name=""tabs"", by=(countries_names, customer_mktsgm))(average_order_amount = AVG(tabs.extended_price * (1 - tabs.discount)))

ordered_tables= partitioned_tables.ORDER_BY(countries_names.ASC(), customer_mktsgm.ASC())

output = ordered_tables(countries_names, customer_mktsgm, average_order_amount)

pydough.to_df(output)"
"Find the suppliers of each region that supply STEEL parts with size bigger than 20, provide the number of parts they supply that comply with the aforementioned conditions","SELECT
    s.S_NAME AS SupplierName,
    n.N_NAME AS Nation,
    r.R_NAME AS Region,
    COUNT(DISTINCT p.P_PARTKEY) AS NumberOfPartsSupplied
FROM
    SUPPLIER s
JOIN
    NATION n ON s.S_NATIONKEY = n.N_NATIONKEY
JOIN
    REGION r ON n.N_REGIONKEY = r.R_REGIONKEY
JOIN
    PARTSUPP ps ON s.S_SUPPKEY = ps.PS_SUPPKEY
JOIN
    PART p ON ps.PS_PARTKEY = p.P_PARTKEY
WHERE
    p.P_SIZE > 20  AND p.P_TYPE LIKE '%STEEL%'  -- Example filtering criteria
GROUP BY
    s.S_NAME, n.N_NAME, r.R_NAME
ORDER BY
    r.R_NAME, n.N_NAME, s.S_NAME;","%%pydough

tables = regions.nations.suppliers.supply_records.part(sup_name = BACK(2).name, nation_name = BACK(3).name, region_name = BACK(4).name)

filtered_tables = tables.WHERE((size > 20) & (CONTAINS(part_type, 'STEEL')))

partitioned_tables = PARTITION(filtered_tables, name = ""tabs"", by=(sup_name, nation_name, region_name))(number_of_parts_supplied = NDISTINCT(tabs.key))

ordered_tables = partitioned_tables.ORDER_BY(region_name.ASC(), nation_name.ASC(), sup_name.ASC())

output = ordered_tables(sup_name, nation_name, region_name, number_of_parts_supplied)

print(pydough.to_df(output))"
Analize the revenue of every year from every manufacturer of Brand#13,"SELECT
    SUBSTR(CAST(o.O_ORDERDATE AS VARCHAR(10)), 1, 4) AS OrderYear,  -- Extract the year
    p.P_MFGR AS PartManufacturer,
    SUM(l.L_EXTENDEDPRICE * (1 - l.L_DISCOUNT)) AS TotalRevenue
FROM
    ORDERS o
JOIN
    LINEITEM l ON o.O_ORDERKEY = l.L_ORDERKEY
JOIN
    PART p ON l.L_PARTKEY = p.P_PARTKEY
WHERE
    p.P_BRAND LIKE 'Brand#13%' -- Example brand filter
GROUP BY
    OrderYear, p.P_MFGR
ORDER BY
    OrderYear, TotalRevenue DESC;","%%pydough

tables = orders.lines.part

filtered_tables = tables.WHERE(brand == ""Brand#13"")(order_year = YEAR(BACK(2).order_date), ext_price = BACK(1).extended_price, disc = BACK(1).discount)

partitioned_tables = PARTITION(filtered_tables, name = ""tabs"", by=(order_year, manufacturer))(
    number_of_parts_supplied = NDISTINCT(tabs.key), revenue = SUM(tabs.ext_price * (1 - tabs.disc)))

ordered_tables = partitioned_tables.ORDER_BY(order_year.ASC(), revenue.DESC())

output = ordered_tables(order_year, manufacturer, revenue)

print(pydough.to_df(output))"
Give me a list of the customers that have placed  orders and display their names,"SELECT
            NAME
        FROM
            CUSTOMER
        WHERE
            C_CUSTKEY IN (SELECT O_CUSTKEY FROM ORDERS)","%%pydough

active_custs = customers.WHERE(HAS(orders) == 1)(Customer_name = name)

pydough.to_df(active_custs)"
"This query aims to identify which three regions generate the highest total sales and who are the main suppliers contributing to those sales. The objective is to assess sales performance by geographic region and to understand which suppliers dominate each region.

Total sales is defined as the extended price times one less discount.","SELECT
    R_NAME AS region_name,
    S_NAME AS supplier_name,
    SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS total_sales
FROM
    REGION
JOIN
    NATION ON R_REGIONKEY = N_REGIONKEY
JOIN
    SUPPLIER ON N_NATIONKEY = S_NATIONKEY
JOIN
    PARTSUPP ON S_SUPPKEY = PS_SUPPKEY
JOIN
    LINEITEM ON PS_PARTKEY = L_PARTKEY AND PS_SUPPKEY = L_SUPPKEY
GROUP BY
    R_NAME, S_NAME
ORDER BY
    total_sales DESC
LIMIT 3;","supplier = suppliers(region_name=nation.region.name, supplier_name=name)

output = PARTITION(supplier, name=""part"", by=(region_name, supplier_name))(
    region_name,
    supplier_name,
    total_sales=SUM(part.lines.extended_price * (1 - part.lines.discount))
).TOP_K(3, by=total_sales.DESC())"
"This query seeks to analyze which are the five customers that return the most orders. The idea is to find the name of the customer, the segment to which it belongs and the total of returned orders.","SELECT
    C_NAME AS customer_name,
    C_MKTSEGMENT AS market_segment,
    COUNT(*) AS return_count
FROM
    CUSTOMER
JOIN
    ORDERS ON C_CUSTKEY = O_CUSTKEY
JOIN
    LINEITEM ON O_ORDERKEY = L_ORDERKEY
WHERE
    L_RETURNFLAG = 'R'  -- 'R' indicates a returned/cancelled item
GROUP BY
    C_NAME, C_MKTSEGMENT
ORDER BY
    return_count DESC
LIMIT 5;","output = PARTITION(customers, name=""cust"", by=(name, mktsegment))(
    customer_name=name,
    market_segment=mktsegment,
    return_count=COUNT(cust.orders.lines.WHERE(return_flag == ""R""))
).TOP_K(5, by=return_count.DESC())"
"The idea is to select the 20 customers who have bought the most according to the money invested. The customer is identified by his id and name, and we also want to know the nation and region to which he belongs, as well as the total number of orders and how much he has spent on them. ","WITH CustomerPurchases AS (
    SELECT 
        O_CUSTKEY, 
        COUNT(DISTINCT O_ORDERKEY) AS TotalOrders, 
        SUM(L_EXTENDEDPRICE * (1 - L_DISCOUNT)) AS TotalSpent
    FROM ORDERS
    JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY
    GROUP BY O_CUSTKEY
), CustomerInfo AS (
    SELECT 
        C_CUSTKEY, 
        C_NAME,
        N_NAME AS Nation,
        R_NAME AS Region
    FROM CUSTOMER
    JOIN NATION ON C_NATIONKEY = N_NATIONKEY
    JOIN REGION ON N_REGIONKEY = R_REGIONKEY
)
SELECT 
    C.C_CUSTKEY AS customer_id, 
    C.C_NAME AS customer_name, 
    C.Nation, 
    C.Region, 
    P.TotalOrders,
    P.TotalSpent
FROM CustomerPurchases P
JOIN CustomerInfo C ON P.O_CUSTKEY = C.C_CUSTKEY
ORDER BY P.TotalSpent DESC
LIMIT 20;","output = customers(
    customer_id=key,
    customer_name=name,
    Nation=nation.name,
    Region=nation.region.name,
    TotalOrders=COUNT(orders),
    TotalSpent=SUM(orders.lines.extended_price * (1 - orders.lines.discount))
).TOP_K(20, TotalSpent.DESC())"
"Average discount applied on orders for each market segment. 
This query allows you to analyze which market segments receive higher discounts on their orders. This can help assess whether discount strategies are aligned with business objectives and whether certain segments are getting too high or too low discounts compared to others.","SELECT 
    C.C_MKTSEGMENT AS MarketSegment,
    AVG(L.L_DISCOUNT) * 100 AS AvgDiscountPercentage
FROM CUSTOMER C
JOIN ORDERS O ON C.C_CUSTKEY = O.O_CUSTKEY
JOIN LINEITEM L ON O.O_ORDERKEY = L.L_ORDERKEY
GROUP BY C.C_MKTSEGMENT
ORDER BY AvgDiscountPercentage DESC;","output = PARTITION(customers, name=""part"", by=mktsegment)(
    MarketSegment=mktsegment,
    AvgDiscountPercentage=AVG(part.orders.lines.discount)*100
).ORDER_BY(AvgDiscountPercentage.DESC())"
"This query allows you to identify the countries that generate the most sales and the total revenue generated in each. It is useful for assessing business performance in different markets and making strategic decisions on expansion, resource allocation and optimization of logistics and distribution.

Total revenues is defined as the sum of (extended price times one less discount).","SELECT 
    N.N_NAME AS Nation,
    COUNT(DISTINCT O.O_ORDERKEY) AS TotalOrders,
    SUM(L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT)) AS TotalSales
FROM NATION N
JOIN CUSTOMER C ON N.N_NATIONKEY = C.C_NATIONKEY
JOIN ORDERS O ON C.C_CUSTKEY = O.O_CUSTKEY
JOIN LINEITEM L ON O.O_ORDERKEY = L.L_ORDERKEY
WHERE L.L_LINESTATUS = 'O'
GROUP BY N.N_NAME
ORDER BY TotalSales DESC
LIMIT 10;","selected_lines = lines(Nation=order.customer.nation.name).WHERE(LIKE(status,""O""))

output = PARTITION(selected_lines, name=""part"", by=Nation)(
    Nation=Nation,
    TotalOrders=NDISTINCT(part.order.key),
    TotalSales=SUM(part.extended_price * (1 - part.discount))
).TOP_K(10, by=TotalSales.DESC())"
"This query identifies customers with the highest average spend per order. It is useful for segmenting high-value customers, customizing loyalty strategies and optimizing sales campaigns focused on customers with higher purchasing power.

Get the top 10 customers with the most orders.","SELECT 
    C.C_NAME AS CustomerName,
    C.C_MKTSEGMENT AS MarketSegment,
    COUNT(DISTINCT O.O_ORDERKEY) AS TotalOrders,
    SUM(L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT)) AS TotalSpent,
    (SUM(L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT)) / COUNT(DISTINCT O.O_ORDERKEY)) AS AvgOrderValue
FROM CUSTOMER C
JOIN ORDERS O ON C.C_CUSTKEY = O.O_CUSTKEY
JOIN LINEITEM L ON O.O_ORDERKEY = L.L_ORDERKEY
WHERE L.L_LINESTATUS = 'O'
GROUP BY C.C_NAME, C.C_MKTSEGMENT
ORDER BY TotalOrders DESC
LIMIT 10;","selected_lines = lines(
    CustomerName=order.customer.name,
    MarketSegment=order.customer.mktsegment,
).WHERE(LIKE(status,""O""))

partition = PARTITION(selected_lines, name=""part"", by=(CustomerName, MarketSegment))(
    CustomerName,
    MarketSegment,
    TotalOrders=NDISTINCT(part.order.key),
    TotalSpent=SUM(part.extended_price * (1 - part.discount))
).TOP_K(10, by=TotalOrders.DESC())

output = partition(
    CustomerName,
    MarketSegment,
    TotalOrders,
    TotalSpent,
    AvgOrderValue=(TotalSpent / TotalOrders)
)
"
"This query identifies the product categories that have generated the highest sales volume, allowing you to optimize inventories, adjust pricing strategies and focus marketing efforts on the most profitable products.","SELECT 
    P.P_TYPE AS ProductCategory,
    SUM(L.L_QUANTITY) AS TotalUnitsSold,
    SUM(L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT)) AS TotalRevenue
FROM PART P
JOIN LINEITEM L ON P.P_PARTKEY = L.L_PARTKEY
WHERE L.L_LINESTATUS = 'O'
GROUP BY P.P_TYPE
ORDER BY TotalUnitsSold DESC
LIMIT 10;","selected_lines = lines(
    ProductCategory=part.part_type
).WHERE(LIKE(status,""O""))

output = PARTITION(selected_lines, name=""part"", by=ProductCategory)(
    ProductCategory,
    TotalUnitsSold=SUM(part.quantity),
    TotalRevenue=SUM(part.extended_price * (1 - part.discount))
).TOP_K(10, TotalUnitsSold.DESC())"